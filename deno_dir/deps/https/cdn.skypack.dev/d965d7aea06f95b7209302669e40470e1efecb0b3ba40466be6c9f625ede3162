var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
function t() {
  return (t = Object.assign || function(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var n2 = arguments[e2];
      for (var r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (t2[r2] = n2[r2]);
    }
    return t2;
  }).apply(this, arguments);
}
var e = {__proto__: null, default: function(t2, e2) {
  return e2 = e2 || {}, new Promise(function(n2, r2) {
    var s2 = new XMLHttpRequest(), i2 = [], a2 = [], o2 = {}, u2 = function() {
      return {ok: (s2.status / 100 | 0) == 2, statusText: s2.statusText, status: s2.status, url: s2.responseURL, text: function() {
        return Promise.resolve(s2.responseText);
      }, json: function() {
        return Promise.resolve(s2.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([s2.response]));
      }, clone: u2, headers: {keys: function() {
        return i2;
      }, entries: function() {
        return a2;
      }, get: function(t3) {
        return o2[t3.toLowerCase()];
      }, has: function(t3) {
        return t3.toLowerCase() in o2;
      }}};
    };
    for (var c2 in s2.open(e2.method || "get", t2, true), s2.onload = function() {
      s2.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(t3, e3, n3) {
        i2.push(e3 = e3.toLowerCase()), a2.push([e3, n3]), o2[e3] = o2[e3] ? o2[e3] + "," + n3 : n3;
      }), n2(u2());
    }, s2.onerror = r2, s2.withCredentials = e2.credentials == "include", e2.headers)
      s2.setRequestHeader(c2, e2.headers[c2]);
    s2.send(e2.body || null);
  });
}}, n = self.fetch || (self.fetch = e.default || e);
class r extends Error {
  constructor(t2, ...e2) {
    super(`${t2.status} ${t2.statusText}`, ...e2), this.response = void 0, this.response = t2;
  }
}
class s {
  constructor(t2) {
    this.apiKey = void 0, this.apiEnv = void 0, this.apiKey = t2.apiKey, this.apiEnv = t2.apiEnv || "production";
  }
  async request(e2, s3) {
    const i2 = function(t2) {
      const e3 = {development: "https://dev-api.truestamp.com/v1/", staging: "https://staging-api.truestamp.com/v1/", production: "https://api.truestamp.com/v1/"}[t2];
      if (!e3)
        throw new Error(`Unknown environment: ${t2}`);
      return e3;
    }(this.apiEnv) + e2, a2 = t({}, s3, {headers: {Authorization: "Bearer " + this.apiKey, "Content-Type": "application/json", Accept: "application/json"}});
    let o2 = await n(i2, a2);
    !function(t2) {
      if (t2.ok)
        return t2;
      throw new r(t2);
    }(o2);
    let u2 = await o2.json();
    return new Promise((t2) => {
      t2(u2);
    });
  }
}
var i = Object.create, a = Object.defineProperty, o = Object.getOwnPropertyDescriptor, u = Object.getOwnPropertyNames, c = Object.getPrototypeOf, h = Object.prototype.hasOwnProperty, l = (t2, e2) => function() {
  return e2 || (0, t2[u(t2)[0]])((e2 = {exports: {}}).exports, e2), e2.exports;
}, d = (t2, e2, n2) => (n2 = t2 != null ? i(c(t2)) : {}, ((t3, e3, n3, r2) => {
  if (e3 && typeof e3 == "object" || typeof e3 == "function")
    for (let n4 of u(e3))
      h.call(t3, n4) || n4 === void 0 || a(t3, n4, {get: () => e3[n4], enumerable: !(r2 = o(e3, n4)) || r2.enumerable});
  return t3;
})(!e2 && t2 && t2.l ? n2 : a(n2, "default", {value: t2, enumerable: true}), t2)), f = l({"node_modules/@stablelib/int/lib/int.js"(t2) {
  Object.defineProperty(t2, "l", {value: true}), t2.mul = Math.imul || function(t3, e2) {
    var n2 = 65535 & t3, r2 = 65535 & e2;
    return n2 * r2 + ((t3 >>> 16 & 65535) * r2 + n2 * (e2 >>> 16 & 65535) << 16 >>> 0) | 0;
  }, t2.add = function(t3, e2) {
    return t3 + e2 | 0;
  }, t2.sub = function(t3, e2) {
    return t3 - e2 | 0;
  }, t2.rotl = function(t3, e2) {
    return t3 << e2 | t3 >>> 32 - e2;
  }, t2.rotr = function(t3, e2) {
    return t3 << 32 - e2 | t3 >>> e2;
  }, t2.isInteger = Number.isInteger || function(t3) {
    return typeof t3 == "number" && isFinite(t3) && Math.floor(t3) === t3;
  }, t2.MAX_SAFE_INTEGER = 9007199254740991, t2.isSafeInteger = function(e2) {
    return t2.isInteger(e2) && e2 >= -t2.MAX_SAFE_INTEGER && e2 <= t2.MAX_SAFE_INTEGER;
  };
}}), m = l({"node_modules/@stablelib/binary/lib/binary.js"(t2) {
  Object.defineProperty(t2, "l", {value: true});
  var e2 = f();
  function n2(t3, e3, n3) {
    return e3 === void 0 && (e3 = new Uint8Array(2)), n3 === void 0 && (n3 = 0), e3[n3 + 0] = t3 >>> 8, e3[n3 + 1] = t3 >>> 0, e3;
  }
  function r2(t3, e3, n3) {
    return e3 === void 0 && (e3 = new Uint8Array(2)), n3 === void 0 && (n3 = 0), e3[n3 + 0] = t3 >>> 0, e3[n3 + 1] = t3 >>> 8, e3;
  }
  function s2(t3, e3) {
    return e3 === void 0 && (e3 = 0), t3[e3] << 24 | t3[e3 + 1] << 16 | t3[e3 + 2] << 8 | t3[e3 + 3];
  }
  function i2(t3, e3) {
    return e3 === void 0 && (e3 = 0), (t3[e3] << 24 | t3[e3 + 1] << 16 | t3[e3 + 2] << 8 | t3[e3 + 3]) >>> 0;
  }
  function a2(t3, e3) {
    return e3 === void 0 && (e3 = 0), t3[e3 + 3] << 24 | t3[e3 + 2] << 16 | t3[e3 + 1] << 8 | t3[e3];
  }
  function o2(t3, e3) {
    return e3 === void 0 && (e3 = 0), (t3[e3 + 3] << 24 | t3[e3 + 2] << 16 | t3[e3 + 1] << 8 | t3[e3]) >>> 0;
  }
  function u2(t3, e3, n3) {
    return e3 === void 0 && (e3 = new Uint8Array(4)), n3 === void 0 && (n3 = 0), e3[n3 + 0] = t3 >>> 24, e3[n3 + 1] = t3 >>> 16, e3[n3 + 2] = t3 >>> 8, e3[n3 + 3] = t3 >>> 0, e3;
  }
  function c2(t3, e3, n3) {
    return e3 === void 0 && (e3 = new Uint8Array(4)), n3 === void 0 && (n3 = 0), e3[n3 + 0] = t3 >>> 0, e3[n3 + 1] = t3 >>> 8, e3[n3 + 2] = t3 >>> 16, e3[n3 + 3] = t3 >>> 24, e3;
  }
  function h2(t3, e3, n3) {
    return e3 === void 0 && (e3 = new Uint8Array(8)), n3 === void 0 && (n3 = 0), u2(t3 / 4294967296 >>> 0, e3, n3), u2(t3 >>> 0, e3, n3 + 4), e3;
  }
  function l2(t3, e3, n3) {
    return e3 === void 0 && (e3 = new Uint8Array(8)), n3 === void 0 && (n3 = 0), c2(t3 >>> 0, e3, n3), c2(t3 / 4294967296 >>> 0, e3, n3 + 4), e3;
  }
  t2.readInt16BE = function(t3, e3) {
    return e3 === void 0 && (e3 = 0), (t3[e3 + 0] << 8 | t3[e3 + 1]) << 16 >> 16;
  }, t2.readUint16BE = function(t3, e3) {
    return e3 === void 0 && (e3 = 0), (t3[e3 + 0] << 8 | t3[e3 + 1]) >>> 0;
  }, t2.readInt16LE = function(t3, e3) {
    return e3 === void 0 && (e3 = 0), (t3[e3 + 1] << 8 | t3[e3]) << 16 >> 16;
  }, t2.readUint16LE = function(t3, e3) {
    return e3 === void 0 && (e3 = 0), (t3[e3 + 1] << 8 | t3[e3]) >>> 0;
  }, t2.writeUint16BE = n2, t2.writeInt16BE = n2, t2.writeUint16LE = r2, t2.writeInt16LE = r2, t2.readInt32BE = s2, t2.readUint32BE = i2, t2.readInt32LE = a2, t2.readUint32LE = o2, t2.writeUint32BE = u2, t2.writeInt32BE = u2, t2.writeUint32LE = c2, t2.writeInt32LE = c2, t2.readInt64BE = function(t3, e3) {
    e3 === void 0 && (e3 = 0);
    var n3 = s2(t3, e3), r3 = s2(t3, e3 + 4);
    return 4294967296 * n3 + r3 - 4294967296 * (r3 >> 31);
  }, t2.readUint64BE = function(t3, e3) {
    return e3 === void 0 && (e3 = 0), 4294967296 * i2(t3, e3) + i2(t3, e3 + 4);
  }, t2.readInt64LE = function(t3, e3) {
    e3 === void 0 && (e3 = 0);
    var n3 = a2(t3, e3);
    return 4294967296 * a2(t3, e3 + 4) + n3 - 4294967296 * (n3 >> 31);
  }, t2.readUint64LE = function(t3, e3) {
    e3 === void 0 && (e3 = 0);
    var n3 = o2(t3, e3);
    return 4294967296 * o2(t3, e3 + 4) + n3;
  }, t2.writeUint64BE = h2, t2.writeInt64BE = h2, t2.writeUint64LE = l2, t2.writeInt64LE = l2, t2.readUintBE = function(t3, e3, n3) {
    if (n3 === void 0 && (n3 = 0), t3 % 8 != 0)
      throw new Error("readUintBE supports only bitLengths divisible by 8");
    if (t3 / 8 > e3.length - n3)
      throw new Error("readUintBE: array is too short for the given bitLength");
    for (var r3 = 0, s3 = 1, i3 = t3 / 8 + n3 - 1; i3 >= n3; i3--)
      r3 += e3[i3] * s3, s3 *= 256;
    return r3;
  }, t2.readUintLE = function(t3, e3, n3) {
    if (n3 === void 0 && (n3 = 0), t3 % 8 != 0)
      throw new Error("readUintLE supports only bitLengths divisible by 8");
    if (t3 / 8 > e3.length - n3)
      throw new Error("readUintLE: array is too short for the given bitLength");
    for (var r3 = 0, s3 = 1, i3 = n3; i3 < n3 + t3 / 8; i3++)
      r3 += e3[i3] * s3, s3 *= 256;
    return r3;
  }, t2.writeUintBE = function(t3, n3, r3, s3) {
    if (r3 === void 0 && (r3 = new Uint8Array(t3 / 8)), s3 === void 0 && (s3 = 0), t3 % 8 != 0)
      throw new Error("writeUintBE supports only bitLengths divisible by 8");
    if (!e2.isSafeInteger(n3))
      throw new Error("writeUintBE value must be an integer");
    for (var i3 = 1, a3 = t3 / 8 + s3 - 1; a3 >= s3; a3--)
      r3[a3] = n3 / i3 & 255, i3 *= 256;
    return r3;
  }, t2.writeUintLE = function(t3, n3, r3, s3) {
    if (r3 === void 0 && (r3 = new Uint8Array(t3 / 8)), s3 === void 0 && (s3 = 0), t3 % 8 != 0)
      throw new Error("writeUintLE supports only bitLengths divisible by 8");
    if (!e2.isSafeInteger(n3))
      throw new Error("writeUintLE value must be an integer");
    for (var i3 = 1, a3 = s3; a3 < s3 + t3 / 8; a3++)
      r3[a3] = n3 / i3 & 255, i3 *= 256;
    return r3;
  }, t2.readFloat32BE = function(t3, e3) {
    return e3 === void 0 && (e3 = 0), new DataView(t3.buffer, t3.byteOffset, t3.byteLength).getFloat32(e3);
  }, t2.readFloat32LE = function(t3, e3) {
    return e3 === void 0 && (e3 = 0), new DataView(t3.buffer, t3.byteOffset, t3.byteLength).getFloat32(e3, true);
  }, t2.readFloat64BE = function(t3, e3) {
    return e3 === void 0 && (e3 = 0), new DataView(t3.buffer, t3.byteOffset, t3.byteLength).getFloat64(e3);
  }, t2.readFloat64LE = function(t3, e3) {
    return e3 === void 0 && (e3 = 0), new DataView(t3.buffer, t3.byteOffset, t3.byteLength).getFloat64(e3, true);
  }, t2.writeFloat32BE = function(t3, e3, n3) {
    return e3 === void 0 && (e3 = new Uint8Array(4)), n3 === void 0 && (n3 = 0), new DataView(e3.buffer, e3.byteOffset, e3.byteLength).setFloat32(n3, t3), e3;
  }, t2.writeFloat32LE = function(t3, e3, n3) {
    return e3 === void 0 && (e3 = new Uint8Array(4)), n3 === void 0 && (n3 = 0), new DataView(e3.buffer, e3.byteOffset, e3.byteLength).setFloat32(n3, t3, true), e3;
  }, t2.writeFloat64BE = function(t3, e3, n3) {
    return e3 === void 0 && (e3 = new Uint8Array(8)), n3 === void 0 && (n3 = 0), new DataView(e3.buffer, e3.byteOffset, e3.byteLength).setFloat64(n3, t3), e3;
  }, t2.writeFloat64LE = function(t3, e3, n3) {
    return e3 === void 0 && (e3 = new Uint8Array(8)), n3 === void 0 && (n3 = 0), new DataView(e3.buffer, e3.byteOffset, e3.byteLength).setFloat64(n3, t3, true), e3;
  };
}}), p = l({"node_modules/@stablelib/wipe/lib/wipe.js"(t2) {
  Object.defineProperty(t2, "l", {value: true}), t2.wipe = function(t3) {
    for (var e2 = 0; e2 < t3.length; e2++)
      t3[e2] = 0;
    return t3;
  };
}}), y = l({"node_modules/@stablelib/sha256/lib/sha256.js"(t2) {
  Object.defineProperty(t2, "l", {value: true});
  var e2 = m(), n2 = p();
  t2.DIGEST_LENGTH = 32, t2.BLOCK_SIZE = 64;
  var r2 = function() {
    function r3() {
      this.digestLength = t2.DIGEST_LENGTH, this.blockSize = t2.BLOCK_SIZE, this.m = new Int32Array(8), this.g = new Int32Array(64), this.N = new Uint8Array(128), this.k = 0, this._ = 0, this.I = false, this.reset();
    }
    return r3.prototype.A = function() {
      this.m[0] = 1779033703, this.m[1] = 3144134277, this.m[2] = 1013904242, this.m[3] = 2773480762, this.m[4] = 1359893119, this.m[5] = 2600822924, this.m[6] = 528734635, this.m[7] = 1541459225;
    }, r3.prototype.reset = function() {
      return this.A(), this.k = 0, this._ = 0, this.I = false, this;
    }, r3.prototype.clean = function() {
      n2.wipe(this.N), n2.wipe(this.g), this.reset();
    }, r3.prototype.update = function(t3, e3) {
      if (e3 === void 0 && (e3 = t3.length), this.I)
        throw new Error("SHA256: can't update because hash was finished.");
      var n3 = 0;
      if (this._ += e3, this.k > 0) {
        for (; this.k < this.blockSize && e3 > 0; )
          this.N[this.k++] = t3[n3++], e3--;
        this.k === this.blockSize && (i2(this.g, this.m, this.N, 0, this.blockSize), this.k = 0);
      }
      for (e3 >= this.blockSize && (n3 = i2(this.g, this.m, t3, n3, e3), e3 %= this.blockSize); e3 > 0; )
        this.N[this.k++] = t3[n3++], e3--;
      return this;
    }, r3.prototype.finish = function(t3) {
      if (!this.I) {
        var n3 = this._, r4 = this.k, s3 = n3 / 536870912 | 0, a2 = n3 << 3, o2 = n3 % 64 < 56 ? 64 : 128;
        this.N[r4] = 128;
        for (var u2 = r4 + 1; u2 < o2 - 8; u2++)
          this.N[u2] = 0;
        e2.writeUint32BE(s3, this.N, o2 - 8), e2.writeUint32BE(a2, this.N, o2 - 4), i2(this.g, this.m, this.N, 0, o2), this.I = true;
      }
      for (u2 = 0; u2 < this.digestLength / 4; u2++)
        e2.writeUint32BE(this.m[u2], t3, 4 * u2);
      return this;
    }, r3.prototype.digest = function() {
      var t3 = new Uint8Array(this.digestLength);
      return this.finish(t3), t3;
    }, r3.prototype.saveState = function() {
      if (this.I)
        throw new Error("SHA256: cannot save finished state");
      return {state: new Int32Array(this.m), buffer: this.k > 0 ? new Uint8Array(this.N) : void 0, bufferLength: this.k, bytesHashed: this._};
    }, r3.prototype.restoreState = function(t3) {
      return this.m.set(t3.state), this.k = t3.bufferLength, t3.buffer && this.N.set(t3.buffer), this._ = t3.bytesHashed, this.I = false, this;
    }, r3.prototype.cleanSavedState = function(t3) {
      n2.wipe(t3.state), t3.buffer && n2.wipe(t3.buffer), t3.bufferLength = 0, t3.bytesHashed = 0;
    }, r3;
  }();
  t2.SHA256 = r2;
  var s2 = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
  function i2(t3, n3, r3, i3, a2) {
    for (; a2 >= 64; ) {
      for (var o2 = n3[0], u2 = n3[1], c2 = n3[2], h2 = n3[3], l2 = n3[4], d2 = n3[5], f2 = n3[6], m2 = n3[7], p2 = 0; p2 < 16; p2++)
        t3[p2] = e2.readUint32BE(r3, i3 + 4 * p2);
      for (p2 = 16; p2 < 64; p2++) {
        var y2 = t3[p2 - 2];
        t3[p2] = ((w2 = (y2 >>> 17 | y2 << 15) ^ (y2 >>> 19 | y2 << 13) ^ y2 >>> 10) + t3[p2 - 7] | 0) + ((g2 = ((y2 = t3[p2 - 15]) >>> 7 | y2 << 25) ^ (y2 >>> 18 | y2 << 14) ^ y2 >>> 3) + t3[p2 - 16] | 0);
      }
      for (p2 = 0; p2 < 64; p2++) {
        var w2 = (((l2 >>> 6 | l2 << 26) ^ (l2 >>> 11 | l2 << 21) ^ (l2 >>> 25 | l2 << 7)) + (l2 & d2 ^ ~l2 & f2) | 0) + (m2 + (s2[p2] + t3[p2] | 0) | 0) | 0, g2 = ((o2 >>> 2 | o2 << 30) ^ (o2 >>> 13 | o2 << 19) ^ (o2 >>> 22 | o2 << 10)) + (o2 & u2 ^ o2 & c2 ^ u2 & c2) | 0;
        m2 = f2, f2 = d2, d2 = l2, l2 = h2 + w2 | 0, h2 = c2, c2 = u2, u2 = o2, o2 = w2 + g2 | 0;
      }
      n3[0] += o2, n3[1] += u2, n3[2] += c2, n3[3] += h2, n3[4] += l2, n3[5] += d2, n3[6] += f2, n3[7] += m2, i3 += 64, a2 -= 64;
    }
    return i3;
  }
  t2.hash = function(t3) {
    var e3 = new r2();
    e3.update(t3);
    var n3 = e3.digest();
    return e3.clean(), n3;
  };
}}), w = l({"node_modules/@stablelib/halfsiphash/lib/halfsiphash.js"(t2) {
  Object.defineProperty(t2, "l", {value: true});
  var e2 = m(), n2 = f();
  function r2(t3, r3, s2) {
    for (var i2 = t3, a2 = r3, o2 = 1819895653 ^ t3, u2 = 1952801890 ^ r3, c2 = 0, h2 = s2.length, l2 = h2 % 256 << 24; h2 >= 4; ) {
      var d2 = e2.readUint32LE(s2, c2);
      u2 ^= d2, i2 = n2.add(i2, a2), a2 = n2.rotl(a2, 5), a2 ^= i2, i2 = n2.rotl(i2, 16), o2 = n2.add(o2, u2), u2 = n2.rotl(u2, 8), i2 = n2.add(i2, u2 ^= o2), u2 = n2.rotl(u2, 7), u2 ^= i2, o2 = n2.add(o2, a2), a2 = n2.rotl(a2, 13), a2 ^= o2, o2 = n2.rotl(o2, 16), i2 = n2.add(i2, a2), a2 = n2.rotl(a2, 5), a2 ^= i2, i2 = n2.rotl(i2, 16), o2 = n2.add(o2, u2), u2 = n2.rotl(u2, 8), i2 = n2.add(i2, u2 ^= o2), u2 = n2.rotl(u2, 7), u2 ^= i2, o2 = n2.add(o2, a2), a2 = n2.rotl(a2, 13), a2 ^= o2, o2 = n2.rotl(o2, 16), i2 ^= d2, c2 += 4, h2 -= 4;
    }
    switch (h2) {
      case 3:
        l2 |= s2[c2 + 2] << 16;
      case 2:
        l2 |= s2[c2 + 1] << 8;
      case 1:
        l2 |= s2[c2];
    }
    return u2 ^= l2, i2 = n2.add(i2, a2), a2 = n2.rotl(a2, 5), a2 ^= i2, i2 = n2.rotl(i2, 16), o2 = n2.add(o2, u2), u2 = n2.rotl(u2, 8), i2 = n2.add(i2, u2 ^= o2), u2 = n2.rotl(u2, 7), u2 ^= i2, o2 = n2.add(o2, a2), a2 = n2.rotl(a2, 13), a2 ^= o2, o2 = n2.rotl(o2, 16), i2 = n2.add(i2, a2), a2 = n2.rotl(a2, 5), a2 ^= i2, i2 = n2.rotl(i2, 16), o2 = n2.add(o2, u2), u2 = n2.rotl(u2, 8), i2 = n2.add(i2, u2 ^= o2), u2 = n2.rotl(u2, 7), u2 ^= i2, o2 = n2.add(o2, a2), a2 = n2.rotl(a2, 13), a2 ^= o2, o2 = n2.rotl(o2, 16), o2 ^= 255, i2 = n2.add(i2 ^= l2, a2), a2 = n2.rotl(a2, 5), a2 ^= i2, i2 = n2.rotl(i2, 16), o2 = n2.add(o2, u2), u2 = n2.rotl(u2, 8), i2 = n2.add(i2, u2 ^= o2), u2 = n2.rotl(u2, 7), u2 ^= i2, o2 = n2.add(o2, a2), a2 = n2.rotl(a2, 13), a2 ^= o2, o2 = n2.rotl(o2, 16), i2 = n2.add(i2, a2), a2 = n2.rotl(a2, 5), a2 ^= i2, i2 = n2.rotl(i2, 16), o2 = n2.add(o2, u2), u2 = n2.rotl(u2, 8), i2 = n2.add(i2, u2 ^= o2), u2 = n2.rotl(u2, 7), u2 ^= i2, o2 = n2.add(o2, a2), a2 = n2.rotl(a2, 13), a2 ^= o2, o2 = n2.rotl(o2, 16), i2 = n2.add(i2, a2), a2 = n2.rotl(a2, 5), a2 ^= i2, i2 = n2.rotl(i2, 16), o2 = n2.add(o2, u2), u2 = n2.rotl(u2, 8), i2 = n2.add(i2, u2 ^= o2), u2 = n2.rotl(u2, 7), u2 ^= i2, o2 = n2.add(o2, a2), a2 = n2.rotl(a2, 13), a2 ^= o2, o2 = n2.rotl(o2, 16), i2 = n2.add(i2, a2), a2 = n2.rotl(a2, 5), a2 ^= i2, i2 = n2.rotl(i2, 16), o2 = n2.add(o2, u2), u2 = n2.rotl(u2, 8), i2 = n2.add(i2, u2 ^= o2), u2 = n2.rotl(u2, 7), u2 ^= i2, o2 = n2.add(o2, a2), a2 = n2.rotl(a2, 13), ((a2 ^= o2) ^ u2) >>> 0;
  }
  t2.KEY_LENGTH = 8, t2.DIGEST_LENGTH = 4, t2.halfSipHash = function(n3, s2) {
    if (n3.length !== t2.KEY_LENGTH)
      throw new Error("halfSipHash: incorrect key length");
    var i2 = e2.readUint32LE(n3, 0), a2 = e2.readUint32LE(n3, 4);
    return e2.writeUint32LE(r2(i2, a2, s2));
  }, t2.halfSipHashNum = r2;
}}), g = l({"node_modules/@stablelib/constant-time/lib/constant-time.js"(t2) {
  function e2(t3, e3) {
    if (t3.length !== e3.length)
      return 0;
    for (var n2 = 0, r2 = 0; r2 < t3.length; r2++)
      n2 |= t3[r2] ^ e3[r2];
    return 1 & n2 - 1 >>> 8;
  }
  Object.defineProperty(t2, "l", {value: true}), t2.select = function(t3, e3, n2) {
    return ~(t3 - 1) & e3 | t3 - 1 & n2;
  }, t2.lessOrEqual = function(t3, e3) {
    return (0 | t3) - (0 | e3) - 1 >>> 31 & 1;
  }, t2.compare = e2, t2.equal = function(t3, n2) {
    return t3.length !== 0 && n2.length !== 0 && e2(t3, n2) !== 0;
  };
}}), v = l({"node_modules/@scure/base/lib/index.js"(t2) {
  function e2(t3) {
    if (!Number.isSafeInteger(t3))
      throw new Error(`Wrong integer: ${t3}`);
  }
  function n2(...t3) {
    const e3 = (t4, e4) => (n3) => t4(e4(n3));
    return {encode: Array.from(t3).reverse().reduce((t4, n3) => t4 ? e3(t4, n3.encode) : n3.encode, void 0), decode: t3.reduce((t4, n3) => t4 ? e3(t4, n3.decode) : n3.decode, void 0)};
  }
  function r2(t3) {
    return {encode: (n3) => {
      if (!Array.isArray(n3) || n3.length && typeof n3[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return n3.map((n4) => {
        if (e2(n4), n4 < 0 || n4 >= t3.length)
          throw new Error(`Digit index outside alphabet: ${n4} (alphabet: ${t3.length})`);
        return t3[n4];
      });
    }, decode: (e3) => {
      if (!Array.isArray(e3) || e3.length && typeof e3[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return e3.map((e4) => {
        if (typeof e4 != "string")
          throw new Error(`alphabet.decode: not string element=${e4}`);
        const n3 = t3.indexOf(e4);
        if (n3 === -1)
          throw new Error(`Unknown letter: "${e4}". Allowed: ${t3}`);
        return n3;
      });
    }};
  }
  function s2(t3 = "") {
    if (typeof t3 != "string")
      throw new Error("join separator should be string");
    return {encode: (e3) => {
      if (!Array.isArray(e3) || e3.length && typeof e3[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let t4 of e3)
        if (typeof t4 != "string")
          throw new Error(`join.encode: non-string input=${t4}`);
      return e3.join(t3);
    }, decode: (e3) => {
      if (typeof e3 != "string")
        throw new Error("join.decode input should be string");
      return e3.split(t3);
    }};
  }
  function i2(t3, n3 = "=") {
    if (e2(t3), typeof n3 != "string")
      throw new Error("padding chr should be string");
    return {encode(e3) {
      if (!Array.isArray(e3) || e3.length && typeof e3[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let t4 of e3)
        if (typeof t4 != "string")
          throw new Error(`padding.encode: non-string input=${t4}`);
      for (; e3.length * t3 % 8; )
        e3.push(n3);
      return e3;
    }, decode(e3) {
      if (!Array.isArray(e3) || e3.length && typeof e3[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let t4 of e3)
        if (typeof t4 != "string")
          throw new Error(`padding.decode: non-string input=${t4}`);
      let r3 = e3.length;
      if (r3 * t3 % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; r3 > 0 && e3[r3 - 1] === n3; r3--)
        if (!((r3 - 1) * t3 % 8))
          throw new Error("Invalid padding: string has too much padding");
      return e3.slice(0, r3);
    }};
  }
  function a2(t3) {
    if (typeof t3 != "function")
      throw new Error("normalize fn should be function");
    return {encode: (t4) => t4, decode: (e3) => t3(e3)};
  }
  function o2(t3, n3, r3) {
    if (n3 < 2)
      throw new Error(`convertRadix: wrong from=${n3}, base cannot be less than 2`);
    if (r3 < 2)
      throw new Error(`convertRadix: wrong to=${r3}, base cannot be less than 2`);
    if (!Array.isArray(t3))
      throw new Error("convertRadix: data should be array");
    if (!t3.length)
      return [];
    let s3 = 0;
    const i3 = [], a3 = Array.from(t3);
    for (a3.forEach((t4) => {
      if (e2(t4), t4 < 0 || t4 >= n3)
        throw new Error(`Wrong integer: ${t4}`);
    }); ; ) {
      let t4 = 0, e3 = true;
      for (let i4 = s3; i4 < a3.length; i4++) {
        const o3 = a3[i4], u3 = n3 * t4 + o3;
        if (!Number.isSafeInteger(u3) || n3 * t4 / n3 !== t4 || u3 - o3 != n3 * t4)
          throw new Error("convertRadix: carry overflow");
        if (t4 = u3 % r3, a3[i4] = Math.floor(u3 / r3), !Number.isSafeInteger(a3[i4]) || a3[i4] * r3 + t4 !== u3)
          throw new Error("convertRadix: carry overflow");
        e3 && (a3[i4] ? e3 = false : s3 = i4);
      }
      if (i3.push(t4), e3)
        break;
    }
    for (let e3 = 0; e3 < t3.length - 1 && t3[e3] === 0; e3++)
      i3.push(0);
    return i3.reverse();
  }
  Object.defineProperty(t2, "l", {value: true}), t2.bytes = t2.stringToBytes = t2.str = t2.bytesToString = t2.hex = t2.utf8 = t2.bech32m = t2.bech32 = t2.base58check = t2.base58xmr = t2.base58xrp = t2.base58flickr = t2.base58 = t2.base64url = t2.base64 = t2.base32crockford = t2.base32hex = t2.base32 = t2.base16 = t2.utils = t2.assertNumber = void 0, t2.assertNumber = e2;
  var u2 = (t3, e3) => e3 ? u2(e3, t3 % e3) : t3, c2 = (t3, e3) => t3 + (e3 - u2(t3, e3));
  function h2(t3, n3, r3, s3) {
    if (!Array.isArray(t3))
      throw new Error("convertRadix2: data should be array");
    if (n3 <= 0 || n3 > 32)
      throw new Error(`convertRadix2: wrong from=${n3}`);
    if (r3 <= 0 || r3 > 32)
      throw new Error(`convertRadix2: wrong to=${r3}`);
    if (c2(n3, r3) > 32)
      throw new Error(`convertRadix2: carry overflow from=${n3} to=${r3} carryBits=${c2(n3, r3)}`);
    let i3 = 0, a3 = 0;
    const o3 = 2 ** r3 - 1, u3 = [];
    for (const s4 of t3) {
      if (e2(s4), s4 >= 2 ** n3)
        throw new Error(`convertRadix2: invalid data word=${s4} from=${n3}`);
      if (i3 = i3 << n3 | s4, a3 + n3 > 32)
        throw new Error(`convertRadix2: carry overflow pos=${a3} from=${n3}`);
      for (a3 += n3; a3 >= r3; a3 -= r3)
        u3.push((i3 >> a3 - r3 & o3) >>> 0);
      i3 &= 2 ** a3 - 1;
    }
    if (i3 = i3 << r3 - a3 & o3, !s3 && a3 >= n3)
      throw new Error("Excess padding");
    if (!s3 && i3)
      throw new Error(`Non-zero padding: ${i3}`);
    return s3 && a3 > 0 && u3.push(i3 >>> 0), u3;
  }
  function l2(t3) {
    return e2(t3), {encode: (e3) => {
      if (!(e3 instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return o2(Array.from(e3), 256, t3);
    }, decode: (e3) => {
      if (!Array.isArray(e3) || e3.length && typeof e3[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(o2(e3, t3, 256));
    }};
  }
  function d2(t3, n3 = false) {
    if (e2(t3), t3 <= 0 || t3 > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (c2(8, t3) > 32 || c2(t3, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {encode: (e3) => {
      if (!(e3 instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return h2(Array.from(e3), 8, t3, !n3);
    }, decode: (e3) => {
      if (!Array.isArray(e3) || e3.length && typeof e3[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(h2(e3, t3, 8, n3));
    }};
  }
  function f2(t3) {
    if (typeof t3 != "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...e3) {
      try {
        return t3.apply(null, e3);
      } catch (t4) {
      }
    };
  }
  function m2(t3, n3) {
    if (e2(t3), typeof n3 != "function")
      throw new Error("checksum fn should be function");
    return {encode(e3) {
      if (!(e3 instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const r3 = n3(e3).slice(0, t3), s3 = new Uint8Array(e3.length + t3);
      return s3.set(e3), s3.set(r3, e3.length), s3;
    }, decode(e3) {
      if (!(e3 instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const r3 = e3.slice(0, -t3), s3 = n3(r3).slice(0, t3), i3 = e3.slice(-t3);
      for (let e4 = 0; e4 < t3; e4++)
        if (s3[e4] !== i3[e4])
          throw new Error("Invalid checksum");
      return r3;
    }};
  }
  t2.utils = {alphabet: r2, chain: n2, checksum: m2, radix: l2, radix2: d2, join: s2, padding: i2}, t2.base16 = n2(d2(4), r2("0123456789ABCDEF"), s2("")), t2.base32 = n2(d2(5), r2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), i2(5), s2("")), t2.base32hex = n2(d2(5), r2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), i2(5), s2("")), t2.base32crockford = n2(d2(5), r2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), s2(""), a2((t3) => t3.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), t2.base64 = n2(d2(6), r2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), i2(6), s2("")), t2.base64url = n2(d2(6), r2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), i2(6), s2(""));
  var p2 = (t3) => n2(l2(58), r2(t3), s2(""));
  t2.base58 = p2("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), t2.base58flickr = p2("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), t2.base58xrp = p2("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  var y2 = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  t2.base58xmr = {encode(e3) {
    let n3 = "";
    for (let r3 = 0; r3 < e3.length; r3 += 8) {
      const s3 = e3.subarray(r3, r3 + 8);
      n3 += t2.base58.encode(s3).padStart(y2[s3.length], "1");
    }
    return n3;
  }, decode(e3) {
    let n3 = [];
    for (let r3 = 0; r3 < e3.length; r3 += 11) {
      const s3 = e3.slice(r3, r3 + 11), i3 = y2.indexOf(s3.length), a3 = t2.base58.decode(s3);
      for (let t3 = 0; t3 < a3.length - i3; t3++)
        if (a3[t3] !== 0)
          throw new Error("base58xmr: wrong padding");
      n3 = n3.concat(Array.from(a3.slice(a3.length - i3)));
    }
    return Uint8Array.from(n3);
  }}, t2.base58check = (e3) => n2(m2(4, (t3) => e3(e3(t3))), t2.base58);
  var w2 = n2(r2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), s2("")), g2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function v2(t3) {
    const e3 = t3 >> 25;
    let n3 = (33554431 & t3) << 5;
    for (let t4 = 0; t4 < g2.length; t4++)
      (e3 >> t4 & 1) == 1 && (n3 ^= g2[t4]);
    return n3;
  }
  function b2(t3, e3, n3 = 1) {
    const r3 = t3.length;
    let s3 = 1;
    for (let e4 = 0; e4 < r3; e4++) {
      const n4 = t3.charCodeAt(e4);
      if (n4 < 33 || n4 > 126)
        throw new Error(`Invalid prefix (${t3})`);
      s3 = v2(s3) ^ n4 >> 5;
    }
    s3 = v2(s3);
    for (let e4 = 0; e4 < r3; e4++)
      s3 = v2(s3) ^ 31 & t3.charCodeAt(e4);
    for (let t4 of e3)
      s3 = v2(s3) ^ t4;
    for (let t4 = 0; t4 < 6; t4++)
      s3 = v2(s3);
    return s3 ^= n3, w2.encode(h2([s3 % 2 ** 30], 30, 5, false));
  }
  function x2(t3) {
    const e3 = t3 === "bech32" ? 1 : 734539939, n3 = d2(5), r3 = n3.decode, s3 = n3.encode, i3 = f2(r3);
    function a3(t4, n4 = 90) {
      if (typeof t4 != "string")
        throw new Error("bech32.decode input should be string, not " + typeof t4);
      if (t4.length < 8 || n4 !== false && t4.length > n4)
        throw new TypeError(`Wrong string length: ${t4.length} (${t4}). Expected (8..${n4})`);
      const r4 = t4.toLowerCase();
      if (t4 !== r4 && t4 !== t4.toUpperCase())
        throw new Error("String must be lowercase or uppercase");
      const s4 = (t4 = r4).lastIndexOf("1");
      if (s4 === 0 || s4 === -1)
        throw new Error('Letter "1" must be present between prefix and data only');
      const i4 = t4.slice(0, s4), a4 = t4.slice(s4 + 1);
      if (a4.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const o3 = w2.decode(a4).slice(0, -6), u3 = b2(i4, o3, e3);
      if (!a4.endsWith(u3))
        throw new Error(`Invalid checksum in ${t4}: expected "${u3}"`);
      return {prefix: i4, words: o3};
    }
    return {encode: function(t4, n4, r4 = 90) {
      if (typeof t4 != "string")
        throw new Error("bech32.encode prefix should be string, not " + typeof t4);
      if (!Array.isArray(n4) || n4.length && typeof n4[0] != "number")
        throw new Error("bech32.encode words should be array of numbers, not " + typeof n4);
      const s4 = t4.length + 7 + n4.length;
      if (r4 !== false && s4 > r4)
        throw new TypeError(`Length ${s4} exceeds limit ${r4}`);
      return `${t4 = t4.toLowerCase()}1${w2.encode(n4)}${b2(t4, n4, e3)}`;
    }, decode: a3, decodeToBytes: function(t4) {
      const {prefix: e4, words: n4} = a3(t4, false);
      return {prefix: e4, words: n4, bytes: r3(n4)};
    }, decodeUnsafe: f2(a3), fromWords: r3, fromWordsUnsafe: i3, toWords: s3};
  }
  t2.bech32 = x2("bech32"), t2.bech32m = x2("bech32m"), t2.utf8 = {encode: (t3) => new TextDecoder().decode(t3), decode: (t3) => new TextEncoder().encode(t3)}, t2.hex = n2(d2(4), r2("0123456789abcdef"), s2(""), a2((t3) => {
    if (typeof t3 != "string" || t3.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof t3} with length ${t3.length}`);
    return t3.toLowerCase();
  }));
  var E2 = {utf8: t2.utf8, hex: t2.hex, base16: t2.base16, base32: t2.base32, base64: t2.base64, base64url: t2.base64url, base58: t2.base58, base58xmr: t2.base58xmr}, N2 = `Invalid encoding type. Available types: ${Object.keys(E2).join(", ")}`;
  t2.bytesToString = (t3, e3) => {
    if (typeof t3 != "string" || !E2.hasOwnProperty(t3))
      throw new TypeError(N2);
    if (!(e3 instanceof Uint8Array))
      throw new TypeError("bytesToString() expects Uint8Array");
    return E2[t3].encode(e3);
  }, t2.str = t2.bytesToString, t2.stringToBytes = (t3, e3) => {
    if (!E2.hasOwnProperty(t3))
      throw new TypeError(N2);
    if (typeof e3 != "string")
      throw new TypeError("stringToBytes() expects string");
    return E2[t3].decode(e3);
  }, t2.bytes = t2.stringToBytes;
}});
function b(t2) {
  t2.bytes = new Uint8Array(2 * t2.bytes.length), t2.view = new DataView(t2.bytes.buffer);
}
function x(t2, e2, n2) {
  for (; ; ) {
    const r2 = t2.bytes.length - 8;
    t2.i = 0;
    try {
      if (e2(t2, n2), t2.i < r2)
        return t2.bytes;
    } catch (e3) {
      if (t2.i < r2)
        throw e3;
    }
    b(t2);
  }
}
function E(t2, e2) {
  return {ser: t2, des: e2};
}
var N, S, M = {encode(t2, e2) {
  const {length: n2} = e2;
  for (let r2 = 0; r2 < n2; r2++)
    t2.view.setUint8(t2.i++, e2.charCodeAt(r2));
}, decode(t2, e2) {
  const n2 = new Array(e2);
  for (let r2 = 0; r2 < e2; r2++)
    n2[r2] = t2.view.getUint8(t2.i++);
  return String.fromCharCode(...n2);
}}, k = E((t2, e2) => {
  t2.view.setUint8(t2.i++, +e2);
}, (t2) => !!t2.view.getUint8(t2.i++)), T = E((t2, e2) => t2.view.setUint8(t2.i++, e2), (t2) => t2.view.getUint8(t2.i++)), _ = E((t2, e2) => {
  t2.view.setBigUint64(t2.i, e2), t2.i += 8;
}, (t2) => {
  const e2 = t2.view.getBigUint64(t2.i);
  return t2.i += 8, e2;
}), I = d(y(), 1), Z = d(w(), 1);
d(g(), 1), (S = N || (N = {})).assertEqual = function(t2) {
}, S.assertNever = function(t2) {
  throw new Error();
}, S.arrayToEnum = (t2) => {
  const e2 = {};
  for (const n2 of t2)
    e2[n2] = n2;
  return e2;
}, S.getValidEnumValues = (t2) => {
  const e2 = S.objectKeys(t2).filter((e3) => typeof t2[t2[e3]] != "number"), n2 = {};
  for (const r2 of e2)
    n2[r2] = t2[r2];
  return S.objectValues(n2);
}, S.objectValues = (t2) => S.objectKeys(t2).map(function(e2) {
  return t2[e2];
}), S.objectKeys = typeof Object.keys == "function" ? (t2) => Object.keys(t2) : (t2) => {
  const e2 = [];
  for (const n2 in t2)
    Object.prototype.hasOwnProperty.call(t2, n2) && e2.push(n2);
  return e2;
}, S.find = (t2, e2) => {
  for (const n2 of t2)
    if (e2(n2))
      return n2;
}, S.isInteger = typeof Number.isInteger == "function" ? (t2) => Number.isInteger(t2) : (t2) => typeof t2 == "number" && isFinite(t2) && Math.floor(t2) === t2, S.joinValues = function(t2, e2 = " | ") {
  return t2.map((t3) => typeof t3 == "string" ? `'${t3}'` : t3).join(e2);
};
var A = N.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), D = (t2) => {
  switch (typeof t2) {
    case "undefined":
      return A.undefined;
    case "string":
      return A.string;
    case "number":
      return isNaN(t2) ? A.nan : A.number;
    case "boolean":
      return A.boolean;
    case "function":
      return A.function;
    case "bigint":
      return A.bigint;
    case "object":
      return Array.isArray(t2) ? A.array : t2 === null ? A.null : t2.then && typeof t2.then == "function" && t2.catch && typeof t2.catch == "function" ? A.promise : typeof Map != "undefined" && t2 instanceof Map ? A.map : typeof Set != "undefined" && t2 instanceof Set ? A.set : typeof Date != "undefined" && t2 instanceof Date ? A.date : A.object;
    default:
      return A.unknown;
  }
}, $ = N.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of"]), O = class extends Error {
  constructor(t2) {
    super(), this.issues = [], this.addIssue = (t3) => {
      this.issues = [...this.issues, t3];
    }, this.addIssues = (t3 = []) => {
      this.issues = [...this.issues, ...t3];
    };
    const e2 = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, e2) : this.__proto__ = e2, this.name = "ZodError", this.issues = t2;
  }
  get errors() {
    return this.issues;
  }
  format(t2) {
    const e2 = t2 || function(t3) {
      return t3.message;
    }, n2 = {$: []}, r2 = (t3) => {
      for (const s2 of t3.issues)
        if (s2.code === "invalid_union")
          s2.unionErrors.map(r2);
        else if (s2.code === "invalid_return_type")
          r2(s2.returnTypeError);
        else if (s2.code === "invalid_arguments")
          r2(s2.argumentsError);
        else if (s2.path.length === 0)
          n2.$.push(e2(s2));
        else {
          let t4 = n2, r3 = 0;
          for (; r3 < s2.path.length; ) {
            const n3 = s2.path[r3];
            r3 === s2.path.length - 1 ? (t4[n3] = t4[n3] || {$: []}, t4[n3].$.push(e2(s2))) : t4[n3] = t4[n3] || {$: []}, t4 = t4[n3], r3++;
          }
        }
    };
    return r2(this), n2;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, K, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t2 = (t3) => t3.message) {
    const e2 = {}, n2 = [];
    for (const r2 of this.issues)
      r2.path.length > 0 ? (e2[r2.path[0]] = e2[r2.path[0]] || [], e2[r2.path[0]].push(t2(r2))) : n2.push(t2(r2));
    return {formErrors: n2, fieldErrors: e2};
  }
  get formErrors() {
    return this.flatten();
  }
};
O.create = (t2) => new O(t2);
var L = (t2, e2) => {
  let n2;
  switch (t2.code) {
    case $.invalid_type:
      n2 = t2.received === A.undefined ? "Required" : `Expected ${t2.expected}, received ${t2.received}`;
      break;
    case $.invalid_literal:
      n2 = `Invalid literal value, expected ${JSON.stringify(t2.expected, K)}`;
      break;
    case $.unrecognized_keys:
      n2 = `Unrecognized key(s) in object: ${N.joinValues(t2.keys, ", ")}`;
      break;
    case $.invalid_union:
      n2 = "Invalid input";
      break;
    case $.invalid_union_discriminator:
      n2 = `Invalid discriminator value. Expected ${N.joinValues(t2.options)}`;
      break;
    case $.invalid_enum_value:
      n2 = `Invalid enum value. Expected ${N.joinValues(t2.options)}, received '${t2.received}'`;
      break;
    case $.invalid_arguments:
      n2 = "Invalid function arguments";
      break;
    case $.invalid_return_type:
      n2 = "Invalid function return type";
      break;
    case $.invalid_date:
      n2 = "Invalid date";
      break;
    case $.invalid_string:
      typeof t2.validation == "object" ? "startsWith" in t2.validation ? n2 = `Invalid input: must start with "${t2.validation.startsWith}"` : "endsWith" in t2.validation ? n2 = `Invalid input: must end with "${t2.validation.endsWith}"` : N.assertNever(t2.validation) : n2 = t2.validation !== "regex" ? `Invalid ${t2.validation}` : "Invalid";
      break;
    case $.too_small:
      n2 = t2.type === "array" ? `Array must contain ${t2.inclusive ? "at least" : "more than"} ${t2.minimum} element(s)` : t2.type === "string" ? `String must contain ${t2.inclusive ? "at least" : "over"} ${t2.minimum} character(s)` : t2.type === "number" ? `Number must be greater than ${t2.inclusive ? "or equal to " : ""}${t2.minimum}` : t2.type === "date" ? `Date must be greater than ${t2.inclusive ? "or equal to " : ""}${new Date(t2.minimum)}` : "Invalid input";
      break;
    case $.too_big:
      n2 = t2.type === "array" ? `Array must contain ${t2.inclusive ? "at most" : "less than"} ${t2.maximum} element(s)` : t2.type === "string" ? `String must contain ${t2.inclusive ? "at most" : "under"} ${t2.maximum} character(s)` : t2.type === "number" ? `Number must be less than ${t2.inclusive ? "or equal to " : ""}${t2.maximum}` : t2.type === "date" ? `Date must be smaller than ${t2.inclusive ? "or equal to " : ""}${new Date(t2.maximum)}` : "Invalid input";
      break;
    case $.custom:
      n2 = "Invalid input";
      break;
    case $.invalid_intersection_types:
      n2 = "Intersection results could not be merged";
      break;
    case $.not_multiple_of:
      n2 = `Number must be a multiple of ${t2.multipleOf}`;
      break;
    default:
      n2 = e2.defaultError, N.assertNever(t2);
  }
  return {message: n2};
}, U = L;
function C() {
  return U;
}
var P = (t2) => {
  const {data: e2, path: n2, errorMaps: r2, issueData: s2} = t2, i2 = [...n2, ...s2.path || []], a2 = {...s2, path: i2};
  let o2 = "";
  const u2 = r2.filter((t3) => !!t3).slice().reverse();
  for (const t3 of u2)
    o2 = t3(a2, {data: e2, defaultError: o2}).message;
  return {...s2, path: i2, message: s2.message || o2};
};
function j(t2, e2) {
  const n2 = P({issueData: e2, data: t2.data, path: t2.path, errorMaps: [t2.common.contextualErrorMap, t2.schemaErrorMap, C(), L].filter((t3) => !!t3)});
  t2.common.issues.push(n2);
}
var F, R, B = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t2, e2) {
    const n2 = [];
    for (const r2 of e2) {
      if (r2.status === "aborted")
        return H;
      r2.status === "dirty" && t2.dirty(), n2.push(r2.value);
    }
    return {status: t2.value, value: n2};
  }
  static async mergeObjectAsync(t2, e2) {
    const n2 = [];
    for (const t3 of e2)
      n2.push({key: await t3.key, value: await t3.value});
    return B.mergeObjectSync(t2, n2);
  }
  static mergeObjectSync(t2, e2) {
    const n2 = {};
    for (const r2 of e2) {
      const {key: e3, value: s2} = r2;
      if (e3.status === "aborted")
        return H;
      if (s2.status === "aborted")
        return H;
      e3.status === "dirty" && t2.dirty(), s2.status === "dirty" && t2.dirty(), (s2.value !== void 0 || r2.alwaysSet) && (n2[e3.value] = s2.value);
    }
    return {status: t2.value, value: n2};
  }
}, H = Object.freeze({status: "aborted"}), G = (t2) => ({status: "valid", value: t2}), W = (t2) => t2.status === "aborted", q = (t2) => t2.status === "dirty", z = (t2) => t2.status === "valid", V = (t2) => typeof Promise !== void 0 && t2 instanceof Promise, K = (t2, e2) => typeof e2 == "bigint" ? e2.toString() : e2;
(R = F || (F = {})).errToObj = (t2) => typeof t2 == "string" ? {message: t2} : t2 || {}, R.toString = (t2) => typeof t2 == "string" ? t2 : t2 == null ? void 0 : t2.message;
var J = class {
  constructor(t2, e2, n2, r2) {
    this.parent = t2, this.data = e2, this.O = n2, this.L = r2;
  }
  get path() {
    return this.O.concat(this.L);
  }
}, Y = (t2, e2) => {
  if (z(e2))
    return {success: true, data: e2.value};
  if (!t2.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {success: false, error: new O(t2.common.issues)};
};
function Q(t2) {
  if (!t2)
    return {};
  const {errorMap: e2, invalid_type_error: n2, required_error: r2, description: s2} = t2;
  if (e2 && (n2 || r2))
    throw new Error(`Can't use "invalid" or "required" in conjunction with custom error map.`);
  return e2 ? {errorMap: e2, description: s2} : {errorMap: (t3, e3) => t3.code !== "invalid_type" ? {message: e3.defaultError} : e3.data === void 0 ? {message: r2 != null ? r2 : e3.defaultError} : {message: n2 != null ? n2 : e3.defaultError}, description: s2};
}
var X = class {
  constructor(t2) {
    this.spa = this.safeParseAsync, this.superRefine = this.U, this.C = t2, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.default = this.default.bind(this), this.describe = this.describe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this.C.description;
  }
  P(t2) {
    return D(t2.data);
  }
  j(t2, e2) {
    return e2 || {common: t2.parent.common, data: t2.data, parsedType: D(t2.data), schemaErrorMap: this.C.errorMap, path: t2.path, parent: t2.parent};
  }
  R(t2) {
    return {status: new B(), ctx: {common: t2.parent.common, data: t2.data, parsedType: D(t2.data), schemaErrorMap: this.C.errorMap, path: t2.path, parent: t2.parent}};
  }
  B(t2) {
    const e2 = this.H(t2);
    if (V(e2))
      throw new Error("Synchronous parse encountered promise.");
    return e2;
  }
  W(t2) {
    const e2 = this.H(t2);
    return Promise.resolve(e2);
  }
  parse(t2, e2) {
    const n2 = this.safeParse(t2, e2);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  safeParse(t2, e2) {
    var n2;
    const r2 = {common: {issues: [], async: (n2 = e2 == null ? void 0 : e2.async) !== null && n2 !== void 0 && n2, contextualErrorMap: e2 == null ? void 0 : e2.errorMap}, path: (e2 == null ? void 0 : e2.path) || [], schemaErrorMap: this.C.errorMap, parent: null, data: t2, parsedType: D(t2)}, s2 = this.B({data: t2, path: r2.path, parent: r2});
    return Y(r2, s2);
  }
  async parseAsync(t2, e2) {
    const n2 = await this.safeParseAsync(t2, e2);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  async safeParseAsync(t2, e2) {
    const n2 = {common: {issues: [], contextualErrorMap: e2 == null ? void 0 : e2.errorMap, async: true}, path: (e2 == null ? void 0 : e2.path) || [], schemaErrorMap: this.C.errorMap, parent: null, data: t2, parsedType: D(t2)}, r2 = this.H({data: t2, path: [], parent: n2}), s2 = await (V(r2) ? r2 : Promise.resolve(r2));
    return Y(n2, s2);
  }
  refine(t2, e2) {
    const n2 = (t3) => typeof e2 == "string" || e2 === void 0 ? {message: e2} : typeof e2 == "function" ? e2(t3) : e2;
    return this.U((e3, r2) => {
      const s2 = t2(e3), i2 = () => r2.addIssue({code: $.custom, ...n2(e3)});
      return typeof Promise != "undefined" && s2 instanceof Promise ? s2.then((t3) => !!t3 || (i2(), false)) : !!s2 || (i2(), false);
    });
  }
  refinement(t2, e2) {
    return this.U((n2, r2) => !!t2(n2) || (r2.addIssue(typeof e2 == "function" ? e2(n2, r2) : e2), false));
  }
  U(t2) {
    return new Lt({schema: this, typeName: Ft.ZodEffects, effect: {type: "refinement", refinement: t2}});
  }
  optional() {
    return Ut.create(this);
  }
  nullable() {
    return Ct.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return yt.create(this);
  }
  promise() {
    return Ot.create(this);
  }
  or(t2) {
    return bt.create([this, t2]);
  }
  and(t2) {
    return Nt.create(this, t2);
  }
  transform(t2) {
    return new Lt({schema: this, typeName: Ft.ZodEffects, effect: {type: "transform", transform: t2}});
  }
  default(t2) {
    return new Pt({innerType: this, defaultValue: typeof t2 == "function" ? t2 : () => t2, typeName: Ft.ZodDefault});
  }
  describe(t2) {
    return new this.constructor({...this.C, description: t2});
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}, tt = /^c[^\s-]{8,}$/i, et = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, nt = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i, rt = class extends X {
  constructor() {
    super(...arguments), this.V = (t2, e2, n2) => this.refinement((e3) => t2.test(e3), {validation: e2, code: $.invalid_string, ...F.errToObj(n2)}), this.nonempty = (t2) => this.min(1, F.errToObj(t2)), this.trim = () => new rt({...this.C, checks: [...this.C.checks, {kind: "trim"}]});
  }
  H(t2) {
    if (this.P(t2) !== A.string) {
      const e3 = this.j(t2);
      return j(e3, {code: $.invalid_type, expected: A.string, received: e3.parsedType}), H;
    }
    const e2 = new B();
    let n2;
    for (const r2 of this.C.checks)
      if (r2.kind === "min")
        t2.data.length < r2.value && (n2 = this.j(t2, n2), j(n2, {code: $.too_small, minimum: r2.value, type: "string", inclusive: true, message: r2.message}), e2.dirty());
      else if (r2.kind === "max")
        t2.data.length > r2.value && (n2 = this.j(t2, n2), j(n2, {code: $.too_big, maximum: r2.value, type: "string", inclusive: true, message: r2.message}), e2.dirty());
      else if (r2.kind === "email")
        nt.test(t2.data) || (n2 = this.j(t2, n2), j(n2, {validation: "email", code: $.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "uuid")
        et.test(t2.data) || (n2 = this.j(t2, n2), j(n2, {validation: "uuid", code: $.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "cuid")
        tt.test(t2.data) || (n2 = this.j(t2, n2), j(n2, {validation: "cuid", code: $.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "url")
        try {
          new URL(t2.data);
        } catch (s2) {
          n2 = this.j(t2, n2), j(n2, {validation: "url", code: $.invalid_string, message: r2.message}), e2.dirty();
        }
      else
        r2.kind === "regex" ? (r2.regex.lastIndex = 0, r2.regex.test(t2.data) || (n2 = this.j(t2, n2), j(n2, {validation: "regex", code: $.invalid_string, message: r2.message}), e2.dirty())) : r2.kind === "trim" ? t2.data = t2.data.trim() : r2.kind === "startsWith" ? t2.data.startsWith(r2.value) || (n2 = this.j(t2, n2), j(n2, {code: $.invalid_string, validation: {startsWith: r2.value}, message: r2.message}), e2.dirty()) : r2.kind === "endsWith" ? t2.data.endsWith(r2.value) || (n2 = this.j(t2, n2), j(n2, {code: $.invalid_string, validation: {endsWith: r2.value}, message: r2.message}), e2.dirty()) : N.assertNever(r2);
    return {status: e2.value, value: t2.data};
  }
  K(t2) {
    return new rt({...this.C, checks: [...this.C.checks, t2]});
  }
  email(t2) {
    return this.K({kind: "email", ...F.errToObj(t2)});
  }
  url(t2) {
    return this.K({kind: "url", ...F.errToObj(t2)});
  }
  uuid(t2) {
    return this.K({kind: "uuid", ...F.errToObj(t2)});
  }
  cuid(t2) {
    return this.K({kind: "cuid", ...F.errToObj(t2)});
  }
  regex(t2, e2) {
    return this.K({kind: "regex", regex: t2, ...F.errToObj(e2)});
  }
  startsWith(t2, e2) {
    return this.K({kind: "startsWith", value: t2, ...F.errToObj(e2)});
  }
  endsWith(t2, e2) {
    return this.K({kind: "endsWith", value: t2, ...F.errToObj(e2)});
  }
  min(t2, e2) {
    return this.K({kind: "min", value: t2, ...F.errToObj(e2)});
  }
  max(t2, e2) {
    return this.K({kind: "max", value: t2, ...F.errToObj(e2)});
  }
  length(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  get isEmail() {
    return !!this.C.checks.find((t2) => t2.kind === "email");
  }
  get isURL() {
    return !!this.C.checks.find((t2) => t2.kind === "url");
  }
  get isUUID() {
    return !!this.C.checks.find((t2) => t2.kind === "uuid");
  }
  get isCUID() {
    return !!this.C.checks.find((t2) => t2.kind === "cuid");
  }
  get minLength() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "min" && (t2 === null || e2.value > t2) && (t2 = e2.value);
    return t2;
  }
  get maxLength() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "max" && (t2 === null || e2.value < t2) && (t2 = e2.value);
    return t2;
  }
};
function st(t2, e2) {
  const n2 = (t2.toString().split(".")[1] || "").length, r2 = (e2.toString().split(".")[1] || "").length, s2 = n2 > r2 ? n2 : r2;
  return parseInt(t2.toFixed(s2).replace(".", "")) % parseInt(e2.toFixed(s2).replace(".", "")) / Math.pow(10, s2);
}
rt.create = (t2) => new rt({checks: [], typeName: Ft.ZodString, ...Q(t2)});
var it = class extends X {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  H(t2) {
    if (this.P(t2) !== A.number) {
      const e3 = this.j(t2);
      return j(e3, {code: $.invalid_type, expected: A.number, received: e3.parsedType}), H;
    }
    let e2;
    const n2 = new B();
    for (const r2 of this.C.checks)
      r2.kind === "int" ? N.isInteger(t2.data) || (e2 = this.j(t2, e2), j(e2, {code: $.invalid_type, expected: "integer", received: "float", message: r2.message}), n2.dirty()) : r2.kind === "min" ? (r2.inclusive ? t2.data < r2.value : t2.data <= r2.value) && (e2 = this.j(t2, e2), j(e2, {code: $.too_small, minimum: r2.value, type: "number", inclusive: r2.inclusive, message: r2.message}), n2.dirty()) : r2.kind === "max" ? (r2.inclusive ? t2.data > r2.value : t2.data >= r2.value) && (e2 = this.j(t2, e2), j(e2, {code: $.too_big, maximum: r2.value, type: "number", inclusive: r2.inclusive, message: r2.message}), n2.dirty()) : r2.kind === "multipleOf" ? st(t2.data, r2.value) !== 0 && (e2 = this.j(t2, e2), j(e2, {code: $.not_multiple_of, multipleOf: r2.value, message: r2.message}), n2.dirty()) : N.assertNever(r2);
    return {status: n2.value, value: t2.data};
  }
  gte(t2, e2) {
    return this.setLimit("min", t2, true, F.toString(e2));
  }
  gt(t2, e2) {
    return this.setLimit("min", t2, false, F.toString(e2));
  }
  lte(t2, e2) {
    return this.setLimit("max", t2, true, F.toString(e2));
  }
  lt(t2, e2) {
    return this.setLimit("max", t2, false, F.toString(e2));
  }
  setLimit(t2, e2, n2, r2) {
    return new it({...this.C, checks: [...this.C.checks, {kind: t2, value: e2, inclusive: n2, message: F.toString(r2)}]});
  }
  K(t2) {
    return new it({...this.C, checks: [...this.C.checks, t2]});
  }
  int(t2) {
    return this.K({kind: "int", message: F.toString(t2)});
  }
  positive(t2) {
    return this.K({kind: "min", value: 0, inclusive: false, message: F.toString(t2)});
  }
  negative(t2) {
    return this.K({kind: "max", value: 0, inclusive: false, message: F.toString(t2)});
  }
  nonpositive(t2) {
    return this.K({kind: "max", value: 0, inclusive: true, message: F.toString(t2)});
  }
  nonnegative(t2) {
    return this.K({kind: "min", value: 0, inclusive: true, message: F.toString(t2)});
  }
  multipleOf(t2, e2) {
    return this.K({kind: "multipleOf", value: t2, message: F.toString(e2)});
  }
  get minValue() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "min" && (t2 === null || e2.value > t2) && (t2 = e2.value);
    return t2;
  }
  get maxValue() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "max" && (t2 === null || e2.value < t2) && (t2 = e2.value);
    return t2;
  }
  get isInt() {
    return !!this.C.checks.find((t2) => t2.kind === "int");
  }
};
it.create = (t2) => new it({checks: [], typeName: Ft.ZodNumber, ...Q(t2)});
var at = class extends X {
  H(t2) {
    if (this.P(t2) !== A.bigint) {
      const e2 = this.j(t2);
      return j(e2, {code: $.invalid_type, expected: A.bigint, received: e2.parsedType}), H;
    }
    return G(t2.data);
  }
};
at.create = (t2) => new at({typeName: Ft.ZodBigInt, ...Q(t2)});
var ot = class extends X {
  H(t2) {
    if (this.P(t2) !== A.boolean) {
      const e2 = this.j(t2);
      return j(e2, {code: $.invalid_type, expected: A.boolean, received: e2.parsedType}), H;
    }
    return G(t2.data);
  }
};
ot.create = (t2) => new ot({typeName: Ft.ZodBoolean, ...Q(t2)});
var ut = class extends X {
  H(t2) {
    if (this.P(t2) !== A.date) {
      const e3 = this.j(t2);
      return j(e3, {code: $.invalid_type, expected: A.date, received: e3.parsedType}), H;
    }
    if (isNaN(t2.data.getTime()))
      return j(this.j(t2), {code: $.invalid_date}), H;
    const e2 = new B();
    let n2;
    for (const r2 of this.C.checks)
      r2.kind === "min" ? t2.data.getTime() < r2.value && (n2 = this.j(t2, n2), j(n2, {code: $.too_small, message: r2.message, inclusive: true, minimum: r2.value, type: "date"}), e2.dirty()) : r2.kind === "max" ? t2.data.getTime() > r2.value && (n2 = this.j(t2, n2), j(n2, {code: $.too_big, message: r2.message, inclusive: true, maximum: r2.value, type: "date"}), e2.dirty()) : N.assertNever(r2);
    return {status: e2.value, value: new Date(t2.data.getTime())};
  }
  K(t2) {
    return new ut({...this.C, checks: [...this.C.checks, t2]});
  }
  min(t2, e2) {
    return this.K({kind: "min", value: t2.getTime(), message: F.toString(e2)});
  }
  max(t2, e2) {
    return this.K({kind: "max", value: t2.getTime(), message: F.toString(e2)});
  }
  get minDate() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "min" && (t2 === null || e2.value > t2) && (t2 = e2.value);
    return t2 != null ? new Date(t2) : null;
  }
  get maxDate() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "max" && (t2 === null || e2.value < t2) && (t2 = e2.value);
    return t2 != null ? new Date(t2) : null;
  }
};
ut.create = (t2) => new ut({checks: [], typeName: Ft.ZodDate, ...Q(t2)});
var ct = class extends X {
  H(t2) {
    if (this.P(t2) !== A.undefined) {
      const e2 = this.j(t2);
      return j(e2, {code: $.invalid_type, expected: A.undefined, received: e2.parsedType}), H;
    }
    return G(t2.data);
  }
};
ct.create = (t2) => new ct({typeName: Ft.ZodUndefined, ...Q(t2)});
var ht = class extends X {
  H(t2) {
    if (this.P(t2) !== A.null) {
      const e2 = this.j(t2);
      return j(e2, {code: $.invalid_type, expected: A.null, received: e2.parsedType}), H;
    }
    return G(t2.data);
  }
};
ht.create = (t2) => new ht({typeName: Ft.ZodNull, ...Q(t2)});
var lt = class extends X {
  constructor() {
    super(...arguments), this.J = true;
  }
  H(t2) {
    return G(t2.data);
  }
};
lt.create = (t2) => new lt({typeName: Ft.ZodAny, ...Q(t2)});
var dt = class extends X {
  constructor() {
    super(...arguments), this.Y = true;
  }
  H(t2) {
    return G(t2.data);
  }
};
dt.create = (t2) => new dt({typeName: Ft.ZodUnknown, ...Q(t2)});
var ft = class extends X {
  H(t2) {
    const e2 = this.j(t2);
    return j(e2, {code: $.invalid_type, expected: A.never, received: e2.parsedType}), H;
  }
};
ft.create = (t2) => new ft({typeName: Ft.ZodNever, ...Q(t2)});
var mt = class extends X {
  H(t2) {
    if (this.P(t2) !== A.undefined) {
      const e2 = this.j(t2);
      return j(e2, {code: $.invalid_type, expected: A.void, received: e2.parsedType}), H;
    }
    return G(t2.data);
  }
};
mt.create = (t2) => new mt({typeName: Ft.ZodVoid, ...Q(t2)});
var pt, yt = class extends X {
  H(t2) {
    const {ctx: e2, status: n2} = this.R(t2), r2 = this.C;
    if (e2.parsedType !== A.array)
      return j(e2, {code: $.invalid_type, expected: A.array, received: e2.parsedType}), H;
    if (r2.minLength !== null && e2.data.length < r2.minLength.value && (j(e2, {code: $.too_small, minimum: r2.minLength.value, type: "array", inclusive: true, message: r2.minLength.message}), n2.dirty()), r2.maxLength !== null && e2.data.length > r2.maxLength.value && (j(e2, {code: $.too_big, maximum: r2.maxLength.value, type: "array", inclusive: true, message: r2.maxLength.message}), n2.dirty()), e2.common.async)
      return Promise.all(e2.data.map((t3, n3) => r2.type.W(new J(e2, t3, e2.path, n3)))).then((t3) => B.mergeArray(n2, t3));
    const s2 = e2.data.map((t3, n3) => r2.type.B(new J(e2, t3, e2.path, n3)));
    return B.mergeArray(n2, s2);
  }
  get element() {
    return this.C.type;
  }
  min(t2, e2) {
    return new yt({...this.C, minLength: {value: t2, message: F.toString(e2)}});
  }
  max(t2, e2) {
    return new yt({...this.C, maxLength: {value: t2, message: F.toString(e2)}});
  }
  length(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  nonempty(t2) {
    return this.min(1, t2);
  }
};
yt.create = (t2, e2) => new yt({type: t2, minLength: null, maxLength: null, typeName: Ft.ZodArray, ...Q(e2)}), (pt || (pt = {})).mergeShapes = (t2, e2) => ({...t2, ...e2});
var wt = (t2) => (e2) => new vt({...t2, shape: () => ({...t2.shape(), ...e2})});
function gt(t2) {
  if (t2 instanceof vt) {
    const e2 = {};
    for (const n2 in t2.shape)
      e2[n2] = Ut.create(gt(t2.shape[n2]));
    return new vt({...t2.C, shape: () => e2});
  }
  return t2 instanceof yt ? yt.create(gt(t2.element)) : t2 instanceof Ut ? Ut.create(gt(t2.unwrap())) : t2 instanceof Ct ? Ct.create(gt(t2.unwrap())) : t2 instanceof St ? St.create(t2.items.map((t3) => gt(t3))) : t2;
}
var vt = class extends X {
  constructor() {
    super(...arguments), this.X = null, this.nonstrict = this.passthrough, this.augment = wt(this.C), this.extend = wt(this.C);
  }
  et() {
    if (this.X !== null)
      return this.X;
    const t2 = this.C.shape(), e2 = N.objectKeys(t2);
    return this.X = {shape: t2, keys: e2};
  }
  H(t2) {
    if (this.P(t2) !== A.object) {
      const e3 = this.j(t2);
      return j(e3, {code: $.invalid_type, expected: A.object, received: e3.parsedType}), H;
    }
    const {status: e2, ctx: n2} = this.R(t2), {shape: r2, keys: s2} = this.et(), i2 = [];
    for (const t3 in n2.data)
      s2.includes(t3) || i2.push(t3);
    const a2 = [];
    for (const t3 of s2)
      a2.push({key: {status: "valid", value: t3}, value: r2[t3].H(new J(n2, n2.data[t3], n2.path, t3)), alwaysSet: t3 in n2.data});
    if (this.C.catchall instanceof ft) {
      const t3 = this.C.unknownKeys;
      if (t3 === "passthrough")
        for (const t4 of i2)
          a2.push({key: {status: "valid", value: t4}, value: {status: "valid", value: n2.data[t4]}});
      else if (t3 === "strict")
        i2.length > 0 && (j(n2, {code: $.unrecognized_keys, keys: i2}), e2.dirty());
      else if (t3 !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const t3 = this.C.catchall;
      for (const e3 of i2)
        a2.push({key: {status: "valid", value: e3}, value: t3.H(new J(n2, n2.data[e3], n2.path, e3)), alwaysSet: e3 in n2.data});
    }
    return n2.common.async ? Promise.resolve().then(async () => {
      const t3 = [];
      for (const e3 of a2) {
        const n3 = await e3.key;
        t3.push({key: n3, value: await e3.value, alwaysSet: e3.alwaysSet});
      }
      return t3;
    }).then((t3) => B.mergeObjectSync(e2, t3)) : B.mergeObjectSync(e2, a2);
  }
  get shape() {
    return this.C.shape();
  }
  strict(t2) {
    return new vt({...this.C, unknownKeys: "strict", ...t2 !== void 0 ? {errorMap: (e2, n2) => {
      var r2, s2, i2, a2;
      const o2 = (i2 = (s2 = (r2 = this.C).errorMap) === null || s2 === void 0 ? void 0 : s2.call(r2, e2, n2).message) !== null && i2 !== void 0 ? i2 : n2.defaultError;
      return e2.code === "unrecognized_keys" ? {message: (a2 = F.errToObj(t2).message) !== null && a2 !== void 0 ? a2 : o2} : {message: o2};
    }} : {}});
  }
  strip() {
    return new vt({...this.C, unknownKeys: "strip"});
  }
  passthrough() {
    return new vt({...this.C, unknownKeys: "passthrough"});
  }
  setKey(t2, e2) {
    return this.augment({[t2]: e2});
  }
  merge(t2) {
    return new vt({unknownKeys: t2.C.unknownKeys, catchall: t2.C.catchall, shape: () => pt.mergeShapes(this.C.shape(), t2.C.shape()), typeName: Ft.ZodObject});
  }
  catchall(t2) {
    return new vt({...this.C, catchall: t2});
  }
  pick(t2) {
    const e2 = {};
    return N.objectKeys(t2).map((t3) => {
      this.shape[t3] && (e2[t3] = this.shape[t3]);
    }), new vt({...this.C, shape: () => e2});
  }
  omit(t2) {
    const e2 = {};
    return N.objectKeys(this.shape).map((n2) => {
      N.objectKeys(t2).indexOf(n2) === -1 && (e2[n2] = this.shape[n2]);
    }), new vt({...this.C, shape: () => e2});
  }
  deepPartial() {
    return gt(this);
  }
  partial(t2) {
    const e2 = {};
    if (t2)
      return N.objectKeys(this.shape).map((n2) => {
        e2[n2] = N.objectKeys(t2).indexOf(n2) === -1 ? this.shape[n2] : this.shape[n2].optional();
      }), new vt({...this.C, shape: () => e2});
    for (const t3 in this.shape)
      e2[t3] = this.shape[t3].optional();
    return new vt({...this.C, shape: () => e2});
  }
  required() {
    const t2 = {};
    for (const e2 in this.shape) {
      let n2 = this.shape[e2];
      for (; n2 instanceof Ut; )
        n2 = n2.C.innerType;
      t2[e2] = n2;
    }
    return new vt({...this.C, shape: () => t2});
  }
  keyof() {
    return At(N.objectKeys(this.shape));
  }
};
vt.create = (t2, e2) => new vt({shape: () => t2, unknownKeys: "strip", catchall: ft.create(), typeName: Ft.ZodObject, ...Q(e2)}), vt.strictCreate = (t2, e2) => new vt({shape: () => t2, unknownKeys: "strict", catchall: ft.create(), typeName: Ft.ZodObject, ...Q(e2)}), vt.lazycreate = (t2, e2) => new vt({shape: t2, unknownKeys: "strip", catchall: ft.create(), typeName: Ft.ZodObject, ...Q(e2)});
var bt = class extends X {
  H(t2) {
    const {ctx: e2} = this.R(t2), n2 = this.C.options;
    if (e2.common.async)
      return Promise.all(n2.map(async (t3) => {
        const n3 = {...e2, common: {...e2.common, issues: []}, parent: null};
        return {result: await t3.W({data: e2.data, path: e2.path, parent: n3}), ctx: n3};
      })).then(function(t3) {
        for (const e3 of t3)
          if (e3.result.status === "valid")
            return e3.result;
        for (const n4 of t3)
          if (n4.result.status === "dirty")
            return e2.common.issues.push(...n4.ctx.common.issues), n4.result;
        const n3 = t3.map((t4) => new O(t4.ctx.common.issues));
        return j(e2, {code: $.invalid_union, unionErrors: n3}), H;
      });
    {
      let t3;
      const r2 = [];
      for (const s3 of n2) {
        const n3 = {...e2, common: {...e2.common, issues: []}, parent: null}, i2 = s3.B({data: e2.data, path: e2.path, parent: n3});
        if (i2.status === "valid")
          return i2;
        i2.status !== "dirty" || t3 || (t3 = {result: i2, ctx: n3}), n3.common.issues.length && r2.push(n3.common.issues);
      }
      if (t3)
        return e2.common.issues.push(...t3.ctx.common.issues), t3.result;
      const s2 = r2.map((t4) => new O(t4));
      return j(e2, {code: $.invalid_union, unionErrors: s2}), H;
    }
  }
  get options() {
    return this.C.options;
  }
};
bt.create = (t2, e2) => new bt({options: t2, typeName: Ft.ZodUnion, ...Q(e2)});
var xt = class extends X {
  H(t2) {
    const {ctx: e2} = this.R(t2);
    if (e2.parsedType !== A.object)
      return j(e2, {code: $.invalid_type, expected: A.object, received: e2.parsedType}), H;
    const n2 = this.discriminator, r2 = this.options.get(e2.data[n2]);
    return r2 ? e2.common.async ? r2.W({data: e2.data, path: e2.path, parent: e2}) : r2.B({data: e2.data, path: e2.path, parent: e2}) : (j(e2, {code: $.invalid_union_discriminator, options: this.validDiscriminatorValues, path: [n2]}), H);
  }
  get discriminator() {
    return this.C.discriminator;
  }
  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }
  get options() {
    return this.C.options;
  }
  static create(t2, e2, n2) {
    const r2 = /* @__PURE__ */ new Map();
    try {
      e2.forEach((e3) => {
        r2.set(e3.shape[t2].value, e3);
      });
    } catch (t3) {
      throw new Error("The discriminator value could not be extracted from all the provided schemas");
    }
    if (r2.size !== e2.length)
      throw new Error("Some of the discriminator values are not unique");
    return new xt({typeName: Ft.ZodDiscriminatedUnion, discriminator: t2, options: r2, ...Q(n2)});
  }
};
function Et(t2, e2) {
  const n2 = D(t2), r2 = D(e2);
  if (t2 === e2)
    return {valid: true, data: t2};
  if (n2 === A.object && r2 === A.object) {
    const n3 = N.objectKeys(e2), r3 = N.objectKeys(t2).filter((t3) => n3.indexOf(t3) !== -1), s2 = {...t2, ...e2};
    for (const n4 of r3) {
      const r4 = Et(t2[n4], e2[n4]);
      if (!r4.valid)
        return {valid: false};
      s2[n4] = r4.data;
    }
    return {valid: true, data: s2};
  }
  if (n2 === A.array && r2 === A.array) {
    if (t2.length !== e2.length)
      return {valid: false};
    const n3 = [];
    for (let r3 = 0; r3 < t2.length; r3++) {
      const s2 = Et(t2[r3], e2[r3]);
      if (!s2.valid)
        return {valid: false};
      n3.push(s2.data);
    }
    return {valid: true, data: n3};
  }
  return n2 === A.date && r2 === A.date && +t2 == +e2 ? {valid: true, data: t2} : {valid: false};
}
var Nt = class extends X {
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2), r2 = (t3, r3) => {
      if (W(t3) || W(r3))
        return H;
      const s2 = Et(t3.value, r3.value);
      return s2.valid ? ((q(t3) || q(r3)) && e2.dirty(), {status: e2.value, value: s2.data}) : (j(n2, {code: $.invalid_intersection_types}), H);
    };
    return n2.common.async ? Promise.all([this.C.left.W({data: n2.data, path: n2.path, parent: n2}), this.C.right.W({data: n2.data, path: n2.path, parent: n2})]).then(([t3, e3]) => r2(t3, e3)) : r2(this.C.left.B({data: n2.data, path: n2.path, parent: n2}), this.C.right.B({data: n2.data, path: n2.path, parent: n2}));
  }
};
Nt.create = (t2, e2, n2) => new Nt({left: t2, right: e2, typeName: Ft.ZodIntersection, ...Q(n2)});
var St = class extends X {
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2);
    if (n2.parsedType !== A.array)
      return j(n2, {code: $.invalid_type, expected: A.array, received: n2.parsedType}), H;
    if (n2.data.length < this.C.items.length)
      return j(n2, {code: $.too_small, minimum: this.C.items.length, inclusive: true, type: "array"}), H;
    !this.C.rest && n2.data.length > this.C.items.length && (j(n2, {code: $.too_big, maximum: this.C.items.length, inclusive: true, type: "array"}), e2.dirty());
    const r2 = n2.data.map((t3, e3) => {
      const r3 = this.C.items[e3] || this.C.rest;
      return r3 ? r3.H(new J(n2, t3, n2.path, e3)) : null;
    }).filter((t3) => !!t3);
    return n2.common.async ? Promise.all(r2).then((t3) => B.mergeArray(e2, t3)) : B.mergeArray(e2, r2);
  }
  get items() {
    return this.C.items;
  }
  rest(t2) {
    return new St({...this.C, rest: t2});
  }
};
St.create = (t2, e2) => new St({items: t2, typeName: Ft.ZodTuple, rest: null, ...Q(e2)});
var Mt = class extends X {
  get keySchema() {
    return this.C.keyType;
  }
  get valueSchema() {
    return this.C.valueType;
  }
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2);
    if (n2.parsedType !== A.object)
      return j(n2, {code: $.invalid_type, expected: A.object, received: n2.parsedType}), H;
    const r2 = [], s2 = this.C.keyType, i2 = this.C.valueType;
    for (const t3 in n2.data)
      r2.push({key: s2.H(new J(n2, t3, n2.path, t3)), value: i2.H(new J(n2, n2.data[t3], n2.path, t3))});
    return n2.common.async ? B.mergeObjectAsync(e2, r2) : B.mergeObjectSync(e2, r2);
  }
  get element() {
    return this.C.valueType;
  }
  static create(t2, e2, n2) {
    return new Mt(e2 instanceof X ? {keyType: t2, valueType: e2, typeName: Ft.ZodRecord, ...Q(n2)} : {keyType: rt.create(), valueType: t2, typeName: Ft.ZodRecord, ...Q(e2)});
  }
}, kt = class extends X {
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2);
    if (n2.parsedType !== A.map)
      return j(n2, {code: $.invalid_type, expected: A.map, received: n2.parsedType}), H;
    const r2 = this.C.keyType, s2 = this.C.valueType, i2 = [...n2.data.entries()].map(([t3, e3], i3) => ({key: r2.H(new J(n2, t3, n2.path, [i3, "key"])), value: s2.H(new J(n2, e3, n2.path, [i3, "value"]))}));
    if (n2.common.async) {
      const t3 = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const n3 of i2) {
          const r3 = await n3.key, s3 = await n3.value;
          if (r3.status === "aborted" || s3.status === "aborted")
            return H;
          r3.status !== "dirty" && s3.status !== "dirty" || e2.dirty(), t3.set(r3.value, s3.value);
        }
        return {status: e2.value, value: t3};
      });
    }
    {
      const t3 = /* @__PURE__ */ new Map();
      for (const n3 of i2) {
        const r3 = n3.key, s3 = n3.value;
        if (r3.status === "aborted" || s3.status === "aborted")
          return H;
        r3.status !== "dirty" && s3.status !== "dirty" || e2.dirty(), t3.set(r3.value, s3.value);
      }
      return {status: e2.value, value: t3};
    }
  }
};
kt.create = (t2, e2, n2) => new kt({valueType: e2, keyType: t2, typeName: Ft.ZodMap, ...Q(n2)});
var Tt = class extends X {
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2);
    if (n2.parsedType !== A.set)
      return j(n2, {code: $.invalid_type, expected: A.set, received: n2.parsedType}), H;
    const r2 = this.C;
    r2.minSize !== null && n2.data.size < r2.minSize.value && (j(n2, {code: $.too_small, minimum: r2.minSize.value, type: "set", inclusive: true, message: r2.minSize.message}), e2.dirty()), r2.maxSize !== null && n2.data.size > r2.maxSize.value && (j(n2, {code: $.too_big, maximum: r2.maxSize.value, type: "set", inclusive: true, message: r2.maxSize.message}), e2.dirty());
    const s2 = this.C.valueType;
    function i2(t3) {
      const n3 = /* @__PURE__ */ new Set();
      for (const r3 of t3) {
        if (r3.status === "aborted")
          return H;
        r3.status === "dirty" && e2.dirty(), n3.add(r3.value);
      }
      return {status: e2.value, value: n3};
    }
    const a2 = [...n2.data.values()].map((t3, e3) => s2.H(new J(n2, t3, n2.path, e3)));
    return n2.common.async ? Promise.all(a2).then((t3) => i2(t3)) : i2(a2);
  }
  min(t2, e2) {
    return new Tt({...this.C, minSize: {value: t2, message: F.toString(e2)}});
  }
  max(t2, e2) {
    return new Tt({...this.C, maxSize: {value: t2, message: F.toString(e2)}});
  }
  size(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  nonempty(t2) {
    return this.min(1, t2);
  }
};
Tt.create = (t2, e2) => new Tt({valueType: t2, minSize: null, maxSize: null, typeName: Ft.ZodSet, ...Q(e2)});
var _t = class extends X {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  H(t2) {
    const {ctx: e2} = this.R(t2);
    if (e2.parsedType !== A.function)
      return j(e2, {code: $.invalid_type, expected: A.function, received: e2.parsedType}), H;
    function n2(t3, n3) {
      return P({data: t3, path: e2.path, errorMaps: [e2.common.contextualErrorMap, e2.schemaErrorMap, C(), L].filter((t4) => !!t4), issueData: {code: $.invalid_arguments, argumentsError: n3}});
    }
    function r2(t3, n3) {
      return P({data: t3, path: e2.path, errorMaps: [e2.common.contextualErrorMap, e2.schemaErrorMap, C(), L].filter((t4) => !!t4), issueData: {code: $.invalid_return_type, returnTypeError: n3}});
    }
    const s2 = {errorMap: e2.common.contextualErrorMap}, i2 = e2.data;
    return G(this.C.returns instanceof Ot ? async (...t3) => {
      const e3 = new O([]), a2 = await this.C.args.parseAsync(t3, s2).catch((r3) => {
        throw e3.addIssue(n2(t3, r3)), e3;
      }), o2 = await i2(...a2);
      return await this.C.returns.C.type.parseAsync(o2, s2).catch((t4) => {
        throw e3.addIssue(r2(o2, t4)), e3;
      });
    } : (...t3) => {
      const e3 = this.C.args.safeParse(t3, s2);
      if (!e3.success)
        throw new O([n2(t3, e3.error)]);
      const a2 = i2(...e3.data), o2 = this.C.returns.safeParse(a2, s2);
      if (!o2.success)
        throw new O([r2(a2, o2.error)]);
      return o2.data;
    });
  }
  parameters() {
    return this.C.args;
  }
  returnType() {
    return this.C.returns;
  }
  args(...t2) {
    return new _t({...this.C, args: St.create(t2).rest(dt.create())});
  }
  returns(t2) {
    return new _t({...this.C, returns: t2});
  }
  implement(t2) {
    return this.parse(t2);
  }
  strictImplement(t2) {
    return this.parse(t2);
  }
};
_t.create = (t2, e2, n2) => new _t({args: t2 ? t2.rest(dt.create()) : St.create([]).rest(dt.create()), returns: e2 || dt.create(), typeName: Ft.ZodFunction, ...Q(n2)});
var It = class extends X {
  get schema() {
    return this.C.getter();
  }
  H(t2) {
    const {ctx: e2} = this.R(t2);
    return this.C.getter().H({data: e2.data, path: e2.path, parent: e2});
  }
};
It.create = (t2, e2) => new It({getter: t2, typeName: Ft.ZodLazy, ...Q(e2)});
var Zt = class extends X {
  H(t2) {
    return t2.data !== this.C.value ? (j(this.j(t2), {code: $.invalid_literal, expected: this.C.value}), H) : {status: "valid", value: t2.data};
  }
  get value() {
    return this.C.value;
  }
};
function At(t2, e2) {
  return new Dt({values: t2, typeName: Ft.ZodEnum, ...Q(e2)});
}
Zt.create = (t2, e2) => new Zt({value: t2, typeName: Ft.ZodLiteral, ...Q(e2)});
var Dt = class extends X {
  H(t2) {
    if (typeof t2.data != "string") {
      const e2 = this.j(t2);
      return j(e2, {expected: N.joinValues(this.C.values), received: e2.parsedType, code: $.invalid_type}), H;
    }
    if (this.C.values.indexOf(t2.data) === -1) {
      const e2 = this.j(t2);
      return j(e2, {received: e2.data, code: $.invalid_enum_value, options: this.C.values}), H;
    }
    return G(t2.data);
  }
  get options() {
    return this.C.values;
  }
  get enum() {
    const t2 = {};
    for (const e2 of this.C.values)
      t2[e2] = e2;
    return t2;
  }
  get Values() {
    const t2 = {};
    for (const e2 of this.C.values)
      t2[e2] = e2;
    return t2;
  }
  get Enum() {
    const t2 = {};
    for (const e2 of this.C.values)
      t2[e2] = e2;
    return t2;
  }
};
Dt.create = At;
var $t = class extends X {
  H(t2) {
    const e2 = N.getValidEnumValues(this.C.values), n2 = this.j(t2);
    if (n2.parsedType !== A.string && n2.parsedType !== A.number) {
      const t3 = N.objectValues(e2);
      return j(n2, {expected: N.joinValues(t3), received: n2.parsedType, code: $.invalid_type}), H;
    }
    if (e2.indexOf(t2.data) === -1) {
      const t3 = N.objectValues(e2);
      return j(n2, {received: n2.data, code: $.invalid_enum_value, options: t3}), H;
    }
    return G(t2.data);
  }
  get enum() {
    return this.C.values;
  }
};
$t.create = (t2, e2) => new $t({values: t2, typeName: Ft.ZodNativeEnum, ...Q(e2)});
var Ot = class extends X {
  H(t2) {
    const {ctx: e2} = this.R(t2);
    if (e2.parsedType !== A.promise && e2.common.async === false)
      return j(e2, {code: $.invalid_type, expected: A.promise, received: e2.parsedType}), H;
    const n2 = e2.parsedType === A.promise ? e2.data : Promise.resolve(e2.data);
    return G(n2.then((t3) => this.C.type.parseAsync(t3, {path: e2.path, errorMap: e2.common.contextualErrorMap})));
  }
};
Ot.create = (t2, e2) => new Ot({type: t2, typeName: Ft.ZodPromise, ...Q(e2)});
var Lt = class extends X {
  innerType() {
    return this.C.schema;
  }
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2), r2 = this.C.effect || null;
    if (r2.type === "preprocess") {
      const t3 = r2.transform(n2.data);
      return n2.common.async ? Promise.resolve(t3).then((t4) => this.C.schema.W({data: t4, path: n2.path, parent: n2})) : this.C.schema.B({data: t3, path: n2.path, parent: n2});
    }
    const s2 = {addIssue: (t3) => {
      j(n2, t3), t3.fatal ? e2.abort() : e2.dirty();
    }, get path() {
      return n2.path;
    }};
    if (s2.addIssue = s2.addIssue.bind(s2), r2.type === "refinement") {
      const t3 = (t4) => {
        const e3 = r2.refinement(t4, s2);
        if (n2.common.async)
          return Promise.resolve(e3);
        if (e3 instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return t4;
      };
      if (n2.common.async === false) {
        const r3 = this.C.schema.B({data: n2.data, path: n2.path, parent: n2});
        return r3.status === "aborted" ? H : (r3.status === "dirty" && e2.dirty(), t3(r3.value), {status: e2.value, value: r3.value});
      }
      return this.C.schema.W({data: n2.data, path: n2.path, parent: n2}).then((n3) => n3.status === "aborted" ? H : (n3.status === "dirty" && e2.dirty(), t3(n3.value).then(() => ({status: e2.value, value: n3.value}))));
    }
    if (r2.type === "transform") {
      if (n2.common.async === false) {
        const t3 = this.C.schema.B({data: n2.data, path: n2.path, parent: n2});
        if (!z(t3))
          return t3;
        const i2 = r2.transform(t3.value, s2);
        if (i2 instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return {status: e2.value, value: i2};
      }
      return this.C.schema.W({data: n2.data, path: n2.path, parent: n2}).then((t3) => z(t3) ? Promise.resolve(r2.transform(t3.value, s2)).then((t4) => ({status: e2.value, value: t4})) : t3);
    }
    N.assertNever(r2);
  }
};
Lt.create = (t2, e2, n2) => new Lt({schema: t2, typeName: Ft.ZodEffects, effect: e2, ...Q(n2)}), Lt.createWithPreprocess = (t2, e2, n2) => new Lt({schema: e2, effect: {type: "preprocess", transform: t2}, typeName: Ft.ZodEffects, ...Q(n2)});
var Ut = class extends X {
  H(t2) {
    return this.P(t2) === A.undefined ? G(void 0) : this.C.innerType.H(t2);
  }
  unwrap() {
    return this.C.innerType;
  }
};
Ut.create = (t2, e2) => new Ut({innerType: t2, typeName: Ft.ZodOptional, ...Q(e2)});
var Ct = class extends X {
  H(t2) {
    return this.P(t2) === A.null ? G(null) : this.C.innerType.H(t2);
  }
  unwrap() {
    return this.C.innerType;
  }
};
Ct.create = (t2, e2) => new Ct({innerType: t2, typeName: Ft.ZodNullable, ...Q(e2)});
var Pt = class extends X {
  H(t2) {
    const {ctx: e2} = this.R(t2);
    let n2 = e2.data;
    return e2.parsedType === A.undefined && (n2 = this.C.defaultValue()), this.C.innerType.H({data: n2, path: e2.path, parent: e2});
  }
  removeDefault() {
    return this.C.innerType;
  }
};
Pt.create = (t2, e2) => new Ut({innerType: t2, typeName: Ft.ZodOptional, ...Q(e2)});
var jt = class extends X {
  H(t2) {
    if (this.P(t2) !== A.nan) {
      const e2 = this.j(t2);
      return j(e2, {code: $.invalid_type, expected: A.nan, received: e2.parsedType}), H;
    }
    return {status: "valid", value: t2.data};
  }
};
jt.create = (t2) => new jt({typeName: Ft.ZodNaN, ...Q(t2)});
var Ft, Rt, Bt = (t2, e2 = {}, n2) => t2 ? lt.create().superRefine((r2, s2) => {
  if (!t2(r2)) {
    const t3 = typeof e2 == "function" ? e2(r2) : e2;
    s2.addIssue({code: "custom", ...typeof t3 == "string" ? {message: t3} : t3, fatal: n2});
  }
}) : lt.create(), Ht = {object: vt.lazycreate};
(Rt = Ft || (Ft = {})).ZodString = "ZodString", Rt.ZodNumber = "ZodNumber", Rt.ZodNaN = "ZodNaN", Rt.ZodBigInt = "ZodBigInt", Rt.ZodBoolean = "ZodBoolean", Rt.ZodDate = "ZodDate", Rt.ZodUndefined = "ZodUndefined", Rt.ZodNull = "ZodNull", Rt.ZodAny = "ZodAny", Rt.ZodUnknown = "ZodUnknown", Rt.ZodNever = "ZodNever", Rt.ZodVoid = "ZodVoid", Rt.ZodArray = "ZodArray", Rt.ZodObject = "ZodObject", Rt.ZodUnion = "ZodUnion", Rt.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", Rt.ZodIntersection = "ZodIntersection", Rt.ZodTuple = "ZodTuple", Rt.ZodRecord = "ZodRecord", Rt.ZodMap = "ZodMap", Rt.ZodSet = "ZodSet", Rt.ZodFunction = "ZodFunction", Rt.ZodLazy = "ZodLazy", Rt.ZodLiteral = "ZodLiteral", Rt.ZodEnum = "ZodEnum", Rt.ZodEffects = "ZodEffects", Rt.ZodNativeEnum = "ZodNativeEnum", Rt.ZodOptional = "ZodOptional", Rt.ZodNullable = "ZodNullable", Rt.ZodDefault = "ZodDefault", Rt.ZodPromise = "ZodPromise";
var Gt, Wt, qt = rt.create, zt = it.create, Vt = ot.create, Kt = Lt.create, Jt = /* @__PURE__ */ Object.freeze({__proto__: null, getParsedType: D, ZodParsedType: A, makeIssue: P, EMPTY_PATH: [], addIssueToContext: j, ParseStatus: B, INVALID: H, DIRTY: (t2) => ({status: "dirty", value: t2}), OK: G, isAborted: W, isDirty: q, isValid: z, isAsync: V, jsonStringifyReplacer: K, ZodType: X, ZodString: rt, ZodNumber: it, ZodBigInt: at, ZodBoolean: ot, ZodDate: ut, ZodUndefined: ct, ZodNull: ht, ZodAny: lt, ZodUnknown: dt, ZodNever: ft, ZodVoid: mt, ZodArray: yt, get objectUtil() {
  return pt;
}, ZodObject: vt, ZodUnion: bt, ZodDiscriminatedUnion: xt, ZodIntersection: Nt, ZodTuple: St, ZodRecord: Mt, ZodMap: kt, ZodSet: Tt, ZodFunction: _t, ZodLazy: It, ZodLiteral: Zt, ZodEnum: Dt, ZodNativeEnum: $t, ZodPromise: Ot, ZodEffects: Lt, ZodTransformer: Lt, ZodOptional: Ut, ZodNullable: Ct, ZodDefault: Pt, ZodNaN: jt, custom: Bt, Schema: X, ZodSchema: X, late: Ht, get ZodFirstPartyTypeKind() {
  return Ft;
}, any: lt.create, array: yt.create, bigint: at.create, boolean: Vt, date: ut.create, discriminatedUnion: xt.create, effect: Kt, enum: Dt.create, function: _t.create, instanceof: (t2, e2 = {message: `Input not instance of ${t2.name}`}) => Bt((e3) => e3 instanceof t2, e2, true), intersection: Nt.create, lazy: It.create, literal: Zt.create, map: kt.create, nan: jt.create, nativeEnum: $t.create, never: ft.create, null: ht.create, nullable: Ct.create, number: zt, object: vt.create, oboolean: () => Vt().optional(), onumber: () => zt().optional(), optional: Ut.create, ostring: () => qt().optional(), preprocess: Lt.createWithPreprocess, promise: Ot.create, record: Mt.create, set: Tt.create, strictObject: vt.strictCreate, string: qt, transformer: Kt, tuple: St.create, undefined: ct.create, union: bt.create, unknown: dt.create, void: mt.create, ZodIssueCode: $, quotelessJson: (t2) => JSON.stringify(t2, null, 2).replace(/"([^"]+)":/g, "$1:"), ZodError: O, defaultErrorMap: L, setErrorMap: function(t2) {
  U = t2;
}, getErrorMap: C}), {base58check: Yt} = v(), Qt = function({ser: t2, des: e2}) {
  const n2 = function(t3 = 4096) {
    const e3 = new ArrayBuffer(t3);
    return {i: 0, view: new DataView(e3), bytes: new Uint8Array(e3)};
  }();
  return {ser: t2, des: e2, toBytes: (e3) => x(n2, t2, e3).slice(0, n2.i), toUnsafeBytes: (e3) => x(n2, t2, e3).subarray(0, n2.i), fromBytes: (t3) => function(t4, e3, n3) {
    const {length: r2} = n3;
    if (r2 < 4096) {
      t4.bytes.set(n3), t4.i = 0;
      const s3 = e3(t4);
      if (t4.i > r2)
        throw RangeError();
      return s3;
    }
    return e3({i: 0, bytes: s2 = n3, view: new DataView(s2.buffer, s2.byteOffset, s2.byteLength)});
    var s2;
  }(n2, e2, t3)};
}(((t2) => {
  const e2 = t2 instanceof Array ? () => [] : () => ({});
  return E((e3, n2) => {
    for (const r2 in t2)
      t2[r2].ser(e3, n2[r2]);
  }, (n2) => {
    const r2 = e2();
    for (const e3 in t2)
      r2[e3] = t2[e3].des(n2);
    return r2;
  });
})({test: k, timestamp: _, ulid: (Gt = M, Wt = T, E((t2, e2) => {
  const n2 = t2.i;
  Wt.ser(t2, e2.length);
  const r2 = t2.i, s2 = r2 - n2;
  Gt.encode(t2, e2);
  const i2 = t2.i, a2 = i2 - r2;
  if (a2 === e2.length)
    return;
  Wt.ser(t2, a2);
  const o2 = t2.i - i2;
  s2 !== o2 && t2.bytes.copyWithin(n2 + o2, r2, i2), t2.i = n2, Wt.ser(t2, a2), t2.i = i2 + (o2 - s2);
}, (t2) => Gt.decode(t2, Wt.des(t2)))), siphash: ((t2) => E((e2, n2) => {
  const {byteLength: r2} = n2;
  t2.ser(e2, r2), e2.bytes.set(n2, e2.i), e2.i += r2;
}, (e2) => {
  const n2 = t2.des(e2);
  return e2.bytes.subarray(e2.i, e2.i += n2);
}))(T)}));
Jt.instanceof(Uint8Array).refine((t2) => t2.length === 8, {message: `SipHash key must be ${Z.KEY_LENGTH} bytes`}), Jt.instanceof(Uint8Array).refine((t2) => t2.length === 4, {message: "SipHash hash should be 4 bytes"});
var Xt, te = Jt.object({test: Jt.boolean().default(false), timestamp: Jt.string(), ulid: Jt.string().regex(/^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$/)}), ee = (t2) => {
  try {
    const [e2] = function(t3) {
      const e3 = t3.split("-");
      if (e3.length !== 1 && e3.length !== 2)
        throw new Error("string format error");
      const n2 = e3.length === 2 ? e3[1] : e3[0], r2 = Yt(I.hash).decode(n2), s2 = Qt.fromBytes(r2), {siphash: i2, ...a2} = s2, o2 = {...a2, timestamp: a2.timestamp.toString()};
      if (!te.safeParse(o2).success)
        throw new Error("invalid payload");
      return [o2, i2];
    }(t2);
    return e2;
  } catch (t3) {
    if (t3 instanceof Jt.ZodError) {
      const e2 = t3.issues.map((t4) => `${t4.code} : [${t4.path.join(", ")}] : ${t4.message}`).join("; ");
      throw new Error(`Invalid ID:  ${e2}`);
    }
    throw t3 instanceof Error ? new Error(`Invalid ID: ${t3.message}`) : t3;
  }
};
!function(t2) {
  t2.assertEqual = (t3) => t3, t2.assertIs = function(t3) {
  }, t2.assertNever = function(t3) {
    throw new Error();
  }, t2.arrayToEnum = (t3) => {
    const e2 = {};
    for (const n2 of t3)
      e2[n2] = n2;
    return e2;
  }, t2.getValidEnumValues = (e2) => {
    const n2 = t2.objectKeys(e2).filter((t3) => typeof e2[e2[t3]] != "number"), r2 = {};
    for (const t3 of n2)
      r2[t3] = e2[t3];
    return t2.objectValues(r2);
  }, t2.objectValues = (e2) => t2.objectKeys(e2).map(function(t3) {
    return e2[t3];
  }), t2.objectKeys = typeof Object.keys == "function" ? (t3) => Object.keys(t3) : (t3) => {
    const e2 = [];
    for (const n2 in t3)
      Object.prototype.hasOwnProperty.call(t3, n2) && e2.push(n2);
    return e2;
  }, t2.find = (t3, e2) => {
    for (const n2 of t3)
      if (e2(n2))
        return n2;
  }, t2.isInteger = typeof Number.isInteger == "function" ? (t3) => Number.isInteger(t3) : (t3) => typeof t3 == "number" && isFinite(t3) && Math.floor(t3) === t3, t2.joinValues = function(t3, e2 = " | ") {
    return t3.map((t4) => typeof t4 == "string" ? `'${t4}'` : t4).join(e2);
  };
}(Xt || (Xt = {}));
const ne = Xt.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), re = (t2) => {
  switch (typeof t2) {
    case "undefined":
      return ne.undefined;
    case "string":
      return ne.string;
    case "number":
      return isNaN(t2) ? ne.nan : ne.number;
    case "boolean":
      return ne.boolean;
    case "function":
      return ne.function;
    case "bigint":
      return ne.bigint;
    case "object":
      return Array.isArray(t2) ? ne.array : t2 === null ? ne.null : t2.then && typeof t2.then == "function" && t2.catch && typeof t2.catch == "function" ? ne.promise : typeof Map != "undefined" && t2 instanceof Map ? ne.map : typeof Set != "undefined" && t2 instanceof Set ? ne.set : typeof Date != "undefined" && t2 instanceof Date ? ne.date : ne.object;
    default:
      return ne.unknown;
  }
}, se = Xt.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of"]);
class ie extends Error {
  constructor(t2) {
    super(), this.issues = [], this.addIssue = (t3) => {
      this.issues = [...this.issues, t3];
    }, this.addIssues = (t3 = []) => {
      this.issues = [...this.issues, ...t3];
    };
    const e2 = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, e2) : this.__proto__ = e2, this.name = "ZodError", this.issues = t2;
  }
  get errors() {
    return this.issues;
  }
  format(t2) {
    const e2 = t2 || function(t3) {
      return t3.message;
    }, n2 = {$: []}, r2 = (t3) => {
      for (const s2 of t3.issues)
        if (s2.code === "invalid_union")
          s2.unionErrors.map(r2);
        else if (s2.code === "invalid_return_type")
          r2(s2.returnTypeError);
        else if (s2.code === "invalid_arguments")
          r2(s2.argumentsError);
        else if (s2.path.length === 0)
          n2.$.push(e2(s2));
        else {
          let t4 = n2, r3 = 0;
          for (; r3 < s2.path.length; ) {
            const n3 = s2.path[r3];
            r3 === s2.path.length - 1 ? (t4[n3] = t4[n3] || {$: []}, t4[n3].$.push(e2(s2))) : t4[n3] = t4[n3] || {$: []}, t4 = t4[n3], r3++;
          }
        }
    };
    return r2(this), n2;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, ge, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t2 = (t3) => t3.message) {
    const e2 = {}, n2 = [];
    for (const r2 of this.issues)
      r2.path.length > 0 ? (e2[r2.path[0]] = e2[r2.path[0]] || [], e2[r2.path[0]].push(t2(r2))) : n2.push(t2(r2));
    return {formErrors: n2, fieldErrors: e2};
  }
  get formErrors() {
    return this.flatten();
  }
}
ie.create = (t2) => new ie(t2);
const ae = (t2, e2) => {
  let n2;
  switch (t2.code) {
    case se.invalid_type:
      n2 = t2.received === ne.undefined ? "Required" : `Expected ${t2.expected}, received ${t2.received}`;
      break;
    case se.invalid_literal:
      n2 = `Invalid literal value, expected ${JSON.stringify(t2.expected, ge)}`;
      break;
    case se.unrecognized_keys:
      n2 = `Unrecognized key(s) in object: ${Xt.joinValues(t2.keys, ", ")}`;
      break;
    case se.invalid_union:
      n2 = "Invalid input";
      break;
    case se.invalid_union_discriminator:
      n2 = `Invalid discriminator value. Expected ${Xt.joinValues(t2.options)}`;
      break;
    case se.invalid_enum_value:
      n2 = `Invalid enum value. Expected ${Xt.joinValues(t2.options)}, received '${t2.received}'`;
      break;
    case se.invalid_arguments:
      n2 = "Invalid function arguments";
      break;
    case se.invalid_return_type:
      n2 = "Invalid function return type";
      break;
    case se.invalid_date:
      n2 = "Invalid date";
      break;
    case se.invalid_string:
      typeof t2.validation == "object" ? "startsWith" in t2.validation ? n2 = `Invalid input: must start with "${t2.validation.startsWith}"` : "endsWith" in t2.validation ? n2 = `Invalid input: must end with "${t2.validation.endsWith}"` : Xt.assertNever(t2.validation) : n2 = t2.validation !== "regex" ? `Invalid ${t2.validation}` : "Invalid";
      break;
    case se.too_small:
      n2 = t2.type === "array" ? `Array must contain ${t2.inclusive ? "at least" : "more than"} ${t2.minimum} element(s)` : t2.type === "string" ? `String must contain ${t2.inclusive ? "at least" : "over"} ${t2.minimum} character(s)` : t2.type === "number" ? `Number must be greater than ${t2.inclusive ? "or equal to " : ""}${t2.minimum}` : t2.type === "date" ? `Date must be greater than ${t2.inclusive ? "or equal to " : ""}${new Date(t2.minimum)}` : "Invalid input";
      break;
    case se.too_big:
      n2 = t2.type === "array" ? `Array must contain ${t2.inclusive ? "at most" : "less than"} ${t2.maximum} element(s)` : t2.type === "string" ? `String must contain ${t2.inclusive ? "at most" : "under"} ${t2.maximum} character(s)` : t2.type === "number" ? `Number must be less than ${t2.inclusive ? "or equal to " : ""}${t2.maximum}` : t2.type === "date" ? `Date must be smaller than ${t2.inclusive ? "or equal to " : ""}${new Date(t2.maximum)}` : "Invalid input";
      break;
    case se.custom:
      n2 = "Invalid input";
      break;
    case se.invalid_intersection_types:
      n2 = "Intersection results could not be merged";
      break;
    case se.not_multiple_of:
      n2 = `Number must be a multiple of ${t2.multipleOf}`;
      break;
    default:
      n2 = e2.defaultError, Xt.assertNever(t2);
  }
  return {message: n2};
};
let oe = ae;
function ue() {
  return oe;
}
const ce = (t2) => {
  const {data: e2, path: n2, errorMaps: r2, issueData: s2} = t2, i2 = [...n2, ...s2.path || []], a2 = {...s2, path: i2};
  let o2 = "";
  const u2 = r2.filter((t3) => !!t3).slice().reverse();
  for (const t3 of u2)
    o2 = t3(a2, {data: e2, defaultError: o2}).message;
  return {...s2, path: i2, message: s2.message || o2};
};
function he(t2, e2) {
  const n2 = ce({issueData: e2, data: t2.data, path: t2.path, errorMaps: [t2.common.contextualErrorMap, t2.schemaErrorMap, ue(), ae].filter((t3) => !!t3)});
  t2.common.issues.push(n2);
}
class le {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t2, e2) {
    const n2 = [];
    for (const r2 of e2) {
      if (r2.status === "aborted")
        return de;
      r2.status === "dirty" && t2.dirty(), n2.push(r2.value);
    }
    return {status: t2.value, value: n2};
  }
  static async mergeObjectAsync(t2, e2) {
    const n2 = [];
    for (const t3 of e2)
      n2.push({key: await t3.key, value: await t3.value});
    return le.mergeObjectSync(t2, n2);
  }
  static mergeObjectSync(t2, e2) {
    const n2 = {};
    for (const r2 of e2) {
      const {key: e3, value: s2} = r2;
      if (e3.status === "aborted")
        return de;
      if (s2.status === "aborted")
        return de;
      e3.status === "dirty" && t2.dirty(), s2.status === "dirty" && t2.dirty(), (s2.value !== void 0 || r2.alwaysSet) && (n2[e3.value] = s2.value);
    }
    return {status: t2.value, value: n2};
  }
}
const de = Object.freeze({status: "aborted"}), fe = (t2) => ({status: "valid", value: t2}), me = (t2) => t2.status === "aborted", pe = (t2) => t2.status === "dirty", ye = (t2) => t2.status === "valid", we = (t2) => typeof Promise !== void 0 && t2 instanceof Promise, ge = (t2, e2) => typeof e2 == "bigint" ? e2.toString() : e2;
var ve;
!function(t2) {
  t2.errToObj = (t3) => typeof t3 == "string" ? {message: t3} : t3 || {}, t2.toString = (t3) => typeof t3 == "string" ? t3 : t3 == null ? void 0 : t3.message;
}(ve || (ve = {}));
class be {
  constructor(t2, e2, n2, r2) {
    this.parent = t2, this.data = e2, this.O = n2, this.L = r2;
  }
  get path() {
    return this.O.concat(this.L);
  }
}
const xe = (t2, e2) => {
  if (ye(e2))
    return {success: true, data: e2.value};
  if (!t2.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {success: false, error: new ie(t2.common.issues)};
};
function Ee(t2) {
  if (!t2)
    return {};
  const {errorMap: e2, invalid_type_error: n2, required_error: r2, description: s2} = t2;
  if (e2 && (n2 || r2))
    throw new Error(`Can't use "invalid" or "required" in conjunction with custom error map.`);
  return e2 ? {errorMap: e2, description: s2} : {errorMap: (t3, e3) => t3.code !== "invalid_type" ? {message: e3.defaultError} : e3.data === void 0 ? {message: r2 != null ? r2 : e3.defaultError} : {message: n2 != null ? n2 : e3.defaultError}, description: s2};
}
class Ne {
  constructor(t2) {
    this.spa = this.safeParseAsync, this.superRefine = this.U, this.C = t2, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.default = this.default.bind(this), this.describe = this.describe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this.C.description;
  }
  P(t2) {
    return re(t2.data);
  }
  j(t2, e2) {
    return e2 || {common: t2.parent.common, data: t2.data, parsedType: re(t2.data), schemaErrorMap: this.C.errorMap, path: t2.path, parent: t2.parent};
  }
  R(t2) {
    return {status: new le(), ctx: {common: t2.parent.common, data: t2.data, parsedType: re(t2.data), schemaErrorMap: this.C.errorMap, path: t2.path, parent: t2.parent}};
  }
  B(t2) {
    const e2 = this.H(t2);
    if (we(e2))
      throw new Error("Synchronous parse encountered promise.");
    return e2;
  }
  W(t2) {
    const e2 = this.H(t2);
    return Promise.resolve(e2);
  }
  parse(t2, e2) {
    const n2 = this.safeParse(t2, e2);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  safeParse(t2, e2) {
    var n2;
    const r2 = {common: {issues: [], async: (n2 = e2 == null ? void 0 : e2.async) !== null && n2 !== void 0 && n2, contextualErrorMap: e2 == null ? void 0 : e2.errorMap}, path: (e2 == null ? void 0 : e2.path) || [], schemaErrorMap: this.C.errorMap, parent: null, data: t2, parsedType: re(t2)}, s2 = this.B({data: t2, path: r2.path, parent: r2});
    return xe(r2, s2);
  }
  async parseAsync(t2, e2) {
    const n2 = await this.safeParseAsync(t2, e2);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  async safeParseAsync(t2, e2) {
    const n2 = {common: {issues: [], contextualErrorMap: e2 == null ? void 0 : e2.errorMap, async: true}, path: (e2 == null ? void 0 : e2.path) || [], schemaErrorMap: this.C.errorMap, parent: null, data: t2, parsedType: re(t2)}, r2 = this.H({data: t2, path: [], parent: n2}), s2 = await (we(r2) ? r2 : Promise.resolve(r2));
    return xe(n2, s2);
  }
  refine(t2, e2) {
    const n2 = (t3) => typeof e2 == "string" || e2 === void 0 ? {message: e2} : typeof e2 == "function" ? e2(t3) : e2;
    return this.U((e3, r2) => {
      const s2 = t2(e3), i2 = () => r2.addIssue({code: se.custom, ...n2(e3)});
      return typeof Promise != "undefined" && s2 instanceof Promise ? s2.then((t3) => !!t3 || (i2(), false)) : !!s2 || (i2(), false);
    });
  }
  refinement(t2, e2) {
    return this.U((n2, r2) => !!t2(n2) || (r2.addIssue(typeof e2 == "function" ? e2(n2, r2) : e2), false));
  }
  U(t2) {
    return new an({schema: this, typeName: pn.ZodEffects, effect: {type: "refinement", refinement: t2}});
  }
  optional() {
    return on.create(this);
  }
  nullable() {
    return un.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return je.create(this);
  }
  promise() {
    return sn.create(this);
  }
  or(t2) {
    return Ge.create([this, t2]);
  }
  and(t2) {
    return ze.create(this, t2);
  }
  transform(t2) {
    return new an({schema: this, typeName: pn.ZodEffects, effect: {type: "transform", transform: t2}});
  }
  default(t2) {
    return new cn({innerType: this, defaultValue: typeof t2 == "function" ? t2 : () => t2, typeName: pn.ZodDefault});
  }
  brand() {
    return new dn({typeName: pn.ZodBranded, type: this, ...Ee(void 0)});
  }
  describe(t2) {
    return new this.constructor({...this.C, description: t2});
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const Se = /^c[^\s-]{8,}$/i, Me = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, ke = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
class Te extends Ne {
  constructor() {
    super(...arguments), this.V = (t2, e2, n2) => this.refinement((e3) => t2.test(e3), {validation: e2, code: se.invalid_string, ...ve.errToObj(n2)}), this.nonempty = (t2) => this.min(1, ve.errToObj(t2)), this.trim = () => new Te({...this.C, checks: [...this.C.checks, {kind: "trim"}]});
  }
  H(t2) {
    if (this.P(t2) !== ne.string) {
      const e3 = this.j(t2);
      return he(e3, {code: se.invalid_type, expected: ne.string, received: e3.parsedType}), de;
    }
    const e2 = new le();
    let n2;
    for (const r2 of this.C.checks)
      if (r2.kind === "min")
        t2.data.length < r2.value && (n2 = this.j(t2, n2), he(n2, {code: se.too_small, minimum: r2.value, type: "string", inclusive: true, message: r2.message}), e2.dirty());
      else if (r2.kind === "max")
        t2.data.length > r2.value && (n2 = this.j(t2, n2), he(n2, {code: se.too_big, maximum: r2.value, type: "string", inclusive: true, message: r2.message}), e2.dirty());
      else if (r2.kind === "email")
        ke.test(t2.data) || (n2 = this.j(t2, n2), he(n2, {validation: "email", code: se.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "uuid")
        Me.test(t2.data) || (n2 = this.j(t2, n2), he(n2, {validation: "uuid", code: se.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "cuid")
        Se.test(t2.data) || (n2 = this.j(t2, n2), he(n2, {validation: "cuid", code: se.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "url")
        try {
          new URL(t2.data);
        } catch (s2) {
          n2 = this.j(t2, n2), he(n2, {validation: "url", code: se.invalid_string, message: r2.message}), e2.dirty();
        }
      else
        r2.kind === "regex" ? (r2.regex.lastIndex = 0, r2.regex.test(t2.data) || (n2 = this.j(t2, n2), he(n2, {validation: "regex", code: se.invalid_string, message: r2.message}), e2.dirty())) : r2.kind === "trim" ? t2.data = t2.data.trim() : r2.kind === "startsWith" ? t2.data.startsWith(r2.value) || (n2 = this.j(t2, n2), he(n2, {code: se.invalid_string, validation: {startsWith: r2.value}, message: r2.message}), e2.dirty()) : r2.kind === "endsWith" ? t2.data.endsWith(r2.value) || (n2 = this.j(t2, n2), he(n2, {code: se.invalid_string, validation: {endsWith: r2.value}, message: r2.message}), e2.dirty()) : Xt.assertNever(r2);
    return {status: e2.value, value: t2.data};
  }
  K(t2) {
    return new Te({...this.C, checks: [...this.C.checks, t2]});
  }
  email(t2) {
    return this.K({kind: "email", ...ve.errToObj(t2)});
  }
  url(t2) {
    return this.K({kind: "url", ...ve.errToObj(t2)});
  }
  uuid(t2) {
    return this.K({kind: "uuid", ...ve.errToObj(t2)});
  }
  cuid(t2) {
    return this.K({kind: "cuid", ...ve.errToObj(t2)});
  }
  regex(t2, e2) {
    return this.K({kind: "regex", regex: t2, ...ve.errToObj(e2)});
  }
  startsWith(t2, e2) {
    return this.K({kind: "startsWith", value: t2, ...ve.errToObj(e2)});
  }
  endsWith(t2, e2) {
    return this.K({kind: "endsWith", value: t2, ...ve.errToObj(e2)});
  }
  min(t2, e2) {
    return this.K({kind: "min", value: t2, ...ve.errToObj(e2)});
  }
  max(t2, e2) {
    return this.K({kind: "max", value: t2, ...ve.errToObj(e2)});
  }
  length(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  get isEmail() {
    return !!this.C.checks.find((t2) => t2.kind === "email");
  }
  get isURL() {
    return !!this.C.checks.find((t2) => t2.kind === "url");
  }
  get isUUID() {
    return !!this.C.checks.find((t2) => t2.kind === "uuid");
  }
  get isCUID() {
    return !!this.C.checks.find((t2) => t2.kind === "cuid");
  }
  get minLength() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "min" && (t2 === null || e2.value > t2) && (t2 = e2.value);
    return t2;
  }
  get maxLength() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "max" && (t2 === null || e2.value < t2) && (t2 = e2.value);
    return t2;
  }
}
function _e(t2, e2) {
  const n2 = (t2.toString().split(".")[1] || "").length, r2 = (e2.toString().split(".")[1] || "").length, s2 = n2 > r2 ? n2 : r2;
  return parseInt(t2.toFixed(s2).replace(".", "")) % parseInt(e2.toFixed(s2).replace(".", "")) / Math.pow(10, s2);
}
Te.create = (t2) => new Te({checks: [], typeName: pn.ZodString, ...Ee(t2)});
class Ie extends Ne {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  H(t2) {
    if (this.P(t2) !== ne.number) {
      const e3 = this.j(t2);
      return he(e3, {code: se.invalid_type, expected: ne.number, received: e3.parsedType}), de;
    }
    let e2;
    const n2 = new le();
    for (const r2 of this.C.checks)
      r2.kind === "int" ? Xt.isInteger(t2.data) || (e2 = this.j(t2, e2), he(e2, {code: se.invalid_type, expected: "integer", received: "float", message: r2.message}), n2.dirty()) : r2.kind === "min" ? (r2.inclusive ? t2.data < r2.value : t2.data <= r2.value) && (e2 = this.j(t2, e2), he(e2, {code: se.too_small, minimum: r2.value, type: "number", inclusive: r2.inclusive, message: r2.message}), n2.dirty()) : r2.kind === "max" ? (r2.inclusive ? t2.data > r2.value : t2.data >= r2.value) && (e2 = this.j(t2, e2), he(e2, {code: se.too_big, maximum: r2.value, type: "number", inclusive: r2.inclusive, message: r2.message}), n2.dirty()) : r2.kind === "multipleOf" ? _e(t2.data, r2.value) !== 0 && (e2 = this.j(t2, e2), he(e2, {code: se.not_multiple_of, multipleOf: r2.value, message: r2.message}), n2.dirty()) : Xt.assertNever(r2);
    return {status: n2.value, value: t2.data};
  }
  gte(t2, e2) {
    return this.setLimit("min", t2, true, ve.toString(e2));
  }
  gt(t2, e2) {
    return this.setLimit("min", t2, false, ve.toString(e2));
  }
  lte(t2, e2) {
    return this.setLimit("max", t2, true, ve.toString(e2));
  }
  lt(t2, e2) {
    return this.setLimit("max", t2, false, ve.toString(e2));
  }
  setLimit(t2, e2, n2, r2) {
    return new Ie({...this.C, checks: [...this.C.checks, {kind: t2, value: e2, inclusive: n2, message: ve.toString(r2)}]});
  }
  K(t2) {
    return new Ie({...this.C, checks: [...this.C.checks, t2]});
  }
  int(t2) {
    return this.K({kind: "int", message: ve.toString(t2)});
  }
  positive(t2) {
    return this.K({kind: "min", value: 0, inclusive: false, message: ve.toString(t2)});
  }
  negative(t2) {
    return this.K({kind: "max", value: 0, inclusive: false, message: ve.toString(t2)});
  }
  nonpositive(t2) {
    return this.K({kind: "max", value: 0, inclusive: true, message: ve.toString(t2)});
  }
  nonnegative(t2) {
    return this.K({kind: "min", value: 0, inclusive: true, message: ve.toString(t2)});
  }
  multipleOf(t2, e2) {
    return this.K({kind: "multipleOf", value: t2, message: ve.toString(e2)});
  }
  get minValue() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "min" && (t2 === null || e2.value > t2) && (t2 = e2.value);
    return t2;
  }
  get maxValue() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "max" && (t2 === null || e2.value < t2) && (t2 = e2.value);
    return t2;
  }
  get isInt() {
    return !!this.C.checks.find((t2) => t2.kind === "int");
  }
}
Ie.create = (t2) => new Ie({checks: [], typeName: pn.ZodNumber, ...Ee(t2)});
class Ze extends Ne {
  H(t2) {
    if (this.P(t2) !== ne.bigint) {
      const e2 = this.j(t2);
      return he(e2, {code: se.invalid_type, expected: ne.bigint, received: e2.parsedType}), de;
    }
    return fe(t2.data);
  }
}
Ze.create = (t2) => new Ze({typeName: pn.ZodBigInt, ...Ee(t2)});
class Ae extends Ne {
  H(t2) {
    if (this.P(t2) !== ne.boolean) {
      const e2 = this.j(t2);
      return he(e2, {code: se.invalid_type, expected: ne.boolean, received: e2.parsedType}), de;
    }
    return fe(t2.data);
  }
}
Ae.create = (t2) => new Ae({typeName: pn.ZodBoolean, ...Ee(t2)});
class De extends Ne {
  H(t2) {
    if (this.P(t2) !== ne.date) {
      const e3 = this.j(t2);
      return he(e3, {code: se.invalid_type, expected: ne.date, received: e3.parsedType}), de;
    }
    if (isNaN(t2.data.getTime()))
      return he(this.j(t2), {code: se.invalid_date}), de;
    const e2 = new le();
    let n2;
    for (const r2 of this.C.checks)
      r2.kind === "min" ? t2.data.getTime() < r2.value && (n2 = this.j(t2, n2), he(n2, {code: se.too_small, message: r2.message, inclusive: true, minimum: r2.value, type: "date"}), e2.dirty()) : r2.kind === "max" ? t2.data.getTime() > r2.value && (n2 = this.j(t2, n2), he(n2, {code: se.too_big, message: r2.message, inclusive: true, maximum: r2.value, type: "date"}), e2.dirty()) : Xt.assertNever(r2);
    return {status: e2.value, value: new Date(t2.data.getTime())};
  }
  K(t2) {
    return new De({...this.C, checks: [...this.C.checks, t2]});
  }
  min(t2, e2) {
    return this.K({kind: "min", value: t2.getTime(), message: ve.toString(e2)});
  }
  max(t2, e2) {
    return this.K({kind: "max", value: t2.getTime(), message: ve.toString(e2)});
  }
  get minDate() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "min" && (t2 === null || e2.value > t2) && (t2 = e2.value);
    return t2 != null ? new Date(t2) : null;
  }
  get maxDate() {
    let t2 = null;
    for (const e2 of this.C.checks)
      e2.kind === "max" && (t2 === null || e2.value < t2) && (t2 = e2.value);
    return t2 != null ? new Date(t2) : null;
  }
}
De.create = (t2) => new De({checks: [], typeName: pn.ZodDate, ...Ee(t2)});
class $e extends Ne {
  H(t2) {
    if (this.P(t2) !== ne.undefined) {
      const e2 = this.j(t2);
      return he(e2, {code: se.invalid_type, expected: ne.undefined, received: e2.parsedType}), de;
    }
    return fe(t2.data);
  }
}
$e.create = (t2) => new $e({typeName: pn.ZodUndefined, ...Ee(t2)});
class Oe extends Ne {
  H(t2) {
    if (this.P(t2) !== ne.null) {
      const e2 = this.j(t2);
      return he(e2, {code: se.invalid_type, expected: ne.null, received: e2.parsedType}), de;
    }
    return fe(t2.data);
  }
}
Oe.create = (t2) => new Oe({typeName: pn.ZodNull, ...Ee(t2)});
class Le extends Ne {
  constructor() {
    super(...arguments), this.J = true;
  }
  H(t2) {
    return fe(t2.data);
  }
}
Le.create = (t2) => new Le({typeName: pn.ZodAny, ...Ee(t2)});
class Ue extends Ne {
  constructor() {
    super(...arguments), this.Y = true;
  }
  H(t2) {
    return fe(t2.data);
  }
}
Ue.create = (t2) => new Ue({typeName: pn.ZodUnknown, ...Ee(t2)});
class Ce extends Ne {
  H(t2) {
    const e2 = this.j(t2);
    return he(e2, {code: se.invalid_type, expected: ne.never, received: e2.parsedType}), de;
  }
}
Ce.create = (t2) => new Ce({typeName: pn.ZodNever, ...Ee(t2)});
class Pe extends Ne {
  H(t2) {
    if (this.P(t2) !== ne.undefined) {
      const e2 = this.j(t2);
      return he(e2, {code: se.invalid_type, expected: ne.void, received: e2.parsedType}), de;
    }
    return fe(t2.data);
  }
}
Pe.create = (t2) => new Pe({typeName: pn.ZodVoid, ...Ee(t2)});
class je extends Ne {
  H(t2) {
    const {ctx: e2, status: n2} = this.R(t2), r2 = this.C;
    if (e2.parsedType !== ne.array)
      return he(e2, {code: se.invalid_type, expected: ne.array, received: e2.parsedType}), de;
    if (r2.minLength !== null && e2.data.length < r2.minLength.value && (he(e2, {code: se.too_small, minimum: r2.minLength.value, type: "array", inclusive: true, message: r2.minLength.message}), n2.dirty()), r2.maxLength !== null && e2.data.length > r2.maxLength.value && (he(e2, {code: se.too_big, maximum: r2.maxLength.value, type: "array", inclusive: true, message: r2.maxLength.message}), n2.dirty()), e2.common.async)
      return Promise.all(e2.data.map((t3, n3) => r2.type.W(new be(e2, t3, e2.path, n3)))).then((t3) => le.mergeArray(n2, t3));
    const s2 = e2.data.map((t3, n3) => r2.type.B(new be(e2, t3, e2.path, n3)));
    return le.mergeArray(n2, s2);
  }
  get element() {
    return this.C.type;
  }
  min(t2, e2) {
    return new je({...this.C, minLength: {value: t2, message: ve.toString(e2)}});
  }
  max(t2, e2) {
    return new je({...this.C, maxLength: {value: t2, message: ve.toString(e2)}});
  }
  length(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  nonempty(t2) {
    return this.min(1, t2);
  }
}
var Fe;
je.create = (t2, e2) => new je({type: t2, minLength: null, maxLength: null, typeName: pn.ZodArray, ...Ee(e2)}), function(t2) {
  t2.mergeShapes = (t3, e2) => ({...t3, ...e2});
}(Fe || (Fe = {}));
const Re = (t2) => (e2) => new He({...t2, shape: () => ({...t2.shape(), ...e2})});
function Be(t2) {
  if (t2 instanceof He) {
    const e2 = {};
    for (const n2 in t2.shape)
      e2[n2] = on.create(Be(t2.shape[n2]));
    return new He({...t2.C, shape: () => e2});
  }
  return t2 instanceof je ? je.create(Be(t2.element)) : t2 instanceof on ? on.create(Be(t2.unwrap())) : t2 instanceof un ? un.create(Be(t2.unwrap())) : t2 instanceof Ve ? Ve.create(t2.items.map((t3) => Be(t3))) : t2;
}
class He extends Ne {
  constructor() {
    super(...arguments), this.X = null, this.nonstrict = this.passthrough, this.augment = Re(this.C), this.extend = Re(this.C);
  }
  et() {
    if (this.X !== null)
      return this.X;
    const t2 = this.C.shape(), e2 = Xt.objectKeys(t2);
    return this.X = {shape: t2, keys: e2};
  }
  H(t2) {
    if (this.P(t2) !== ne.object) {
      const e3 = this.j(t2);
      return he(e3, {code: se.invalid_type, expected: ne.object, received: e3.parsedType}), de;
    }
    const {status: e2, ctx: n2} = this.R(t2), {shape: r2, keys: s2} = this.et(), i2 = [];
    for (const t3 in n2.data)
      s2.includes(t3) || i2.push(t3);
    const a2 = [];
    for (const t3 of s2)
      a2.push({key: {status: "valid", value: t3}, value: r2[t3].H(new be(n2, n2.data[t3], n2.path, t3)), alwaysSet: t3 in n2.data});
    if (this.C.catchall instanceof Ce) {
      const t3 = this.C.unknownKeys;
      if (t3 === "passthrough")
        for (const t4 of i2)
          a2.push({key: {status: "valid", value: t4}, value: {status: "valid", value: n2.data[t4]}});
      else if (t3 === "strict")
        i2.length > 0 && (he(n2, {code: se.unrecognized_keys, keys: i2}), e2.dirty());
      else if (t3 !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const t3 = this.C.catchall;
      for (const e3 of i2)
        a2.push({key: {status: "valid", value: e3}, value: t3.H(new be(n2, n2.data[e3], n2.path, e3)), alwaysSet: e3 in n2.data});
    }
    return n2.common.async ? Promise.resolve().then(async () => {
      const t3 = [];
      for (const e3 of a2) {
        const n3 = await e3.key;
        t3.push({key: n3, value: await e3.value, alwaysSet: e3.alwaysSet});
      }
      return t3;
    }).then((t3) => le.mergeObjectSync(e2, t3)) : le.mergeObjectSync(e2, a2);
  }
  get shape() {
    return this.C.shape();
  }
  strict(t2) {
    return new He({...this.C, unknownKeys: "strict", ...t2 !== void 0 ? {errorMap: (e2, n2) => {
      var r2, s2, i2, a2;
      const o2 = (i2 = (s2 = (r2 = this.C).errorMap) === null || s2 === void 0 ? void 0 : s2.call(r2, e2, n2).message) !== null && i2 !== void 0 ? i2 : n2.defaultError;
      return e2.code === "unrecognized_keys" ? {message: (a2 = ve.errToObj(t2).message) !== null && a2 !== void 0 ? a2 : o2} : {message: o2};
    }} : {}});
  }
  strip() {
    return new He({...this.C, unknownKeys: "strip"});
  }
  passthrough() {
    return new He({...this.C, unknownKeys: "passthrough"});
  }
  setKey(t2, e2) {
    return this.augment({[t2]: e2});
  }
  merge(t2) {
    return new He({unknownKeys: t2.C.unknownKeys, catchall: t2.C.catchall, shape: () => Fe.mergeShapes(this.C.shape(), t2.C.shape()), typeName: pn.ZodObject});
  }
  catchall(t2) {
    return new He({...this.C, catchall: t2});
  }
  pick(t2) {
    const e2 = {};
    return Xt.objectKeys(t2).map((t3) => {
      this.shape[t3] && (e2[t3] = this.shape[t3]);
    }), new He({...this.C, shape: () => e2});
  }
  omit(t2) {
    const e2 = {};
    return Xt.objectKeys(this.shape).map((n2) => {
      Xt.objectKeys(t2).indexOf(n2) === -1 && (e2[n2] = this.shape[n2]);
    }), new He({...this.C, shape: () => e2});
  }
  deepPartial() {
    return Be(this);
  }
  partial(t2) {
    const e2 = {};
    if (t2)
      return Xt.objectKeys(this.shape).map((n2) => {
        e2[n2] = Xt.objectKeys(t2).indexOf(n2) === -1 ? this.shape[n2] : this.shape[n2].optional();
      }), new He({...this.C, shape: () => e2});
    for (const t3 in this.shape)
      e2[t3] = this.shape[t3].optional();
    return new He({...this.C, shape: () => e2});
  }
  required() {
    const t2 = {};
    for (const e2 in this.shape) {
      let n2 = this.shape[e2];
      for (; n2 instanceof on; )
        n2 = n2.C.innerType;
      t2[e2] = n2;
    }
    return new He({...this.C, shape: () => t2});
  }
  keyof() {
    return en(Xt.objectKeys(this.shape));
  }
}
He.create = (t2, e2) => new He({shape: () => t2, unknownKeys: "strip", catchall: Ce.create(), typeName: pn.ZodObject, ...Ee(e2)}), He.strictCreate = (t2, e2) => new He({shape: () => t2, unknownKeys: "strict", catchall: Ce.create(), typeName: pn.ZodObject, ...Ee(e2)}), He.lazycreate = (t2, e2) => new He({shape: t2, unknownKeys: "strip", catchall: Ce.create(), typeName: pn.ZodObject, ...Ee(e2)});
class Ge extends Ne {
  H(t2) {
    const {ctx: e2} = this.R(t2), n2 = this.C.options;
    if (e2.common.async)
      return Promise.all(n2.map(async (t3) => {
        const n3 = {...e2, common: {...e2.common, issues: []}, parent: null};
        return {result: await t3.W({data: e2.data, path: e2.path, parent: n3}), ctx: n3};
      })).then(function(t3) {
        for (const e3 of t3)
          if (e3.result.status === "valid")
            return e3.result;
        for (const n4 of t3)
          if (n4.result.status === "dirty")
            return e2.common.issues.push(...n4.ctx.common.issues), n4.result;
        const n3 = t3.map((t4) => new ie(t4.ctx.common.issues));
        return he(e2, {code: se.invalid_union, unionErrors: n3}), de;
      });
    {
      let t3;
      const r2 = [];
      for (const s3 of n2) {
        const n3 = {...e2, common: {...e2.common, issues: []}, parent: null}, i2 = s3.B({data: e2.data, path: e2.path, parent: n3});
        if (i2.status === "valid")
          return i2;
        i2.status !== "dirty" || t3 || (t3 = {result: i2, ctx: n3}), n3.common.issues.length && r2.push(n3.common.issues);
      }
      if (t3)
        return e2.common.issues.push(...t3.ctx.common.issues), t3.result;
      const s2 = r2.map((t4) => new ie(t4));
      return he(e2, {code: se.invalid_union, unionErrors: s2}), de;
    }
  }
  get options() {
    return this.C.options;
  }
}
Ge.create = (t2, e2) => new Ge({options: t2, typeName: pn.ZodUnion, ...Ee(e2)});
class We extends Ne {
  H(t2) {
    const {ctx: e2} = this.R(t2);
    if (e2.parsedType !== ne.object)
      return he(e2, {code: se.invalid_type, expected: ne.object, received: e2.parsedType}), de;
    const n2 = this.discriminator, r2 = this.options.get(e2.data[n2]);
    return r2 ? e2.common.async ? r2.W({data: e2.data, path: e2.path, parent: e2}) : r2.B({data: e2.data, path: e2.path, parent: e2}) : (he(e2, {code: se.invalid_union_discriminator, options: this.validDiscriminatorValues, path: [n2]}), de);
  }
  get discriminator() {
    return this.C.discriminator;
  }
  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }
  get options() {
    return this.C.options;
  }
  static create(t2, e2, n2) {
    const r2 = new Map();
    try {
      e2.forEach((e3) => {
        r2.set(e3.shape[t2].value, e3);
      });
    } catch (t3) {
      throw new Error("The discriminator value could not be extracted from all the provided schemas");
    }
    if (r2.size !== e2.length)
      throw new Error("Some of the discriminator values are not unique");
    return new We({typeName: pn.ZodDiscriminatedUnion, discriminator: t2, options: r2, ...Ee(n2)});
  }
}
function qe(t2, e2) {
  const n2 = re(t2), r2 = re(e2);
  if (t2 === e2)
    return {valid: true, data: t2};
  if (n2 === ne.object && r2 === ne.object) {
    const n3 = Xt.objectKeys(e2), r3 = Xt.objectKeys(t2).filter((t3) => n3.indexOf(t3) !== -1), s2 = {...t2, ...e2};
    for (const n4 of r3) {
      const r4 = qe(t2[n4], e2[n4]);
      if (!r4.valid)
        return {valid: false};
      s2[n4] = r4.data;
    }
    return {valid: true, data: s2};
  }
  if (n2 === ne.array && r2 === ne.array) {
    if (t2.length !== e2.length)
      return {valid: false};
    const n3 = [];
    for (let r3 = 0; r3 < t2.length; r3++) {
      const s2 = qe(t2[r3], e2[r3]);
      if (!s2.valid)
        return {valid: false};
      n3.push(s2.data);
    }
    return {valid: true, data: n3};
  }
  return n2 === ne.date && r2 === ne.date && +t2 == +e2 ? {valid: true, data: t2} : {valid: false};
}
class ze extends Ne {
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2), r2 = (t3, r3) => {
      if (me(t3) || me(r3))
        return de;
      const s2 = qe(t3.value, r3.value);
      return s2.valid ? ((pe(t3) || pe(r3)) && e2.dirty(), {status: e2.value, value: s2.data}) : (he(n2, {code: se.invalid_intersection_types}), de);
    };
    return n2.common.async ? Promise.all([this.C.left.W({data: n2.data, path: n2.path, parent: n2}), this.C.right.W({data: n2.data, path: n2.path, parent: n2})]).then(([t3, e3]) => r2(t3, e3)) : r2(this.C.left.B({data: n2.data, path: n2.path, parent: n2}), this.C.right.B({data: n2.data, path: n2.path, parent: n2}));
  }
}
ze.create = (t2, e2, n2) => new ze({left: t2, right: e2, typeName: pn.ZodIntersection, ...Ee(n2)});
class Ve extends Ne {
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2);
    if (n2.parsedType !== ne.array)
      return he(n2, {code: se.invalid_type, expected: ne.array, received: n2.parsedType}), de;
    if (n2.data.length < this.C.items.length)
      return he(n2, {code: se.too_small, minimum: this.C.items.length, inclusive: true, type: "array"}), de;
    !this.C.rest && n2.data.length > this.C.items.length && (he(n2, {code: se.too_big, maximum: this.C.items.length, inclusive: true, type: "array"}), e2.dirty());
    const r2 = n2.data.map((t3, e3) => {
      const r3 = this.C.items[e3] || this.C.rest;
      return r3 ? r3.H(new be(n2, t3, n2.path, e3)) : null;
    }).filter((t3) => !!t3);
    return n2.common.async ? Promise.all(r2).then((t3) => le.mergeArray(e2, t3)) : le.mergeArray(e2, r2);
  }
  get items() {
    return this.C.items;
  }
  rest(t2) {
    return new Ve({...this.C, rest: t2});
  }
}
Ve.create = (t2, e2) => new Ve({items: t2, typeName: pn.ZodTuple, rest: null, ...Ee(e2)});
class Ke extends Ne {
  get keySchema() {
    return this.C.keyType;
  }
  get valueSchema() {
    return this.C.valueType;
  }
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2);
    if (n2.parsedType !== ne.object)
      return he(n2, {code: se.invalid_type, expected: ne.object, received: n2.parsedType}), de;
    const r2 = [], s2 = this.C.keyType, i2 = this.C.valueType;
    for (const t3 in n2.data)
      r2.push({key: s2.H(new be(n2, t3, n2.path, t3)), value: i2.H(new be(n2, n2.data[t3], n2.path, t3))});
    return n2.common.async ? le.mergeObjectAsync(e2, r2) : le.mergeObjectSync(e2, r2);
  }
  get element() {
    return this.C.valueType;
  }
  static create(t2, e2, n2) {
    return new Ke(e2 instanceof Ne ? {keyType: t2, valueType: e2, typeName: pn.ZodRecord, ...Ee(n2)} : {keyType: Te.create(), valueType: t2, typeName: pn.ZodRecord, ...Ee(e2)});
  }
}
class Je extends Ne {
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2);
    if (n2.parsedType !== ne.map)
      return he(n2, {code: se.invalid_type, expected: ne.map, received: n2.parsedType}), de;
    const r2 = this.C.keyType, s2 = this.C.valueType, i2 = [...n2.data.entries()].map(([t3, e3], i3) => ({key: r2.H(new be(n2, t3, n2.path, [i3, "key"])), value: s2.H(new be(n2, e3, n2.path, [i3, "value"]))}));
    if (n2.common.async) {
      const t3 = new Map();
      return Promise.resolve().then(async () => {
        for (const n3 of i2) {
          const r3 = await n3.key, s3 = await n3.value;
          if (r3.status === "aborted" || s3.status === "aborted")
            return de;
          r3.status !== "dirty" && s3.status !== "dirty" || e2.dirty(), t3.set(r3.value, s3.value);
        }
        return {status: e2.value, value: t3};
      });
    }
    {
      const t3 = new Map();
      for (const n3 of i2) {
        const r3 = n3.key, s3 = n3.value;
        if (r3.status === "aborted" || s3.status === "aborted")
          return de;
        r3.status !== "dirty" && s3.status !== "dirty" || e2.dirty(), t3.set(r3.value, s3.value);
      }
      return {status: e2.value, value: t3};
    }
  }
}
Je.create = (t2, e2, n2) => new Je({valueType: e2, keyType: t2, typeName: pn.ZodMap, ...Ee(n2)});
class Ye extends Ne {
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2);
    if (n2.parsedType !== ne.set)
      return he(n2, {code: se.invalid_type, expected: ne.set, received: n2.parsedType}), de;
    const r2 = this.C;
    r2.minSize !== null && n2.data.size < r2.minSize.value && (he(n2, {code: se.too_small, minimum: r2.minSize.value, type: "set", inclusive: true, message: r2.minSize.message}), e2.dirty()), r2.maxSize !== null && n2.data.size > r2.maxSize.value && (he(n2, {code: se.too_big, maximum: r2.maxSize.value, type: "set", inclusive: true, message: r2.maxSize.message}), e2.dirty());
    const s2 = this.C.valueType;
    function i2(t3) {
      const n3 = new Set();
      for (const r3 of t3) {
        if (r3.status === "aborted")
          return de;
        r3.status === "dirty" && e2.dirty(), n3.add(r3.value);
      }
      return {status: e2.value, value: n3};
    }
    const a2 = [...n2.data.values()].map((t3, e3) => s2.H(new be(n2, t3, n2.path, e3)));
    return n2.common.async ? Promise.all(a2).then((t3) => i2(t3)) : i2(a2);
  }
  min(t2, e2) {
    return new Ye({...this.C, minSize: {value: t2, message: ve.toString(e2)}});
  }
  max(t2, e2) {
    return new Ye({...this.C, maxSize: {value: t2, message: ve.toString(e2)}});
  }
  size(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  nonempty(t2) {
    return this.min(1, t2);
  }
}
Ye.create = (t2, e2) => new Ye({valueType: t2, minSize: null, maxSize: null, typeName: pn.ZodSet, ...Ee(e2)});
class Qe extends Ne {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  H(t2) {
    const {ctx: e2} = this.R(t2);
    if (e2.parsedType !== ne.function)
      return he(e2, {code: se.invalid_type, expected: ne.function, received: e2.parsedType}), de;
    function n2(t3, n3) {
      return ce({data: t3, path: e2.path, errorMaps: [e2.common.contextualErrorMap, e2.schemaErrorMap, ue(), ae].filter((t4) => !!t4), issueData: {code: se.invalid_arguments, argumentsError: n3}});
    }
    function r2(t3, n3) {
      return ce({data: t3, path: e2.path, errorMaps: [e2.common.contextualErrorMap, e2.schemaErrorMap, ue(), ae].filter((t4) => !!t4), issueData: {code: se.invalid_return_type, returnTypeError: n3}});
    }
    const s2 = {errorMap: e2.common.contextualErrorMap}, i2 = e2.data;
    return fe(this.C.returns instanceof sn ? async (...t3) => {
      const e3 = new ie([]), a2 = await this.C.args.parseAsync(t3, s2).catch((r3) => {
        throw e3.addIssue(n2(t3, r3)), e3;
      }), o2 = await i2(...a2);
      return await this.C.returns.C.type.parseAsync(o2, s2).catch((t4) => {
        throw e3.addIssue(r2(o2, t4)), e3;
      });
    } : (...t3) => {
      const e3 = this.C.args.safeParse(t3, s2);
      if (!e3.success)
        throw new ie([n2(t3, e3.error)]);
      const a2 = i2(...e3.data), o2 = this.C.returns.safeParse(a2, s2);
      if (!o2.success)
        throw new ie([r2(a2, o2.error)]);
      return o2.data;
    });
  }
  parameters() {
    return this.C.args;
  }
  returnType() {
    return this.C.returns;
  }
  args(...t2) {
    return new Qe({...this.C, args: Ve.create(t2).rest(Ue.create())});
  }
  returns(t2) {
    return new Qe({...this.C, returns: t2});
  }
  implement(t2) {
    return this.parse(t2);
  }
  strictImplement(t2) {
    return this.parse(t2);
  }
}
Qe.create = (t2, e2, n2) => new Qe({args: t2 ? t2.rest(Ue.create()) : Ve.create([]).rest(Ue.create()), returns: e2 || Ue.create(), typeName: pn.ZodFunction, ...Ee(n2)});
class Xe extends Ne {
  get schema() {
    return this.C.getter();
  }
  H(t2) {
    const {ctx: e2} = this.R(t2);
    return this.C.getter().H({data: e2.data, path: e2.path, parent: e2});
  }
}
Xe.create = (t2, e2) => new Xe({getter: t2, typeName: pn.ZodLazy, ...Ee(e2)});
class tn extends Ne {
  H(t2) {
    return t2.data !== this.C.value ? (he(this.j(t2), {code: se.invalid_literal, expected: this.C.value}), de) : {status: "valid", value: t2.data};
  }
  get value() {
    return this.C.value;
  }
}
function en(t2, e2) {
  return new nn({values: t2, typeName: pn.ZodEnum, ...Ee(e2)});
}
tn.create = (t2, e2) => new tn({value: t2, typeName: pn.ZodLiteral, ...Ee(e2)});
class nn extends Ne {
  H(t2) {
    if (typeof t2.data != "string") {
      const e2 = this.j(t2);
      return he(e2, {expected: Xt.joinValues(this.C.values), received: e2.parsedType, code: se.invalid_type}), de;
    }
    if (this.C.values.indexOf(t2.data) === -1) {
      const e2 = this.j(t2);
      return he(e2, {received: e2.data, code: se.invalid_enum_value, options: this.C.values}), de;
    }
    return fe(t2.data);
  }
  get options() {
    return this.C.values;
  }
  get enum() {
    const t2 = {};
    for (const e2 of this.C.values)
      t2[e2] = e2;
    return t2;
  }
  get Values() {
    const t2 = {};
    for (const e2 of this.C.values)
      t2[e2] = e2;
    return t2;
  }
  get Enum() {
    const t2 = {};
    for (const e2 of this.C.values)
      t2[e2] = e2;
    return t2;
  }
}
nn.create = en;
class rn extends Ne {
  H(t2) {
    const e2 = Xt.getValidEnumValues(this.C.values), n2 = this.j(t2);
    if (n2.parsedType !== ne.string && n2.parsedType !== ne.number) {
      const t3 = Xt.objectValues(e2);
      return he(n2, {expected: Xt.joinValues(t3), received: n2.parsedType, code: se.invalid_type}), de;
    }
    if (e2.indexOf(t2.data) === -1) {
      const t3 = Xt.objectValues(e2);
      return he(n2, {received: n2.data, code: se.invalid_enum_value, options: t3}), de;
    }
    return fe(t2.data);
  }
  get enum() {
    return this.C.values;
  }
}
rn.create = (t2, e2) => new rn({values: t2, typeName: pn.ZodNativeEnum, ...Ee(e2)});
class sn extends Ne {
  H(t2) {
    const {ctx: e2} = this.R(t2);
    if (e2.parsedType !== ne.promise && e2.common.async === false)
      return he(e2, {code: se.invalid_type, expected: ne.promise, received: e2.parsedType}), de;
    const n2 = e2.parsedType === ne.promise ? e2.data : Promise.resolve(e2.data);
    return fe(n2.then((t3) => this.C.type.parseAsync(t3, {path: e2.path, errorMap: e2.common.contextualErrorMap})));
  }
}
sn.create = (t2, e2) => new sn({type: t2, typeName: pn.ZodPromise, ...Ee(e2)});
class an extends Ne {
  innerType() {
    return this.C.schema;
  }
  H(t2) {
    const {status: e2, ctx: n2} = this.R(t2), r2 = this.C.effect || null;
    if (r2.type === "preprocess") {
      const t3 = r2.transform(n2.data);
      return n2.common.async ? Promise.resolve(t3).then((t4) => this.C.schema.W({data: t4, path: n2.path, parent: n2})) : this.C.schema.B({data: t3, path: n2.path, parent: n2});
    }
    const s2 = {addIssue: (t3) => {
      he(n2, t3), t3.fatal ? e2.abort() : e2.dirty();
    }, get path() {
      return n2.path;
    }};
    if (s2.addIssue = s2.addIssue.bind(s2), r2.type === "refinement") {
      const t3 = (t4) => {
        const e3 = r2.refinement(t4, s2);
        if (n2.common.async)
          return Promise.resolve(e3);
        if (e3 instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return t4;
      };
      if (n2.common.async === false) {
        const r3 = this.C.schema.B({data: n2.data, path: n2.path, parent: n2});
        return r3.status === "aborted" ? de : (r3.status === "dirty" && e2.dirty(), t3(r3.value), {status: e2.value, value: r3.value});
      }
      return this.C.schema.W({data: n2.data, path: n2.path, parent: n2}).then((n3) => n3.status === "aborted" ? de : (n3.status === "dirty" && e2.dirty(), t3(n3.value).then(() => ({status: e2.value, value: n3.value}))));
    }
    if (r2.type === "transform") {
      if (n2.common.async === false) {
        const t3 = this.C.schema.B({data: n2.data, path: n2.path, parent: n2});
        if (!ye(t3))
          return t3;
        const i2 = r2.transform(t3.value, s2);
        if (i2 instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return {status: e2.value, value: i2};
      }
      return this.C.schema.W({data: n2.data, path: n2.path, parent: n2}).then((t3) => ye(t3) ? Promise.resolve(r2.transform(t3.value, s2)).then((t4) => ({status: e2.value, value: t4})) : t3);
    }
    Xt.assertNever(r2);
  }
}
an.create = (t2, e2, n2) => new an({schema: t2, typeName: pn.ZodEffects, effect: e2, ...Ee(n2)}), an.createWithPreprocess = (t2, e2, n2) => new an({schema: e2, effect: {type: "preprocess", transform: t2}, typeName: pn.ZodEffects, ...Ee(n2)});
class on extends Ne {
  H(t2) {
    return this.P(t2) === ne.undefined ? fe(void 0) : this.C.innerType.H(t2);
  }
  unwrap() {
    return this.C.innerType;
  }
}
on.create = (t2, e2) => new on({innerType: t2, typeName: pn.ZodOptional, ...Ee(e2)});
class un extends Ne {
  H(t2) {
    return this.P(t2) === ne.null ? fe(null) : this.C.innerType.H(t2);
  }
  unwrap() {
    return this.C.innerType;
  }
}
un.create = (t2, e2) => new un({innerType: t2, typeName: pn.ZodNullable, ...Ee(e2)});
class cn extends Ne {
  H(t2) {
    const {ctx: e2} = this.R(t2);
    let n2 = e2.data;
    return e2.parsedType === ne.undefined && (n2 = this.C.defaultValue()), this.C.innerType.H({data: n2, path: e2.path, parent: e2});
  }
  removeDefault() {
    return this.C.innerType;
  }
}
cn.create = (t2, e2) => new on({innerType: t2, typeName: pn.ZodOptional, ...Ee(e2)});
class hn extends Ne {
  H(t2) {
    if (this.P(t2) !== ne.nan) {
      const e2 = this.j(t2);
      return he(e2, {code: se.invalid_type, expected: ne.nan, received: e2.parsedType}), de;
    }
    return {status: "valid", value: t2.data};
  }
}
hn.create = (t2) => new hn({typeName: pn.ZodNaN, ...Ee(t2)});
const ln = Symbol("zod_brand");
class dn extends Ne {
  H(t2) {
    const {ctx: e2} = this.R(t2);
    return this.C.type.H({data: e2.data, path: e2.path, parent: e2});
  }
  unwrap() {
    return this.C.type;
  }
}
const fn = (t2, e2 = {}, n2) => t2 ? Le.create().superRefine((r2, s2) => {
  if (!t2(r2)) {
    const t3 = typeof e2 == "function" ? e2(r2) : e2;
    s2.addIssue({code: "custom", ...typeof t3 == "string" ? {message: t3} : t3, fatal: n2});
  }
}) : Le.create(), mn = {object: He.lazycreate};
var pn;
!function(t2) {
  t2.ZodString = "ZodString", t2.ZodNumber = "ZodNumber", t2.ZodNaN = "ZodNaN", t2.ZodBigInt = "ZodBigInt", t2.ZodBoolean = "ZodBoolean", t2.ZodDate = "ZodDate", t2.ZodUndefined = "ZodUndefined", t2.ZodNull = "ZodNull", t2.ZodAny = "ZodAny", t2.ZodUnknown = "ZodUnknown", t2.ZodNever = "ZodNever", t2.ZodVoid = "ZodVoid", t2.ZodArray = "ZodArray", t2.ZodObject = "ZodObject", t2.ZodUnion = "ZodUnion", t2.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t2.ZodIntersection = "ZodIntersection", t2.ZodTuple = "ZodTuple", t2.ZodRecord = "ZodRecord", t2.ZodMap = "ZodMap", t2.ZodSet = "ZodSet", t2.ZodFunction = "ZodFunction", t2.ZodLazy = "ZodLazy", t2.ZodLiteral = "ZodLiteral", t2.ZodEnum = "ZodEnum", t2.ZodEffects = "ZodEffects", t2.ZodNativeEnum = "ZodNativeEnum", t2.ZodOptional = "ZodOptional", t2.ZodNullable = "ZodNullable", t2.ZodDefault = "ZodDefault", t2.ZodPromise = "ZodPromise", t2.ZodBranded = "ZodBranded";
}(pn || (pn = {}));
const yn = Te.create, wn = Ie.create, gn = Ae.create, vn = an.create;
var bn = /* @__PURE__ */ Object.freeze({__proto__: null, getParsedType: re, ZodParsedType: ne, makeIssue: ce, EMPTY_PATH: [], addIssueToContext: he, ParseStatus: le, INVALID: de, DIRTY: (t2) => ({status: "dirty", value: t2}), OK: fe, isAborted: me, isDirty: pe, isValid: ye, isAsync: we, jsonStringifyReplacer: ge, ZodType: Ne, ZodString: Te, ZodNumber: Ie, ZodBigInt: Ze, ZodBoolean: Ae, ZodDate: De, ZodUndefined: $e, ZodNull: Oe, ZodAny: Le, ZodUnknown: Ue, ZodNever: Ce, ZodVoid: Pe, ZodArray: je, get objectUtil() {
  return Fe;
}, ZodObject: He, ZodUnion: Ge, ZodDiscriminatedUnion: We, ZodIntersection: ze, ZodTuple: Ve, ZodRecord: Ke, ZodMap: Je, ZodSet: Ye, ZodFunction: Qe, ZodLazy: Xe, ZodLiteral: tn, ZodEnum: nn, ZodNativeEnum: rn, ZodPromise: sn, ZodEffects: an, ZodTransformer: an, ZodOptional: on, ZodNullable: un, ZodDefault: cn, ZodNaN: hn, BRAND: ln, ZodBranded: dn, custom: fn, Schema: Ne, ZodSchema: Ne, late: mn, get ZodFirstPartyTypeKind() {
  return pn;
}, any: Le.create, array: je.create, bigint: Ze.create, boolean: gn, date: De.create, discriminatedUnion: We.create, effect: vn, enum: nn.create, function: Qe.create, instanceof: (t2, e2 = {message: `Input not instance of ${t2.name}`}) => fn((e3) => e3 instanceof t2, e2, true), intersection: ze.create, lazy: Xe.create, literal: tn.create, map: Je.create, nan: hn.create, nativeEnum: rn.create, never: Ce.create, null: Oe.create, nullable: un.create, number: wn, object: He.create, oboolean: () => gn().optional(), onumber: () => wn().optional(), optional: on.create, ostring: () => yn().optional(), preprocess: an.createWithPreprocess, promise: sn.create, record: Ke.create, set: Ye.create, strictObject: He.strictCreate, string: yn, transformer: vn, tuple: Ve.create, undefined: $e.create, union: Ge.create, unknown: Ue.create, void: Pe.create, ZodIssueCode: se, quotelessJson: (t2) => JSON.stringify(t2, null, 2).replace(/"([^"]+)":/g, "$1:"), ZodError: ie, defaultErrorMap: ae, setErrorMap: function(t2) {
  oe = t2;
}, getErrorMap: ue});
class xn extends Error {
}
class En extends xn {
  constructor(t2) {
    super(`Invalid DateTime: ${t2.toMessage()}`);
  }
}
class Nn extends xn {
  constructor(t2) {
    super(`Invalid Interval: ${t2.toMessage()}`);
  }
}
class Sn extends xn {
  constructor(t2) {
    super(`Invalid Duration: ${t2.toMessage()}`);
  }
}
class Mn extends xn {
}
class kn extends xn {
  constructor(t2) {
    super(`Invalid unit ${t2}`);
  }
}
class Tn extends xn {
}
class _n extends xn {
  constructor() {
    super("Zone is an abstract class");
  }
}
const In = "numeric", Zn = "short", An = "long", Dn = {year: In, month: In, day: In}, $n = {year: In, month: Zn, day: In}, On = {year: In, month: Zn, day: In, weekday: Zn}, Ln = {year: In, month: An, day: In}, Un = {year: In, month: An, day: In, weekday: An}, Cn = {hour: In, minute: In}, Pn = {hour: In, minute: In, second: In}, jn = {hour: In, minute: In, second: In, timeZoneName: Zn}, Fn = {hour: In, minute: In, second: In, timeZoneName: An}, Rn = {hour: In, minute: In, hourCycle: "h23"}, Bn = {hour: In, minute: In, second: In, hourCycle: "h23"}, Hn = {hour: In, minute: In, second: In, hourCycle: "h23", timeZoneName: Zn}, Gn = {hour: In, minute: In, second: In, hourCycle: "h23", timeZoneName: An}, Wn = {year: In, month: In, day: In, hour: In, minute: In}, qn = {year: In, month: In, day: In, hour: In, minute: In, second: In}, zn = {year: In, month: Zn, day: In, hour: In, minute: In}, Vn = {year: In, month: Zn, day: In, hour: In, minute: In, second: In}, Kn = {year: In, month: Zn, day: In, weekday: Zn, hour: In, minute: In}, Jn = {year: In, month: An, day: In, hour: In, minute: In, timeZoneName: Zn}, Yn = {year: In, month: An, day: In, hour: In, minute: In, second: In, timeZoneName: Zn}, Qn = {year: In, month: An, day: In, weekday: An, hour: In, minute: In, timeZoneName: An}, Xn = {year: In, month: An, day: In, weekday: An, hour: In, minute: In, second: In, timeZoneName: An};
function tr(t2) {
  return t2 === void 0;
}
function er(t2) {
  return typeof t2 == "number";
}
function nr(t2) {
  return typeof t2 == "number" && t2 % 1 == 0;
}
function rr() {
  try {
    return typeof Intl != "undefined" && !!Intl.RelativeTimeFormat;
  } catch (t2) {
    return false;
  }
}
function sr(t2, e2, n2) {
  if (t2.length !== 0)
    return t2.reduce((t3, r2) => {
      const s2 = [e2(r2), r2];
      return t3 && n2(t3[0], s2[0]) === t3[0] ? t3 : s2;
    }, null)[1];
}
function ir(t2, e2) {
  return Object.prototype.hasOwnProperty.call(t2, e2);
}
function ar(t2, e2, n2) {
  return nr(t2) && t2 >= e2 && t2 <= n2;
}
function or(t2, e2 = 2) {
  let n2;
  return n2 = t2 < 0 ? "-" + ("" + -t2).padStart(e2, "0") : ("" + t2).padStart(e2, "0"), n2;
}
function ur(t2) {
  return tr(t2) || t2 === null || t2 === "" ? void 0 : parseInt(t2, 10);
}
function cr(t2) {
  return tr(t2) || t2 === null || t2 === "" ? void 0 : parseFloat(t2);
}
function hr(t2) {
  if (!tr(t2) && t2 !== null && t2 !== "") {
    const e2 = 1e3 * parseFloat("0." + t2);
    return Math.floor(e2);
  }
}
function lr(t2, e2, n2 = false) {
  const r2 = 10 ** e2;
  return (n2 ? Math.trunc : Math.round)(t2 * r2) / r2;
}
function dr(t2) {
  return t2 % 4 == 0 && (t2 % 100 != 0 || t2 % 400 == 0);
}
function fr(t2) {
  return dr(t2) ? 366 : 365;
}
function mr(t2, e2) {
  const n2 = (r2 = e2 - 1) - 12 * Math.floor(r2 / 12) + 1;
  var r2;
  return n2 === 2 ? dr(t2 + (e2 - n2) / 12) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n2 - 1];
}
function pr(t2) {
  let e2 = Date.UTC(t2.year, t2.month - 1, t2.day, t2.hour, t2.minute, t2.second, t2.millisecond);
  return t2.year < 100 && t2.year >= 0 && (e2 = new Date(e2), e2.setUTCFullYear(e2.getUTCFullYear() - 1900)), +e2;
}
function yr(t2) {
  const e2 = (t2 + Math.floor(t2 / 4) - Math.floor(t2 / 100) + Math.floor(t2 / 400)) % 7, n2 = t2 - 1, r2 = (n2 + Math.floor(n2 / 4) - Math.floor(n2 / 100) + Math.floor(n2 / 400)) % 7;
  return e2 === 4 || r2 === 3 ? 53 : 52;
}
function wr(t2) {
  return t2 > 99 ? t2 : t2 > 60 ? 1900 + t2 : 2e3 + t2;
}
function gr(t2, e2, n2, r2 = null) {
  const s2 = new Date(t2), i2 = {hourCycle: "h23", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit"};
  r2 && (i2.timeZone = r2);
  const a2 = {timeZoneName: e2, ...i2}, o2 = new Intl.DateTimeFormat(n2, a2).formatToParts(s2).find((t3) => t3.type.toLowerCase() === "timezonename");
  return o2 ? o2.value : null;
}
function vr(t2, e2) {
  let n2 = parseInt(t2, 10);
  Number.isNaN(n2) && (n2 = 0);
  const r2 = parseInt(e2, 10) || 0;
  return 60 * n2 + (n2 < 0 || Object.is(n2, -0) ? -r2 : r2);
}
function br(t2) {
  const e2 = Number(t2);
  if (typeof t2 == "boolean" || t2 === "" || Number.isNaN(e2))
    throw new Tn(`Invalid unit value ${t2}`);
  return e2;
}
function xr(t2, e2) {
  const n2 = {};
  for (const r2 in t2)
    if (ir(t2, r2)) {
      const s2 = t2[r2];
      if (s2 == null)
        continue;
      n2[e2(r2)] = br(s2);
    }
  return n2;
}
function Er(t2, e2) {
  const n2 = Math.trunc(Math.abs(t2 / 60)), r2 = Math.trunc(Math.abs(t2 % 60)), s2 = t2 >= 0 ? "+" : "-";
  switch (e2) {
    case "short":
      return `${s2}${or(n2, 2)}:${or(r2, 2)}`;
    case "narrow":
      return `${s2}${n2}${r2 > 0 ? `:${r2}` : ""}`;
    case "techie":
      return `${s2}${or(n2, 2)}${or(r2, 2)}`;
    default:
      throw new RangeError(`Value format ${e2} is out of range for property format`);
  }
}
function Nr(t2) {
  return function(t3, e2) {
    return ["hour", "minute", "second", "millisecond"].reduce((e3, n2) => (e3[n2] = t3[n2], e3), {});
  }(t2);
}
const Sr = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/, Mr = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], kr = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], Tr = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function _r(t2) {
  switch (t2) {
    case "narrow":
      return [...Tr];
    case "short":
      return [...kr];
    case "long":
      return [...Mr];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const Ir = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], Zr = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], Ar = ["M", "T", "W", "T", "F", "S", "S"];
function Dr(t2) {
  switch (t2) {
    case "narrow":
      return [...Ar];
    case "short":
      return [...Zr];
    case "long":
      return [...Ir];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const $r = ["AM", "PM"], Or = ["Before Christ", "Anno Domini"], Lr = ["BC", "AD"], Ur = ["B", "A"];
function Cr(t2) {
  switch (t2) {
    case "narrow":
      return [...Ur];
    case "short":
      return [...Lr];
    case "long":
      return [...Or];
    default:
      return null;
  }
}
function Pr(t2, e2) {
  let n2 = "";
  for (const r2 of t2)
    n2 += r2.literal ? r2.val : e2(r2.val);
  return n2;
}
const jr = {D: Dn, DD: $n, DDD: Ln, DDDD: Un, t: Cn, tt: Pn, ttt: jn, tttt: Fn, T: Rn, TT: Bn, TTT: Hn, TTTT: Gn, f: Wn, ff: zn, fff: Jn, ffff: Qn, F: qn, FF: Vn, FFF: Yn, FFFF: Xn};
class Fr {
  static create(t2, e2 = {}) {
    return new Fr(t2, e2);
  }
  static parseFormat(t2) {
    let e2 = null, n2 = "", r2 = false;
    const s2 = [];
    for (let i2 = 0; i2 < t2.length; i2++) {
      const a2 = t2.charAt(i2);
      a2 === "'" ? (n2.length > 0 && s2.push({literal: r2, val: n2}), e2 = null, n2 = "", r2 = !r2) : r2 || a2 === e2 ? n2 += a2 : (n2.length > 0 && s2.push({literal: false, val: n2}), n2 = a2, e2 = a2);
    }
    return n2.length > 0 && s2.push({literal: r2, val: n2}), s2;
  }
  static macroTokenToFormatOpts(t2) {
    return jr[t2];
  }
  constructor(t2, e2) {
    this.opts = e2, this.loc = t2, this.systemLoc = null;
  }
  formatWithSystemDefault(t2, e2) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(t2, {...this.opts, ...e2}).format();
  }
  formatDateTime(t2, e2 = {}) {
    return this.loc.dtFormatter(t2, {...this.opts, ...e2}).format();
  }
  formatDateTimeParts(t2, e2 = {}) {
    return this.loc.dtFormatter(t2, {...this.opts, ...e2}).formatToParts();
  }
  resolvedOptions(t2, e2 = {}) {
    return this.loc.dtFormatter(t2, {...this.opts, ...e2}).resolvedOptions();
  }
  num(t2, e2 = 0) {
    if (this.opts.forceSimple)
      return or(t2, e2);
    const n2 = {...this.opts};
    return e2 > 0 && (n2.padTo = e2), this.loc.numberFormatter(n2).format(t2);
  }
  formatDateTimeFromString(t2, e2) {
    const n2 = this.loc.listingMode() === "en", r2 = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", s2 = (e3, n3) => this.loc.extract(t2, e3, n3), i2 = (e3) => t2.isOffsetFixed && t2.offset === 0 && e3.allowZ ? "Z" : t2.isValid ? t2.zone.formatOffset(t2.ts, e3.format) : "", a2 = (e3, r3) => n2 ? function(t3, e4) {
      return _r(e4)[t3.month - 1];
    }(t2, e3) : s2(r3 ? {month: e3} : {month: e3, day: "numeric"}, "month"), o2 = (e3, r3) => n2 ? function(t3, e4) {
      return Dr(e4)[t3.weekday - 1];
    }(t2, e3) : s2(r3 ? {weekday: e3} : {weekday: e3, month: "long", day: "numeric"}, "weekday"), u2 = (e3) => {
      const n3 = Fr.macroTokenToFormatOpts(e3);
      return n3 ? this.formatWithSystemDefault(t2, n3) : e3;
    }, c2 = (e3) => n2 ? function(t3, e4) {
      return Cr(e4)[t3.year < 0 ? 0 : 1];
    }(t2, e3) : s2({era: e3}, "era");
    return Pr(Fr.parseFormat(e2), (e3) => {
      switch (e3) {
        case "S":
          return this.num(t2.millisecond);
        case "u":
        case "SSS":
          return this.num(t2.millisecond, 3);
        case "s":
          return this.num(t2.second);
        case "ss":
          return this.num(t2.second, 2);
        case "uu":
          return this.num(Math.floor(t2.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(t2.millisecond / 100));
        case "m":
          return this.num(t2.minute);
        case "mm":
          return this.num(t2.minute, 2);
        case "h":
          return this.num(t2.hour % 12 == 0 ? 12 : t2.hour % 12);
        case "hh":
          return this.num(t2.hour % 12 == 0 ? 12 : t2.hour % 12, 2);
        case "H":
          return this.num(t2.hour);
        case "HH":
          return this.num(t2.hour, 2);
        case "Z":
          return i2({format: "narrow", allowZ: this.opts.allowZ});
        case "ZZ":
          return i2({format: "short", allowZ: this.opts.allowZ});
        case "ZZZ":
          return i2({format: "techie", allowZ: this.opts.allowZ});
        case "ZZZZ":
          return t2.zone.offsetName(t2.ts, {format: "short", locale: this.loc.locale});
        case "ZZZZZ":
          return t2.zone.offsetName(t2.ts, {format: "long", locale: this.loc.locale});
        case "z":
          return t2.zoneName;
        case "a":
          return n2 ? function(t3) {
            return $r[t3.hour < 12 ? 0 : 1];
          }(t2) : s2({hour: "numeric", hourCycle: "h12"}, "dayperiod");
        case "d":
          return r2 ? s2({day: "numeric"}, "day") : this.num(t2.day);
        case "dd":
          return r2 ? s2({day: "2-digit"}, "day") : this.num(t2.day, 2);
        case "c":
          return this.num(t2.weekday);
        case "ccc":
          return o2("short", true);
        case "cccc":
          return o2("long", true);
        case "ccccc":
          return o2("narrow", true);
        case "E":
          return this.num(t2.weekday);
        case "EEE":
          return o2("short", false);
        case "EEEE":
          return o2("long", false);
        case "EEEEE":
          return o2("narrow", false);
        case "L":
          return r2 ? s2({month: "numeric", day: "numeric"}, "month") : this.num(t2.month);
        case "LL":
          return r2 ? s2({month: "2-digit", day: "numeric"}, "month") : this.num(t2.month, 2);
        case "LLL":
          return a2("short", true);
        case "LLLL":
          return a2("long", true);
        case "LLLLL":
          return a2("narrow", true);
        case "M":
          return r2 ? s2({month: "numeric"}, "month") : this.num(t2.month);
        case "MM":
          return r2 ? s2({month: "2-digit"}, "month") : this.num(t2.month, 2);
        case "MMM":
          return a2("short", false);
        case "MMMM":
          return a2("long", false);
        case "MMMMM":
          return a2("narrow", false);
        case "y":
          return r2 ? s2({year: "numeric"}, "year") : this.num(t2.year);
        case "yy":
          return r2 ? s2({year: "2-digit"}, "year") : this.num(t2.year.toString().slice(-2), 2);
        case "yyyy":
          return r2 ? s2({year: "numeric"}, "year") : this.num(t2.year, 4);
        case "yyyyyy":
          return r2 ? s2({year: "numeric"}, "year") : this.num(t2.year, 6);
        case "G":
          return c2("short");
        case "GG":
          return c2("long");
        case "GGGGG":
          return c2("narrow");
        case "kk":
          return this.num(t2.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(t2.weekYear, 4);
        case "W":
          return this.num(t2.weekNumber);
        case "WW":
          return this.num(t2.weekNumber, 2);
        case "o":
          return this.num(t2.ordinal);
        case "ooo":
          return this.num(t2.ordinal, 3);
        case "q":
          return this.num(t2.quarter);
        case "qq":
          return this.num(t2.quarter, 2);
        case "X":
          return this.num(Math.floor(t2.ts / 1e3));
        case "x":
          return this.num(t2.ts);
        default:
          return u2(e3);
      }
    });
  }
  formatDurationFromString(t2, e2) {
    const n2 = (t3) => {
      switch (t3[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, r2 = Fr.parseFormat(e2), s2 = r2.reduce((t3, {literal: e3, val: n3}) => e3 ? t3 : t3.concat(n3), []);
    return Pr(r2, ((t3) => (e3) => {
      const r3 = n2(e3);
      return r3 ? this.num(t3.get(r3), e3.length) : e3;
    })(t2.shiftTo(...s2.map(n2).filter((t3) => t3))));
  }
}
class Rr {
  constructor(t2, e2) {
    this.reason = t2, this.explanation = e2;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
class Br {
  get type() {
    throw new _n();
  }
  get name() {
    throw new _n();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new _n();
  }
  offsetName(t2, e2) {
    throw new _n();
  }
  formatOffset(t2, e2) {
    throw new _n();
  }
  offset(t2) {
    throw new _n();
  }
  equals(t2) {
    throw new _n();
  }
  get isValid() {
    throw new _n();
  }
}
let Hr = null;
class Gr extends Br {
  static get instance() {
    return Hr === null && (Hr = new Gr()), Hr;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return false;
  }
  offsetName(t2, {format: e2, locale: n2}) {
    return gr(t2, e2, n2);
  }
  formatOffset(t2, e2) {
    return Er(this.offset(t2), e2);
  }
  offset(t2) {
    return -new Date(t2).getTimezoneOffset();
  }
  equals(t2) {
    return t2.type === "system";
  }
  get isValid() {
    return true;
  }
}
let Wr = {};
const qr = {year: 0, month: 1, day: 2, era: 3, hour: 4, minute: 5, second: 6};
let zr = {};
class Vr extends Br {
  static create(t2) {
    return zr[t2] || (zr[t2] = new Vr(t2)), zr[t2];
  }
  static resetCache() {
    zr = {}, Wr = {};
  }
  static isValidSpecifier(t2) {
    return this.isValidZone(t2);
  }
  static isValidZone(t2) {
    if (!t2)
      return false;
    try {
      return new Intl.DateTimeFormat("en-US", {timeZone: t2}).format(), true;
    } catch (t3) {
      return false;
    }
  }
  constructor(t2) {
    super(), this.zoneName = t2, this.valid = Vr.isValidZone(t2);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName(t2, {format: e2, locale: n2}) {
    return gr(t2, e2, n2, this.name);
  }
  formatOffset(t2, e2) {
    return Er(this.offset(t2), e2);
  }
  offset(t2) {
    const e2 = new Date(t2);
    if (isNaN(e2))
      return NaN;
    const n2 = (Wr[r2 = this.name] || (Wr[r2] = new Intl.DateTimeFormat("en-US", {hour12: false, timeZone: r2, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", era: "short"})), Wr[r2]);
    var r2;
    let [s2, i2, a2, o2, u2, c2, h2] = n2.formatToParts ? function(t3, e3) {
      const n3 = t3.formatToParts(e3), r3 = [];
      for (let t4 = 0; t4 < n3.length; t4++) {
        const {type: e4, value: s3} = n3[t4], i3 = qr[e4];
        e4 === "era" ? r3[i3] = s3 : tr(i3) || (r3[i3] = parseInt(s3, 10));
      }
      return r3;
    }(n2, e2) : function(t3, e3) {
      const n3 = t3.format(e3).replace(/\u200E/g, ""), r3 = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n3), [, s3, i3, a3, o3, u3, c3, h3] = r3;
      return [a3, s3, i3, o3, u3, c3, h3];
    }(n2, e2);
    o2 === "BC" && (s2 = 1 - Math.abs(s2));
    let l2 = +e2;
    const d2 = l2 % 1e3;
    return l2 -= d2 >= 0 ? d2 : 1e3 + d2, (pr({year: s2, month: i2, day: a2, hour: u2 === 24 ? 0 : u2, minute: c2, second: h2, millisecond: 0}) - l2) / 6e4;
  }
  equals(t2) {
    return t2.type === "iana" && t2.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
}
let Kr = null;
class Jr extends Br {
  static get utcInstance() {
    return Kr === null && (Kr = new Jr(0)), Kr;
  }
  static instance(t2) {
    return t2 === 0 ? Jr.utcInstance : new Jr(t2);
  }
  static parseSpecifier(t2) {
    if (t2) {
      const e2 = t2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (e2)
        return new Jr(vr(e2[1], e2[2]));
    }
    return null;
  }
  constructor(t2) {
    super(), this.fixed = t2;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${Er(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${Er(-this.fixed, "narrow")}`;
  }
  offsetName() {
    return this.name;
  }
  formatOffset(t2, e2) {
    return Er(this.fixed, e2);
  }
  get isUniversal() {
    return true;
  }
  offset() {
    return this.fixed;
  }
  equals(t2) {
    return t2.type === "fixed" && t2.fixed === this.fixed;
  }
  get isValid() {
    return true;
  }
}
class Yr extends Br {
  constructor(t2) {
    super(), this.zoneName = t2;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return false;
  }
  get isValid() {
    return false;
  }
}
function Qr(t2, e2) {
  if (tr(t2) || t2 === null)
    return e2;
  if (t2 instanceof Br)
    return t2;
  if (typeof t2 == "string") {
    const n2 = t2.toLowerCase();
    return n2 === "default" ? e2 : n2 === "local" || n2 === "system" ? Gr.instance : n2 === "utc" || n2 === "gmt" ? Jr.utcInstance : Jr.parseSpecifier(n2) || Vr.create(t2);
  }
  return er(t2) ? Jr.instance(t2) : typeof t2 == "object" && t2.offset && typeof t2.offset == "number" ? t2 : new Yr(t2);
}
let Xr, ts = () => Date.now(), es = "system", ns = null, rs = null, ss = null;
class is {
  static get now() {
    return ts;
  }
  static set now(t2) {
    ts = t2;
  }
  static set defaultZone(t2) {
    es = t2;
  }
  static get defaultZone() {
    return Qr(es, Gr.instance);
  }
  static get defaultLocale() {
    return ns;
  }
  static set defaultLocale(t2) {
    ns = t2;
  }
  static get defaultNumberingSystem() {
    return rs;
  }
  static set defaultNumberingSystem(t2) {
    rs = t2;
  }
  static get defaultOutputCalendar() {
    return ss;
  }
  static set defaultOutputCalendar(t2) {
    ss = t2;
  }
  static get throwOnInvalid() {
    return Xr;
  }
  static set throwOnInvalid(t2) {
    Xr = t2;
  }
  static resetCaches() {
    ys.resetCache(), Vr.resetCache();
  }
}
let as = {}, os = {};
function us(t2, e2 = {}) {
  const n2 = JSON.stringify([t2, e2]);
  let r2 = os[n2];
  return r2 || (r2 = new Intl.DateTimeFormat(t2, e2), os[n2] = r2), r2;
}
let cs = {}, hs = {}, ls = null;
function ds(t2, e2, n2, r2, s2) {
  const i2 = t2.listingMode(n2);
  return i2 === "error" ? null : i2 === "en" ? r2(e2) : s2(e2);
}
class fs {
  constructor(t2, e2, n2) {
    this.padTo = n2.padTo || 0, this.floor = n2.floor || false;
    const {padTo: r2, floor: s2, ...i2} = n2;
    if (!e2 || Object.keys(i2).length > 0) {
      const e3 = {useGrouping: false, ...n2};
      n2.padTo > 0 && (e3.minimumIntegerDigits = n2.padTo), this.inf = function(t3, e4 = {}) {
        const n3 = JSON.stringify([t3, e4]);
        let r3 = cs[n3];
        return r3 || (r3 = new Intl.NumberFormat(t3, e4), cs[n3] = r3), r3;
      }(t2, e3);
    }
  }
  format(t2) {
    if (this.inf) {
      const e2 = this.floor ? Math.floor(t2) : t2;
      return this.inf.format(e2);
    }
    return or(this.floor ? Math.floor(t2) : lr(t2, 3), this.padTo);
  }
}
class ms {
  constructor(t2, e2, n2) {
    let r2;
    if (this.opts = n2, t2.zone.isUniversal) {
      const e3 = t2.offset / 60 * -1, s3 = e3 >= 0 ? `Etc/GMT+${e3}` : `Etc/GMT${e3}`;
      t2.offset !== 0 && Vr.create(s3).valid ? (r2 = s3, this.dt = t2) : (r2 = "UTC", this.dt = n2.timeZoneName || t2.offset === 0 ? t2 : la.fromMillis(t2.ts + 60 * t2.offset * 1e3));
    } else
      t2.zone.type === "system" ? this.dt = t2 : (this.dt = t2, r2 = t2.zone.name);
    const s2 = {...this.opts};
    r2 && (s2.timeZone = r2), this.dtf = us(e2, s2);
  }
  format() {
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class ps {
  constructor(t2, e2, n2) {
    this.opts = {style: "long", ...n2}, !e2 && rr() && (this.rtf = function(t3, e3 = {}) {
      const {base: n3, ...r2} = e3, s2 = JSON.stringify([t3, r2]);
      let i2 = hs[s2];
      return i2 || (i2 = new Intl.RelativeTimeFormat(t3, e3), hs[s2] = i2), i2;
    }(t2, n2));
  }
  format(t2, e2) {
    return this.rtf ? this.rtf.format(t2, e2) : function(t3, e3, n2 = "always", r2 = false) {
      const s2 = {years: ["year", "yr."], quarters: ["quarter", "qtr."], months: ["month", "mo."], weeks: ["week", "wk."], days: ["day", "day", "days"], hours: ["hour", "hr."], minutes: ["minute", "min."], seconds: ["second", "sec."]}, i2 = ["hours", "minutes", "seconds"].indexOf(t3) === -1;
      if (n2 === "auto" && i2) {
        const n3 = t3 === "days";
        switch (e3) {
          case 1:
            return n3 ? "tomorrow" : `next ${s2[t3][0]}`;
          case -1:
            return n3 ? "yesterday" : `last ${s2[t3][0]}`;
          case 0:
            return n3 ? "today" : `this ${s2[t3][0]}`;
        }
      }
      const a2 = Object.is(e3, -0) || e3 < 0, o2 = Math.abs(e3), u2 = o2 === 1, c2 = s2[t3], h2 = r2 ? u2 ? c2[1] : c2[2] || c2[1] : u2 ? s2[t3][0] : t3;
      return a2 ? `${o2} ${h2} ago` : `in ${o2} ${h2}`;
    }(e2, t2, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(t2, e2) {
    return this.rtf ? this.rtf.formatToParts(t2, e2) : [];
  }
}
class ys {
  static fromOpts(t2) {
    return ys.create(t2.locale, t2.numberingSystem, t2.outputCalendar, t2.defaultToEN);
  }
  static create(t2, e2, n2, r2 = false) {
    const s2 = t2 || is.defaultLocale, i2 = s2 || (r2 ? "en-US" : ls || (ls = new Intl.DateTimeFormat().resolvedOptions().locale, ls));
    return new ys(i2, e2 || is.defaultNumberingSystem, n2 || is.defaultOutputCalendar, s2);
  }
  static resetCache() {
    ls = null, os = {}, cs = {}, hs = {};
  }
  static fromObject({locale: t2, numberingSystem: e2, outputCalendar: n2} = {}) {
    return ys.create(t2, e2, n2);
  }
  constructor(t2, e2, n2, r2) {
    const [s2, i2, a2] = function(t3) {
      const e3 = t3.indexOf("-u-");
      if (e3 === -1)
        return [t3];
      {
        let n3;
        const r3 = t3.substring(0, e3);
        try {
          n3 = us(t3).resolvedOptions();
        } catch (t4) {
          n3 = us(r3).resolvedOptions();
        }
        const {numberingSystem: s3, calendar: i3} = n3;
        return [r3, s3, i3];
      }
    }(t2);
    this.locale = s2, this.numberingSystem = e2 || i2 || null, this.outputCalendar = n2 || a2 || null, this.intl = function(t3, e3, n3) {
      return n3 || e3 ? (t3 += "-u", n3 && (t3 += `-ca-${n3}`), e3 && (t3 += `-nu-${e3}`), t3) : t3;
    }(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = {format: {}, standalone: {}}, this.monthsCache = {format: {}, standalone: {}}, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = r2, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    var t2;
    return this.fastNumbersCached == null && (this.fastNumbersCached = (!(t2 = this).numberingSystem || t2.numberingSystem === "latn") && (t2.numberingSystem === "latn" || !t2.locale || t2.locale.startsWith("en") || new Intl.DateTimeFormat(t2.intl).resolvedOptions().numberingSystem === "latn")), this.fastNumbersCached;
  }
  listingMode() {
    return this.isEnglish() && !(this.numberingSystem !== null && this.numberingSystem !== "latn" || this.outputCalendar !== null && this.outputCalendar !== "gregory") ? "en" : "intl";
  }
  clone(t2) {
    return t2 && Object.getOwnPropertyNames(t2).length !== 0 ? ys.create(t2.locale || this.specifiedLocale, t2.numberingSystem || this.numberingSystem, t2.outputCalendar || this.outputCalendar, t2.defaultToEN || false) : this;
  }
  redefaultToEN(t2 = {}) {
    return this.clone({...t2, defaultToEN: true});
  }
  redefaultToSystem(t2 = {}) {
    return this.clone({...t2, defaultToEN: false});
  }
  months(t2, e2 = false, n2 = true) {
    return ds(this, t2, n2, _r, () => {
      const n3 = e2 ? {month: t2, day: "numeric"} : {month: t2}, r2 = e2 ? "format" : "standalone";
      return this.monthsCache[r2][t2] || (this.monthsCache[r2][t2] = function(t3) {
        const e3 = [];
        for (let n4 = 1; n4 <= 12; n4++) {
          const r3 = la.utc(2016, n4, 1);
          e3.push(t3(r3));
        }
        return e3;
      }((t3) => this.extract(t3, n3, "month"))), this.monthsCache[r2][t2];
    });
  }
  weekdays(t2, e2 = false, n2 = true) {
    return ds(this, t2, n2, Dr, () => {
      const n3 = e2 ? {weekday: t2, year: "numeric", month: "long", day: "numeric"} : {weekday: t2}, r2 = e2 ? "format" : "standalone";
      return this.weekdaysCache[r2][t2] || (this.weekdaysCache[r2][t2] = function(t3) {
        const e3 = [];
        for (let n4 = 1; n4 <= 7; n4++) {
          const r3 = la.utc(2016, 11, 13 + n4);
          e3.push(t3(r3));
        }
        return e3;
      }((t3) => this.extract(t3, n3, "weekday"))), this.weekdaysCache[r2][t2];
    });
  }
  meridiems(t2 = true) {
    return ds(this, void 0, t2, () => $r, () => {
      if (!this.meridiemCache) {
        const t3 = {hour: "numeric", hourCycle: "h12"};
        this.meridiemCache = [la.utc(2016, 11, 13, 9), la.utc(2016, 11, 13, 19)].map((e2) => this.extract(e2, t3, "dayperiod"));
      }
      return this.meridiemCache;
    });
  }
  eras(t2, e2 = true) {
    return ds(this, t2, e2, Cr, () => {
      const e3 = {era: t2};
      return this.eraCache[t2] || (this.eraCache[t2] = [la.utc(-40, 1, 1), la.utc(2017, 1, 1)].map((t3) => this.extract(t3, e3, "era"))), this.eraCache[t2];
    });
  }
  extract(t2, e2, n2) {
    const r2 = this.dtFormatter(t2, e2).formatToParts().find((t3) => t3.type.toLowerCase() === n2);
    return r2 ? r2.value : null;
  }
  numberFormatter(t2 = {}) {
    return new fs(this.intl, t2.forceSimple || this.fastNumbers, t2);
  }
  dtFormatter(t2, e2 = {}) {
    return new ms(t2, this.intl, e2);
  }
  relFormatter(t2 = {}) {
    return new ps(this.intl, this.isEnglish(), t2);
  }
  listFormatter(t2 = {}) {
    return function(t3, e2 = {}) {
      const n2 = JSON.stringify([t3, e2]);
      let r2 = as[n2];
      return r2 || (r2 = new Intl.ListFormat(t3, e2), as[n2] = r2), r2;
    }(this.intl, t2);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(t2) {
    return this.locale === t2.locale && this.numberingSystem === t2.numberingSystem && this.outputCalendar === t2.outputCalendar;
  }
}
function ws(...t2) {
  const e2 = t2.reduce((t3, e3) => t3 + e3.source, "");
  return RegExp(`^${e2}$`);
}
function gs(...t2) {
  return (e2) => t2.reduce(([t3, n2, r2], s2) => {
    const [i2, a2, o2] = s2(e2, r2);
    return [{...t3, ...i2}, a2 || n2, o2];
  }, [{}, null, 1]).slice(0, 2);
}
function vs(t2, ...e2) {
  if (t2 == null)
    return [null, null];
  for (const [n2, r2] of e2) {
    const e3 = n2.exec(t2);
    if (e3)
      return r2(e3);
  }
  return [null, null];
}
function bs(...t2) {
  return (e2, n2) => {
    const r2 = {};
    let s2;
    for (s2 = 0; s2 < t2.length; s2++)
      r2[t2[s2]] = ur(e2[n2 + s2]);
    return [r2, null, n2 + s2];
  };
}
const xs = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, Es = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, Ns = RegExp(`${Es.source}(?:${xs.source}?(?:\\[(${Sr.source})\\])?)?`), Ss = RegExp(`(?:T${Ns.source})?`), Ms = bs("weekYear", "weekNumber", "weekDay"), ks = bs("year", "ordinal"), Ts = RegExp(`${Es.source} ?(?:${xs.source}|(${Sr.source}))?`), _s = RegExp(`(?: ${Ts.source})?`);
function Is(t2, e2, n2) {
  const r2 = t2[e2];
  return tr(r2) ? n2 : ur(r2);
}
function Zs(t2, e2) {
  return [{hours: Is(t2, e2, 0), minutes: Is(t2, e2 + 1, 0), seconds: Is(t2, e2 + 2, 0), milliseconds: hr(t2[e2 + 3])}, null, e2 + 4];
}
function As(t2, e2) {
  const n2 = !t2[e2] && !t2[e2 + 1], r2 = vr(t2[e2 + 1], t2[e2 + 2]);
  return [{}, n2 ? null : Jr.instance(r2), e2 + 3];
}
function Ds(t2, e2) {
  return [{}, t2[e2] ? Vr.create(t2[e2]) : null, e2 + 1];
}
const $s = RegExp(`^T?${Es.source}$`), Os = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function Ls(t2) {
  const [e2, n2, r2, s2, i2, a2, o2, u2, c2] = t2, h2 = e2[0] === "-", l2 = u2 && u2[0] === "-", d2 = (t3, e3 = false) => t3 !== void 0 && (e3 || t3 && h2) ? -t3 : t3;
  return [{years: d2(cr(n2)), months: d2(cr(r2)), weeks: d2(cr(s2)), days: d2(cr(i2)), hours: d2(cr(a2)), minutes: d2(cr(o2)), seconds: d2(cr(u2), u2 === "-0"), milliseconds: d2(hr(c2), l2)}];
}
const Us = {GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480};
function Cs(t2, e2, n2, r2, s2, i2, a2) {
  const o2 = {year: e2.length === 2 ? wr(ur(e2)) : ur(e2), month: kr.indexOf(n2) + 1, day: ur(r2), hour: ur(s2), minute: ur(i2)};
  return a2 && (o2.second = ur(a2)), t2 && (o2.weekday = t2.length > 3 ? Ir.indexOf(t2) + 1 : Zr.indexOf(t2) + 1), o2;
}
const Ps = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function js(t2) {
  const [, e2, n2, r2, s2, i2, a2, o2, u2, c2, h2, l2] = t2, d2 = Cs(e2, s2, r2, n2, i2, a2, o2);
  let f2;
  return f2 = u2 ? Us[u2] : c2 ? 0 : vr(h2, l2), [d2, new Jr(f2)];
}
const Fs = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, Rs = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Bs = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function Hs(t2) {
  const [, e2, n2, r2, s2, i2, a2, o2] = t2;
  return [Cs(e2, s2, r2, n2, i2, a2, o2), Jr.utcInstance];
}
function Gs(t2) {
  const [, e2, n2, r2, s2, i2, a2, o2] = t2;
  return [Cs(e2, o2, n2, r2, s2, i2, a2), Jr.utcInstance];
}
const Ws = ws(/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, Ss), qs = ws(/(\d{4})-?W(\d\d)(?:-?(\d))?/, Ss), zs = ws(/(\d{4})-?(\d{3})/, Ss), Vs = ws(Ns), Ks = gs(function(t2, e2) {
  return [{year: Is(t2, e2), month: Is(t2, e2 + 1, 1), day: Is(t2, e2 + 2, 1)}, null, e2 + 3];
}, Zs, As, Ds), Js = gs(Ms, Zs, As, Ds), Ys = gs(ks, Zs, As, Ds), Qs = gs(Zs, As, Ds), Xs = gs(Zs), ti = ws(/(\d{4})-(\d\d)-(\d\d)/, _s), ei = ws(Ts), ni = gs(Zs, As, Ds), ri = {weeks: {days: 7, hours: 168, minutes: 10080, seconds: 604800, milliseconds: 6048e5}, days: {hours: 24, minutes: 1440, seconds: 86400, milliseconds: 864e5}, hours: {minutes: 60, seconds: 3600, milliseconds: 36e5}, minutes: {seconds: 60, milliseconds: 6e4}, seconds: {milliseconds: 1e3}}, si = {years: {quarters: 4, months: 12, weeks: 52, days: 365, hours: 8760, minutes: 525600, seconds: 31536e3, milliseconds: 31536e6}, quarters: {months: 3, weeks: 13, days: 91, hours: 2184, minutes: 131040, seconds: 7862400, milliseconds: 78624e5}, months: {weeks: 4, days: 30, hours: 720, minutes: 43200, seconds: 2592e3, milliseconds: 2592e6}, ...ri}, ii = {years: {quarters: 4, months: 12, weeks: 52.1775, days: 365.2425, hours: 8765.82, minutes: 525949.2, seconds: 525949.2 * 60, milliseconds: 525949.2 * 60 * 1e3}, quarters: {months: 3, weeks: 13.044375, days: 91.310625, hours: 2191.455, minutes: 131487.3, seconds: 525949.2 * 60 / 4, milliseconds: 7889237999999999e-6}, months: {weeks: 30.436875 / 7, days: 30.436875, hours: 730.485, minutes: 43829.1, seconds: 2629746, milliseconds: 2629746e3}, ...ri}, ai = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"], oi = ai.slice(0).reverse();
function ui(t2, e2, n2 = false) {
  const r2 = {values: n2 ? e2.values : {...t2.values, ...e2.values || {}}, loc: t2.loc.clone(e2.loc), conversionAccuracy: e2.conversionAccuracy || t2.conversionAccuracy};
  return new hi(r2);
}
function ci(t2, e2, n2, r2, s2) {
  const i2 = t2[s2][n2], a2 = e2[n2] / i2, o2 = Math.sign(a2) !== Math.sign(r2[s2]) && r2[s2] !== 0 && Math.abs(a2) <= 1 ? function(t3) {
    return t3 < 0 ? Math.floor(t3) : Math.ceil(t3);
  }(a2) : Math.trunc(a2);
  r2[s2] += o2, e2[n2] -= o2 * i2;
}
class hi {
  constructor(t2) {
    const e2 = t2.conversionAccuracy === "longterm" || false;
    this.values = t2.values, this.loc = t2.loc || ys.create(), this.conversionAccuracy = e2 ? "longterm" : "casual", this.invalid = t2.invalid || null, this.matrix = e2 ? ii : si, this.isLuxonDuration = true;
  }
  static fromMillis(t2, e2) {
    return hi.fromObject({milliseconds: t2}, e2);
  }
  static fromObject(t2, e2 = {}) {
    if (t2 == null || typeof t2 != "object")
      throw new Tn("Duration.fromObject: argument expected to be an object, got " + (t2 === null ? "null" : typeof t2));
    return new hi({values: xr(t2, hi.normalizeUnit), loc: ys.fromObject(e2), conversionAccuracy: e2.conversionAccuracy});
  }
  static fromDurationLike(t2) {
    if (er(t2))
      return hi.fromMillis(t2);
    if (hi.isDuration(t2))
      return t2;
    if (typeof t2 == "object")
      return hi.fromObject(t2);
    throw new Tn(`Unknown duration argument ${t2} of type ${typeof t2}`);
  }
  static fromISO(t2, e2) {
    const [n2] = function(t3) {
      return vs(t3, [Os, Ls]);
    }(t2);
    return n2 ? hi.fromObject(n2, e2) : hi.invalid("unparsable", `the input "${t2}" can't be parsed as ISO 8601`);
  }
  static fromISOTime(t2, e2) {
    const [n2] = function(t3) {
      return vs(t3, [$s, Xs]);
    }(t2);
    return n2 ? hi.fromObject(n2, e2) : hi.invalid("unparsable", `the input "${t2}" can't be parsed as ISO 8601`);
  }
  static invalid(t2, e2 = null) {
    if (!t2)
      throw new Tn("need to specify a reason the Duration is invalid");
    const n2 = t2 instanceof Rr ? t2 : new Rr(t2, e2);
    if (is.throwOnInvalid)
      throw new Sn(n2);
    return new hi({invalid: n2});
  }
  static normalizeUnit(t2) {
    const e2 = {year: "years", years: "years", quarter: "quarters", quarters: "quarters", month: "months", months: "months", week: "weeks", weeks: "weeks", day: "days", days: "days", hour: "hours", hours: "hours", minute: "minutes", minutes: "minutes", second: "seconds", seconds: "seconds", millisecond: "milliseconds", milliseconds: "milliseconds"}[t2 ? t2.toLowerCase() : t2];
    if (!e2)
      throw new kn(t2);
    return e2;
  }
  static isDuration(t2) {
    return t2 && t2.isLuxonDuration || false;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(t2, e2 = {}) {
    const n2 = {...e2, floor: e2.round !== false && e2.floor !== false};
    return this.isValid ? Fr.create(this.loc, n2).formatDurationFromString(this, t2) : "Invalid Duration";
  }
  toHuman(t2 = {}) {
    const e2 = ai.map((e3) => {
      const n2 = this.values[e3];
      return tr(n2) ? null : this.loc.numberFormatter({style: "unit", unitDisplay: "long", ...t2, unit: e3.slice(0, -1)}).format(n2);
    }).filter((t3) => t3);
    return this.loc.listFormatter({type: "conjunction", style: t2.listStyle || "narrow", ...t2}).format(e2);
  }
  toObject() {
    return this.isValid ? {...this.values} : {};
  }
  toISO() {
    if (!this.isValid)
      return null;
    let t2 = "P";
    return this.years !== 0 && (t2 += this.years + "Y"), this.months === 0 && this.quarters === 0 || (t2 += this.months + 3 * this.quarters + "M"), this.weeks !== 0 && (t2 += this.weeks + "W"), this.days !== 0 && (t2 += this.days + "D"), this.hours === 0 && this.minutes === 0 && this.seconds === 0 && this.milliseconds === 0 || (t2 += "T"), this.hours !== 0 && (t2 += this.hours + "H"), this.minutes !== 0 && (t2 += this.minutes + "M"), this.seconds === 0 && this.milliseconds === 0 || (t2 += lr(this.seconds + this.milliseconds / 1e3, 3) + "S"), t2 === "P" && (t2 += "T0S"), t2;
  }
  toISOTime(t2 = {}) {
    if (!this.isValid)
      return null;
    const e2 = this.toMillis();
    if (e2 < 0 || e2 >= 864e5)
      return null;
    t2 = {suppressMilliseconds: false, suppressSeconds: false, includePrefix: false, format: "extended", ...t2};
    const n2 = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let r2 = t2.format === "basic" ? "hhmm" : "hh:mm";
    t2.suppressSeconds && n2.seconds === 0 && n2.milliseconds === 0 || (r2 += t2.format === "basic" ? "ss" : ":ss", t2.suppressMilliseconds && n2.milliseconds === 0 || (r2 += ".SSS"));
    let s2 = n2.toFormat(r2);
    return t2.includePrefix && (s2 = "T" + s2), s2;
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  toMillis() {
    return this.as("milliseconds");
  }
  valueOf() {
    return this.toMillis();
  }
  plus(t2) {
    if (!this.isValid)
      return this;
    const e2 = hi.fromDurationLike(t2), n2 = {};
    for (const t3 of ai)
      (ir(e2.values, t3) || ir(this.values, t3)) && (n2[t3] = e2.get(t3) + this.get(t3));
    return ui(this, {values: n2}, true);
  }
  minus(t2) {
    if (!this.isValid)
      return this;
    const e2 = hi.fromDurationLike(t2);
    return this.plus(e2.negate());
  }
  mapUnits(t2) {
    if (!this.isValid)
      return this;
    const e2 = {};
    for (const n2 of Object.keys(this.values))
      e2[n2] = br(t2(this.values[n2], n2));
    return ui(this, {values: e2}, true);
  }
  get(t2) {
    return this[hi.normalizeUnit(t2)];
  }
  set(t2) {
    return this.isValid ? ui(this, {values: {...this.values, ...xr(t2, hi.normalizeUnit)}}) : this;
  }
  reconfigure({locale: t2, numberingSystem: e2, conversionAccuracy: n2} = {}) {
    const r2 = {loc: this.loc.clone({locale: t2, numberingSystem: e2})};
    return n2 && (r2.conversionAccuracy = n2), ui(this, r2);
  }
  as(t2) {
    return this.isValid ? this.shiftTo(t2).get(t2) : NaN;
  }
  normalize() {
    if (!this.isValid)
      return this;
    const t2 = this.toObject();
    return function(t3, e2) {
      oi.reduce((n2, r2) => tr(e2[r2]) ? n2 : (n2 && ci(t3, e2, n2, e2, r2), r2), null);
    }(this.matrix, t2), ui(this, {values: t2}, true);
  }
  shiftTo(...t2) {
    if (!this.isValid)
      return this;
    if (t2.length === 0)
      return this;
    t2 = t2.map((t3) => hi.normalizeUnit(t3));
    const e2 = {}, n2 = {}, r2 = this.toObject();
    let s2;
    for (const i2 of ai)
      if (t2.indexOf(i2) >= 0) {
        s2 = i2;
        let t3 = 0;
        for (const e3 in n2)
          t3 += this.matrix[e3][i2] * n2[e3], n2[e3] = 0;
        er(r2[i2]) && (t3 += r2[i2]);
        const a2 = Math.trunc(t3);
        e2[i2] = a2, n2[i2] = (1e3 * t3 - 1e3 * a2) / 1e3;
        for (const t4 in r2)
          ai.indexOf(t4) > ai.indexOf(i2) && ci(this.matrix, r2, t4, e2, i2);
      } else
        er(r2[i2]) && (n2[i2] = r2[i2]);
    for (const t3 in n2)
      n2[t3] !== 0 && (e2[s2] += t3 === s2 ? n2[t3] : n2[t3] / this.matrix[s2][t3]);
    return ui(this, {values: e2}, true).normalize();
  }
  negate() {
    if (!this.isValid)
      return this;
    const t2 = {};
    for (const e2 of Object.keys(this.values))
      t2[e2] = this.values[e2] === 0 ? 0 : -this.values[e2];
    return ui(this, {values: t2}, true);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(t2) {
    if (!this.isValid || !t2.isValid)
      return false;
    if (!this.loc.equals(t2.loc))
      return false;
    for (const r2 of ai)
      if (n2 = t2.values[r2], !((e2 = this.values[r2]) === void 0 || e2 === 0 ? n2 === void 0 || n2 === 0 : e2 === n2))
        return false;
    var e2, n2;
    return true;
  }
}
const li = "Invalid Interval";
class di {
  constructor(t2) {
    this.s = t2.start, this.e = t2.end, this.invalid = t2.invalid || null, this.isLuxonInterval = true;
  }
  static invalid(t2, e2 = null) {
    if (!t2)
      throw new Tn("need to specify a reason the Interval is invalid");
    const n2 = t2 instanceof Rr ? t2 : new Rr(t2, e2);
    if (is.throwOnInvalid)
      throw new Nn(n2);
    return new di({invalid: n2});
  }
  static fromDateTimes(t2, e2) {
    const n2 = da(t2), r2 = da(e2), s2 = function(t3, e3) {
      return t3 && t3.isValid ? e3 && e3.isValid ? e3 < t3 ? di.invalid("end before start", `The end of an interval must be after its start, but you had start=${t3.toISO()} and end=${e3.toISO()}`) : null : di.invalid("missing or invalid end") : di.invalid("missing or invalid start");
    }(n2, r2);
    return s2 == null ? new di({start: n2, end: r2}) : s2;
  }
  static after(t2, e2) {
    const n2 = hi.fromDurationLike(e2), r2 = da(t2);
    return di.fromDateTimes(r2, r2.plus(n2));
  }
  static before(t2, e2) {
    const n2 = hi.fromDurationLike(e2), r2 = da(t2);
    return di.fromDateTimes(r2.minus(n2), r2);
  }
  static fromISO(t2, e2) {
    const [n2, r2] = (t2 || "").split("/", 2);
    if (n2 && r2) {
      let t3, s2, i2, a2;
      try {
        t3 = la.fromISO(n2, e2), s2 = t3.isValid;
      } catch (r3) {
        s2 = false;
      }
      try {
        i2 = la.fromISO(r2, e2), a2 = i2.isValid;
      } catch (r3) {
        a2 = false;
      }
      if (s2 && a2)
        return di.fromDateTimes(t3, i2);
      if (s2) {
        const n3 = hi.fromISO(r2, e2);
        if (n3.isValid)
          return di.after(t3, n3);
      } else if (a2) {
        const t4 = hi.fromISO(n2, e2);
        if (t4.isValid)
          return di.before(i2, t4);
      }
    }
    return di.invalid("unparsable", `the input "${t2}" can't be parsed as ISO 8601`);
  }
  static isInterval(t2) {
    return t2 && t2.isLuxonInterval || false;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(t2 = "milliseconds") {
    return this.isValid ? this.toDuration(t2).get(t2) : NaN;
  }
  count(t2 = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const e2 = this.start.startOf(t2), n2 = this.end.startOf(t2);
    return Math.floor(n2.diff(e2, t2).get(t2)) + 1;
  }
  hasSame(t2) {
    return !!this.isValid && (this.isEmpty() || this.e.minus(1).hasSame(this.s, t2));
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(t2) {
    return !!this.isValid && this.s > t2;
  }
  isBefore(t2) {
    return !!this.isValid && this.e <= t2;
  }
  contains(t2) {
    return !!this.isValid && this.s <= t2 && this.e > t2;
  }
  set({start: t2, end: e2} = {}) {
    return this.isValid ? di.fromDateTimes(t2 || this.s, e2 || this.e) : this;
  }
  splitAt(...t2) {
    if (!this.isValid)
      return [];
    const e2 = t2.map(da).filter((t3) => this.contains(t3)).sort(), n2 = [];
    let {s: r2} = this, s2 = 0;
    for (; r2 < this.e; ) {
      const t3 = e2[s2] || this.e, i2 = +t3 > +this.e ? this.e : t3;
      n2.push(di.fromDateTimes(r2, i2)), r2 = i2, s2 += 1;
    }
    return n2;
  }
  splitBy(t2) {
    const e2 = hi.fromDurationLike(t2);
    if (!this.isValid || !e2.isValid || e2.as("milliseconds") === 0)
      return [];
    let n2, {s: r2} = this, s2 = 1;
    const i2 = [];
    for (; r2 < this.e; ) {
      const t3 = this.start.plus(e2.mapUnits((t4) => t4 * s2));
      n2 = +t3 > +this.e ? this.e : t3, i2.push(di.fromDateTimes(r2, n2)), r2 = n2, s2 += 1;
    }
    return i2;
  }
  divideEqually(t2) {
    return this.isValid ? this.splitBy(this.length() / t2).slice(0, t2) : [];
  }
  overlaps(t2) {
    return this.e > t2.s && this.s < t2.e;
  }
  abutsStart(t2) {
    return !!this.isValid && +this.e == +t2.s;
  }
  abutsEnd(t2) {
    return !!this.isValid && +t2.e == +this.s;
  }
  engulfs(t2) {
    return !!this.isValid && this.s <= t2.s && this.e >= t2.e;
  }
  equals(t2) {
    return !(!this.isValid || !t2.isValid) && this.s.equals(t2.s) && this.e.equals(t2.e);
  }
  intersection(t2) {
    if (!this.isValid)
      return this;
    const e2 = this.s > t2.s ? this.s : t2.s, n2 = this.e < t2.e ? this.e : t2.e;
    return e2 >= n2 ? null : di.fromDateTimes(e2, n2);
  }
  union(t2) {
    return this.isValid ? di.fromDateTimes(this.s < t2.s ? this.s : t2.s, this.e > t2.e ? this.e : t2.e) : this;
  }
  static merge(t2) {
    const [e2, n2] = t2.sort((t3, e3) => t3.s - e3.s).reduce(([t3, e3], n3) => e3 ? e3.overlaps(n3) || e3.abutsStart(n3) ? [t3, e3.union(n3)] : [t3.concat([e3]), n3] : [t3, n3], [[], null]);
    return n2 && e2.push(n2), e2;
  }
  static xor(t2) {
    let e2 = null, n2 = 0;
    const r2 = [], s2 = t2.map((t3) => [{time: t3.s, type: "s"}, {time: t3.e, type: "e"}]), i2 = Array.prototype.concat(...s2).sort((t3, e3) => t3.time - e3.time);
    for (const t3 of i2)
      n2 += t3.type === "s" ? 1 : -1, n2 === 1 ? e2 = t3.time : (e2 && +e2 != +t3.time && r2.push(di.fromDateTimes(e2, t3.time)), e2 = null);
    return di.merge(r2);
  }
  difference(...t2) {
    return di.xor([this].concat(t2)).map((t3) => this.intersection(t3)).filter((t3) => t3 && !t3.isEmpty());
  }
  toString() {
    return this.isValid ? `[${this.s.toISO()} \u2013 ${this.e.toISO()})` : li;
  }
  toISO(t2) {
    return this.isValid ? `${this.s.toISO(t2)}/${this.e.toISO(t2)}` : li;
  }
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : li;
  }
  toISOTime(t2) {
    return this.isValid ? `${this.s.toISOTime(t2)}/${this.e.toISOTime(t2)}` : li;
  }
  toFormat(t2, {separator: e2 = " \u2013 "} = {}) {
    return this.isValid ? `${this.s.toFormat(t2)}${e2}${this.e.toFormat(t2)}` : li;
  }
  toDuration(t2, e2) {
    return this.isValid ? this.e.diff(this.s, t2, e2) : hi.invalid(this.invalidReason);
  }
  mapEndpoints(t2) {
    return di.fromDateTimes(t2(this.s), t2(this.e));
  }
}
class fi {
  static hasDST(t2 = is.defaultZone) {
    const e2 = la.now().setZone(t2).set({month: 12});
    return !t2.isUniversal && e2.offset !== e2.set({month: 6}).offset;
  }
  static isValidIANAZone(t2) {
    return Vr.isValidZone(t2);
  }
  static normalizeZone(t2) {
    return Qr(t2, is.defaultZone);
  }
  static months(t2 = "long", {locale: e2 = null, numberingSystem: n2 = null, locObj: r2 = null, outputCalendar: s2 = "gregory"} = {}) {
    return (r2 || ys.create(e2, n2, s2)).months(t2);
  }
  static monthsFormat(t2 = "long", {locale: e2 = null, numberingSystem: n2 = null, locObj: r2 = null, outputCalendar: s2 = "gregory"} = {}) {
    return (r2 || ys.create(e2, n2, s2)).months(t2, true);
  }
  static weekdays(t2 = "long", {locale: e2 = null, numberingSystem: n2 = null, locObj: r2 = null} = {}) {
    return (r2 || ys.create(e2, n2, null)).weekdays(t2);
  }
  static weekdaysFormat(t2 = "long", {locale: e2 = null, numberingSystem: n2 = null, locObj: r2 = null} = {}) {
    return (r2 || ys.create(e2, n2, null)).weekdays(t2, true);
  }
  static meridiems({locale: t2 = null} = {}) {
    return ys.create(t2).meridiems();
  }
  static eras(t2 = "short", {locale: e2 = null} = {}) {
    return ys.create(e2, null, "gregory").eras(t2);
  }
  static features() {
    return {relative: rr()};
  }
}
function mi(t2, e2) {
  const n2 = (t3) => t3.toUTC(0, {keepLocalTime: true}).startOf("day").valueOf(), r2 = n2(e2) - n2(t2);
  return Math.floor(hi.fromMillis(r2).as("days"));
}
const pi = {arab: "[\u0660-\u0669]", arabext: "[\u06F0-\u06F9]", bali: "[\u1B50-\u1B59]", beng: "[\u09E6-\u09EF]", deva: "[\u0966-\u096F]", fullwide: "[\uFF10-\uFF19]", gujr: "[\u0AE6-\u0AEF]", hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]", khmr: "[\u17E0-\u17E9]", knda: "[\u0CE6-\u0CEF]", laoo: "[\u0ED0-\u0ED9]", limb: "[\u1946-\u194F]", mlym: "[\u0D66-\u0D6F]", mong: "[\u1810-\u1819]", mymr: "[\u1040-\u1049]", orya: "[\u0B66-\u0B6F]", tamldec: "[\u0BE6-\u0BEF]", telu: "[\u0C66-\u0C6F]", thai: "[\u0E50-\u0E59]", tibt: "[\u0F20-\u0F29]", latn: "\\d"}, yi = {arab: [1632, 1641], arabext: [1776, 1785], bali: [6992, 7001], beng: [2534, 2543], deva: [2406, 2415], fullwide: [65296, 65303], gujr: [2790, 2799], khmr: [6112, 6121], knda: [3302, 3311], laoo: [3792, 3801], limb: [6470, 6479], mlym: [3430, 3439], mong: [6160, 6169], mymr: [4160, 4169], orya: [2918, 2927], tamldec: [3046, 3055], telu: [3174, 3183], thai: [3664, 3673], tibt: [3872, 3881]}, wi = pi.hanidec.replace(/[\[|\]]/g, "").split("");
function gi({numberingSystem: t2}, e2 = "") {
  return new RegExp(`${pi[t2 || "latn"]}${e2}`);
}
function vi(t2, e2 = (t3) => t3) {
  return {regex: t2, deser: ([t3]) => e2(function(t4) {
    let e3 = parseInt(t4, 10);
    if (isNaN(e3)) {
      e3 = "";
      for (let n2 = 0; n2 < t4.length; n2++) {
        const r2 = t4.charCodeAt(n2);
        if (t4[n2].search(pi.hanidec) !== -1)
          e3 += wi.indexOf(t4[n2]);
        else
          for (const t5 in yi) {
            const [n3, s2] = yi[t5];
            r2 >= n3 && r2 <= s2 && (e3 += r2 - n3);
          }
      }
      return parseInt(e3, 10);
    }
    return e3;
  }(t3))};
}
const bi = `[ ${String.fromCharCode(160)}]`, xi = new RegExp(bi, "g");
function Ei(t2) {
  return t2.replace(/\./g, "\\.?").replace(xi, bi);
}
function Ni(t2) {
  return t2.replace(/\./g, "").replace(xi, " ").toLowerCase();
}
function Si(t2, e2) {
  return t2 === null ? null : {regex: RegExp(t2.map(Ei).join("|")), deser: ([n2]) => t2.findIndex((t3) => Ni(n2) === Ni(t3)) + e2};
}
function Mi(t2, e2) {
  return {regex: t2, deser: ([, t3, e3]) => vr(t3, e3), groups: e2};
}
function ki(t2) {
  return {regex: t2, deser: ([t3]) => t3};
}
const Ti = {year: {"2-digit": "yy", numeric: "yyyyy"}, month: {numeric: "M", "2-digit": "MM", short: "MMM", long: "MMMM"}, day: {numeric: "d", "2-digit": "dd"}, weekday: {short: "EEE", long: "EEEE"}, dayperiod: "a", dayPeriod: "a", hour: {numeric: "h", "2-digit": "hh"}, minute: {numeric: "m", "2-digit": "mm"}, second: {numeric: "s", "2-digit": "ss"}, timeZoneName: {long: "ZZZZZ", short: "ZZZ"}};
let _i = null;
function Ii(t2, e2, n2) {
  const r2 = function(t3, e3) {
    return Array.prototype.concat(...t3.map((t4) => function(t5, e4) {
      if (t5.literal)
        return t5;
      const n3 = Zi(Fr.macroTokenToFormatOpts(t5.val), e4);
      return n3 == null || n3.includes(void 0) ? t5 : n3;
    }(t4, e3)));
  }(Fr.parseFormat(n2), t2), s2 = r2.map((e3) => function(t3, e4) {
    const n3 = gi(e4), r3 = gi(e4, "{2}"), s3 = gi(e4, "{3}"), i3 = gi(e4, "{4}"), a2 = gi(e4, "{6}"), o2 = gi(e4, "{1,2}"), u2 = gi(e4, "{1,3}"), c2 = gi(e4, "{1,6}"), h2 = gi(e4, "{1,9}"), l2 = gi(e4, "{2,4}"), d2 = gi(e4, "{4,6}"), f2 = (t4) => {
      return {regex: RegExp((e5 = t4.val, e5.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"))), deser: ([t5]) => t5, literal: true};
      var e5;
    }, m2 = ((m3) => {
      if (t3.literal)
        return f2(m3);
      switch (m3.val) {
        case "G":
          return Si(e4.eras("short", false), 0);
        case "GG":
          return Si(e4.eras("long", false), 0);
        case "y":
          return vi(c2);
        case "yy":
          return vi(l2, wr);
        case "yyyy":
          return vi(i3);
        case "yyyyy":
          return vi(d2);
        case "yyyyyy":
          return vi(a2);
        case "M":
          return vi(o2);
        case "MM":
          return vi(r3);
        case "MMM":
          return Si(e4.months("short", true, false), 1);
        case "MMMM":
          return Si(e4.months("long", true, false), 1);
        case "L":
          return vi(o2);
        case "LL":
          return vi(r3);
        case "LLL":
          return Si(e4.months("short", false, false), 1);
        case "LLLL":
          return Si(e4.months("long", false, false), 1);
        case "d":
          return vi(o2);
        case "dd":
          return vi(r3);
        case "o":
          return vi(u2);
        case "ooo":
          return vi(s3);
        case "HH":
          return vi(r3);
        case "H":
          return vi(o2);
        case "hh":
          return vi(r3);
        case "h":
          return vi(o2);
        case "mm":
          return vi(r3);
        case "m":
        case "q":
          return vi(o2);
        case "qq":
          return vi(r3);
        case "s":
          return vi(o2);
        case "ss":
          return vi(r3);
        case "S":
          return vi(u2);
        case "SSS":
          return vi(s3);
        case "u":
          return ki(h2);
        case "uu":
          return ki(o2);
        case "uuu":
          return vi(n3);
        case "a":
          return Si(e4.meridiems(), 0);
        case "kkkk":
          return vi(i3);
        case "kk":
          return vi(l2, wr);
        case "W":
          return vi(o2);
        case "WW":
          return vi(r3);
        case "E":
        case "c":
          return vi(n3);
        case "EEE":
          return Si(e4.weekdays("short", false, false), 1);
        case "EEEE":
          return Si(e4.weekdays("long", false, false), 1);
        case "ccc":
          return Si(e4.weekdays("short", true, false), 1);
        case "cccc":
          return Si(e4.weekdays("long", true, false), 1);
        case "Z":
        case "ZZ":
          return Mi(new RegExp(`([+-]${o2.source})(?::(${r3.source}))?`), 2);
        case "ZZZ":
          return Mi(new RegExp(`([+-]${o2.source})(${r3.source})?`), 2);
        case "z":
          return ki(/[a-z_+-/]{1,256}?/i);
        default:
          return f2(m3);
      }
    })(t3) || {invalidReason: "missing Intl.DateTimeFormat.formatToParts support"};
    return m2.token = t3, m2;
  }(e3, t2)), i2 = s2.find((t3) => t3.invalidReason);
  if (i2)
    return {input: e2, tokens: r2, invalidReason: i2.invalidReason};
  {
    const [t3, n3] = function(t4) {
      return [`^${t4.map((t5) => t5.regex).reduce((t5, e3) => `${t5}(${e3.source})`, "")}$`, t4];
    }(s2), i3 = RegExp(t3, "i"), [a2, o2] = function(t4, e3, n4) {
      const r3 = t4.match(e3);
      if (r3) {
        const t5 = {};
        let e4 = 1;
        for (const s3 in n4)
          if (ir(n4, s3)) {
            const i4 = n4[s3], a3 = i4.groups ? i4.groups + 1 : 1;
            !i4.literal && i4.token && (t5[i4.token.val[0]] = i4.deser(r3.slice(e4, e4 + a3))), e4 += a3;
          }
        return [r3, t5];
      }
      return [r3, {}];
    }(e2, i3, n3), [u2, c2, h2] = o2 ? function(t4) {
      let e3, n4 = null;
      return tr(t4.z) || (n4 = Vr.create(t4.z)), tr(t4.Z) || (n4 || (n4 = new Jr(t4.Z)), e3 = t4.Z), tr(t4.q) || (t4.M = 3 * (t4.q - 1) + 1), tr(t4.h) || (t4.h < 12 && t4.a === 1 ? t4.h += 12 : t4.h === 12 && t4.a === 0 && (t4.h = 0)), t4.G === 0 && t4.y && (t4.y = -t4.y), tr(t4.u) || (t4.S = hr(t4.u)), [Object.keys(t4).reduce((e4, n5) => {
        const r3 = ((t5) => {
          switch (t5) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
            case "H":
              return "hour";
            case "d":
              return "day";
            case "o":
              return "ordinal";
            case "L":
            case "M":
              return "month";
            case "y":
              return "year";
            case "E":
            case "c":
              return "weekday";
            case "W":
              return "weekNumber";
            case "k":
              return "weekYear";
            case "q":
              return "quarter";
            default:
              return null;
          }
        })(n5);
        return r3 && (e4[r3] = t4[n5]), e4;
      }, {}), n4, e3];
    }(o2) : [null, null, void 0];
    if (ir(o2, "a") && ir(o2, "H"))
      throw new Mn("Can't include meridiem when specifying 24-hour format");
    return {input: e2, tokens: r2, regex: i3, rawMatches: a2, matches: o2, result: u2, zone: c2, specificOffset: h2};
  }
}
function Zi(t2, e2) {
  return t2 ? Fr.create(e2, t2).formatDateTimeParts((_i || (_i = la.fromMillis(1555555555555)), _i)).map((e3) => function(t3, e4, n2) {
    const {type: r2, value: s2} = t3;
    if (r2 === "literal")
      return {literal: true, val: s2};
    let i2 = Ti[r2];
    return typeof i2 == "object" && (i2 = i2[n2[r2]]), i2 ? {literal: false, val: i2} : void 0;
  }(e3, 0, t2)) : null;
}
const Ai = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Di = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function $i(t2, e2) {
  return new Rr("unit out of range", `you specified ${e2} (of type ${typeof e2}) as a ${t2}, which is invalid`);
}
function Oi(t2, e2, n2) {
  const r2 = new Date(Date.UTC(t2, e2 - 1, n2));
  t2 < 100 && t2 >= 0 && r2.setUTCFullYear(r2.getUTCFullYear() - 1900);
  const s2 = r2.getUTCDay();
  return s2 === 0 ? 7 : s2;
}
function Li(t2, e2, n2) {
  return n2 + (dr(t2) ? Di : Ai)[e2 - 1];
}
function Ui(t2, e2) {
  const n2 = dr(t2) ? Di : Ai, r2 = n2.findIndex((t3) => t3 < e2);
  return {month: r2 + 1, day: e2 - n2[r2]};
}
function Ci(t2) {
  const {year: e2, month: n2, day: r2} = t2, s2 = Li(e2, n2, r2), i2 = Oi(e2, n2, r2);
  let a2, o2 = Math.floor((s2 - i2 + 10) / 7);
  return o2 < 1 ? (a2 = e2 - 1, o2 = yr(a2)) : o2 > yr(e2) ? (a2 = e2 + 1, o2 = 1) : a2 = e2, {weekYear: a2, weekNumber: o2, weekday: i2, ...Nr(t2)};
}
function Pi(t2) {
  const {weekYear: e2, weekNumber: n2, weekday: r2} = t2, s2 = Oi(e2, 1, 4), i2 = fr(e2);
  let a2, o2 = 7 * n2 + r2 - s2 - 3;
  o2 < 1 ? (a2 = e2 - 1, o2 += fr(a2)) : o2 > i2 ? (a2 = e2 + 1, o2 -= fr(e2)) : a2 = e2;
  const {month: u2, day: c2} = Ui(a2, o2);
  return {year: a2, month: u2, day: c2, ...Nr(t2)};
}
function ji(t2) {
  const {year: e2, month: n2, day: r2} = t2;
  return {year: e2, ordinal: Li(e2, n2, r2), ...Nr(t2)};
}
function Fi(t2) {
  const {year: e2, ordinal: n2} = t2, {month: r2, day: s2} = Ui(e2, n2);
  return {year: e2, month: r2, day: s2, ...Nr(t2)};
}
function Ri(t2) {
  const e2 = nr(t2.year), n2 = ar(t2.month, 1, 12), r2 = ar(t2.day, 1, mr(t2.year, t2.month));
  return e2 ? n2 ? !r2 && $i("day", t2.day) : $i("month", t2.month) : $i("year", t2.year);
}
function Bi(t2) {
  const {hour: e2, minute: n2, second: r2, millisecond: s2} = t2, i2 = ar(e2, 0, 23) || e2 === 24 && n2 === 0 && r2 === 0 && s2 === 0, a2 = ar(n2, 0, 59), o2 = ar(r2, 0, 59), u2 = ar(s2, 0, 999);
  return i2 ? a2 ? o2 ? !u2 && $i("millisecond", s2) : $i("second", r2) : $i("minute", n2) : $i("hour", e2);
}
const Hi = "Invalid DateTime";
function Gi(t2) {
  return new Rr("unsupported zone", `the zone "${t2.name}" is not supported`);
}
function Wi(t2) {
  return t2.weekData === null && (t2.weekData = Ci(t2.c)), t2.weekData;
}
function qi(t2, e2) {
  const n2 = {ts: t2.ts, zone: t2.zone, c: t2.c, o: t2.o, loc: t2.loc, invalid: t2.invalid};
  return new la({...n2, ...e2, old: n2});
}
function zi(t2, e2, n2) {
  let r2 = t2 - 60 * e2 * 1e3;
  const s2 = n2.offset(r2);
  if (e2 === s2)
    return [r2, e2];
  r2 -= 60 * (s2 - e2) * 1e3;
  const i2 = n2.offset(r2);
  return s2 === i2 ? [r2, s2] : [t2 - 60 * Math.min(s2, i2) * 1e3, Math.max(s2, i2)];
}
function Vi(t2, e2) {
  const n2 = new Date(t2 += 60 * e2 * 1e3);
  return {year: n2.getUTCFullYear(), month: n2.getUTCMonth() + 1, day: n2.getUTCDate(), hour: n2.getUTCHours(), minute: n2.getUTCMinutes(), second: n2.getUTCSeconds(), millisecond: n2.getUTCMilliseconds()};
}
function Ki(t2, e2, n2) {
  return zi(pr(t2), e2, n2);
}
function Ji(t2, e2) {
  const n2 = t2.o, r2 = t2.c.year + Math.trunc(e2.years), s2 = t2.c.month + Math.trunc(e2.months) + 3 * Math.trunc(e2.quarters), i2 = {...t2.c, year: r2, month: s2, day: Math.min(t2.c.day, mr(r2, s2)) + Math.trunc(e2.days) + 7 * Math.trunc(e2.weeks)}, a2 = hi.fromObject({years: e2.years - Math.trunc(e2.years), quarters: e2.quarters - Math.trunc(e2.quarters), months: e2.months - Math.trunc(e2.months), weeks: e2.weeks - Math.trunc(e2.weeks), days: e2.days - Math.trunc(e2.days), hours: e2.hours, minutes: e2.minutes, seconds: e2.seconds, milliseconds: e2.milliseconds}).as("milliseconds"), o2 = pr(i2);
  let [u2, c2] = zi(o2, n2, t2.zone);
  return a2 !== 0 && (u2 += a2, c2 = t2.zone.offset(u2)), {ts: u2, o: c2};
}
function Yi(t2, e2, n2, r2, s2, i2) {
  const {setZone: a2, zone: o2} = n2;
  if (t2 && Object.keys(t2).length !== 0) {
    const r3 = e2 || o2, s3 = la.fromObject(t2, {...n2, zone: r3, specificOffset: i2});
    return a2 ? s3 : s3.setZone(o2);
  }
  return la.invalid(new Rr("unparsable", `the input "${s2}" can't be parsed as ${r2}`));
}
function Qi(t2, e2, n2 = true) {
  return t2.isValid ? Fr.create(ys.create("en-US"), {allowZ: n2, forceSimple: true}).formatDateTimeFromString(t2, e2) : null;
}
function Xi(t2, e2) {
  const n2 = t2.c.year > 9999 || t2.c.year < 0;
  let r2 = "";
  return n2 && t2.c.year >= 0 && (r2 += "+"), r2 += or(t2.c.year, n2 ? 6 : 4), e2 ? (r2 += "-", r2 += or(t2.c.month), r2 += "-", r2 += or(t2.c.day)) : (r2 += or(t2.c.month), r2 += or(t2.c.day)), r2;
}
function ta(t2, e2, n2, r2, s2, i2) {
  let a2 = or(t2.c.hour);
  return e2 ? (a2 += ":", a2 += or(t2.c.minute), t2.c.second === 0 && n2 || (a2 += ":")) : a2 += or(t2.c.minute), t2.c.second === 0 && n2 || (a2 += or(t2.c.second), t2.c.millisecond === 0 && r2 || (a2 += ".", a2 += or(t2.c.millisecond, 3))), s2 && (t2.isOffsetFixed && t2.offset === 0 && !i2 ? a2 += "Z" : t2.o < 0 ? (a2 += "-", a2 += or(Math.trunc(-t2.o / 60)), a2 += ":", a2 += or(Math.trunc(-t2.o % 60))) : (a2 += "+", a2 += or(Math.trunc(t2.o / 60)), a2 += ":", a2 += or(Math.trunc(t2.o % 60)))), i2 && (a2 += "[" + t2.zone.ianaName + "]"), a2;
}
const ea = {month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0}, na = {weekNumber: 1, weekday: 1, hour: 0, minute: 0, second: 0, millisecond: 0}, ra = {ordinal: 1, hour: 0, minute: 0, second: 0, millisecond: 0}, sa = ["year", "month", "day", "hour", "minute", "second", "millisecond"], ia = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"], aa = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function oa(t2) {
  const e2 = {year: "year", years: "year", month: "month", months: "month", day: "day", days: "day", hour: "hour", hours: "hour", minute: "minute", minutes: "minute", quarter: "quarter", quarters: "quarter", second: "second", seconds: "second", millisecond: "millisecond", milliseconds: "millisecond", weekday: "weekday", weekdays: "weekday", weeknumber: "weekNumber", weeksnumber: "weekNumber", weeknumbers: "weekNumber", weekyear: "weekYear", weekyears: "weekYear", ordinal: "ordinal"}[t2.toLowerCase()];
  if (!e2)
    throw new kn(t2);
  return e2;
}
function ua(t2, e2) {
  const n2 = Qr(e2.zone, is.defaultZone), r2 = ys.fromObject(e2), s2 = is.now();
  let i2, a2;
  if (tr(t2.year))
    i2 = s2;
  else {
    for (const e4 of sa)
      tr(t2[e4]) && (t2[e4] = ea[e4]);
    const e3 = Ri(t2) || Bi(t2);
    if (e3)
      return la.invalid(e3);
    const r3 = n2.offset(s2);
    [i2, a2] = Ki(t2, r3, n2);
  }
  return new la({ts: i2, zone: n2, loc: r2, o: a2});
}
function ca(t2, e2, n2) {
  const r2 = !!tr(n2.round) || n2.round, s2 = (t3, s3) => (t3 = lr(t3, r2 || n2.calendary ? 0 : 2, true), e2.loc.clone(n2).relFormatter(n2).format(t3, s3)), i2 = (r3) => n2.calendary ? e2.hasSame(t2, r3) ? 0 : e2.startOf(r3).diff(t2.startOf(r3), r3).get(r3) : e2.diff(t2, r3).get(r3);
  if (n2.unit)
    return s2(i2(n2.unit), n2.unit);
  for (const t3 of n2.units) {
    const e3 = i2(t3);
    if (Math.abs(e3) >= 1)
      return s2(e3, t3);
  }
  return s2(t2 > e2 ? -0 : 0, n2.units[n2.units.length - 1]);
}
function ha(t2) {
  let e2, n2 = {};
  return t2.length > 0 && typeof t2[t2.length - 1] == "object" ? (n2 = t2[t2.length - 1], e2 = Array.from(t2).slice(0, t2.length - 1)) : e2 = Array.from(t2), [n2, e2];
}
class la {
  constructor(t2) {
    const e2 = t2.zone || is.defaultZone;
    let n2 = t2.invalid || (Number.isNaN(t2.ts) ? new Rr("invalid input") : null) || (e2.isValid ? null : Gi(e2));
    this.ts = tr(t2.ts) ? is.now() : t2.ts;
    let r2 = null, s2 = null;
    if (!n2)
      if (t2.old && t2.old.ts === this.ts && t2.old.zone.equals(e2))
        [r2, s2] = [t2.old.c, t2.old.o];
      else {
        const t3 = e2.offset(this.ts);
        r2 = Vi(this.ts, t3), n2 = Number.isNaN(r2.year) ? new Rr("invalid input") : null, r2 = n2 ? null : r2, s2 = n2 ? null : t3;
      }
    this.nt = e2, this.loc = t2.loc || ys.create(), this.invalid = n2, this.weekData = null, this.c = r2, this.o = s2, this.isLuxonDateTime = true;
  }
  static now() {
    return new la({});
  }
  static local() {
    const [t2, e2] = ha(arguments), [n2, r2, s2, i2, a2, o2, u2] = e2;
    return ua({year: n2, month: r2, day: s2, hour: i2, minute: a2, second: o2, millisecond: u2}, t2);
  }
  static utc() {
    const [t2, e2] = ha(arguments), [n2, r2, s2, i2, a2, o2, u2] = e2;
    return t2.zone = Jr.utcInstance, ua({year: n2, month: r2, day: s2, hour: i2, minute: a2, second: o2, millisecond: u2}, t2);
  }
  static fromJSDate(t2, e2 = {}) {
    const n2 = Object.prototype.toString.call(t2) === "[object Date]" ? t2.valueOf() : NaN;
    if (Number.isNaN(n2))
      return la.invalid("invalid input");
    const r2 = Qr(e2.zone, is.defaultZone);
    return r2.isValid ? new la({ts: n2, zone: r2, loc: ys.fromObject(e2)}) : la.invalid(Gi(r2));
  }
  static fromMillis(t2, e2 = {}) {
    if (er(t2))
      return t2 < -864e13 || t2 > 864e13 ? la.invalid("Timestamp out of range") : new la({ts: t2, zone: Qr(e2.zone, is.defaultZone), loc: ys.fromObject(e2)});
    throw new Tn(`fromMillis requires a numerical input, but received a ${typeof t2} with value ${t2}`);
  }
  static fromSeconds(t2, e2 = {}) {
    if (er(t2))
      return new la({ts: 1e3 * t2, zone: Qr(e2.zone, is.defaultZone), loc: ys.fromObject(e2)});
    throw new Tn("fromSeconds requires a numerical input");
  }
  static fromObject(t2, e2 = {}) {
    t2 = t2 || {};
    const n2 = Qr(e2.zone, is.defaultZone);
    if (!n2.isValid)
      return la.invalid(Gi(n2));
    const r2 = is.now(), s2 = tr(e2.specificOffset) ? n2.offset(r2) : e2.specificOffset, i2 = xr(t2, oa), a2 = !tr(i2.ordinal), o2 = !tr(i2.year), u2 = !tr(i2.month) || !tr(i2.day), c2 = o2 || u2, h2 = i2.weekYear || i2.weekNumber, l2 = ys.fromObject(e2);
    if ((c2 || a2) && h2)
      throw new Mn("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    if (u2 && a2)
      throw new Mn("Can't mix ordinal dates with month/day");
    const d2 = h2 || i2.weekday && !c2;
    let f2, m2, p2 = Vi(r2, s2);
    d2 ? (f2 = ia, m2 = na, p2 = Ci(p2)) : a2 ? (f2 = aa, m2 = ra, p2 = ji(p2)) : (f2 = sa, m2 = ea);
    let y2 = false;
    for (const t3 of f2)
      tr(i2[t3]) ? i2[t3] = y2 ? m2[t3] : p2[t3] : y2 = true;
    const w2 = (d2 ? function(t3) {
      const e3 = nr(t3.weekYear), n3 = ar(t3.weekNumber, 1, yr(t3.weekYear)), r3 = ar(t3.weekday, 1, 7);
      return e3 ? n3 ? !r3 && $i("weekday", t3.weekday) : $i("week", t3.week) : $i("weekYear", t3.weekYear);
    }(i2) : a2 ? function(t3) {
      const e3 = nr(t3.year), n3 = ar(t3.ordinal, 1, fr(t3.year));
      return e3 ? !n3 && $i("ordinal", t3.ordinal) : $i("year", t3.year);
    }(i2) : Ri(i2)) || Bi(i2);
    if (w2)
      return la.invalid(w2);
    const g2 = d2 ? Pi(i2) : a2 ? Fi(i2) : i2, [v2, b2] = Ki(g2, s2, n2), x2 = new la({ts: v2, zone: n2, o: b2, loc: l2});
    return i2.weekday && c2 && t2.weekday !== x2.weekday ? la.invalid("mismatched weekday", `you can't specify both a weekday of ${i2.weekday} and a date of ${x2.toISO()}`) : x2;
  }
  static fromISO(t2, e2 = {}) {
    const [n2, r2] = function(t3) {
      return vs(t3, [Ws, Ks], [qs, Js], [zs, Ys], [Vs, Qs]);
    }(t2);
    return Yi(n2, r2, e2, "ISO 8601", t2);
  }
  static fromRFC2822(t2, e2 = {}) {
    const [n2, r2] = function(t3) {
      return vs(function(t4) {
        return t4.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
      }(t3), [Ps, js]);
    }(t2);
    return Yi(n2, r2, e2, "RFC 2822", t2);
  }
  static fromHTTP(t2, e2 = {}) {
    const [n2, r2] = function(t3) {
      return vs(t3, [Fs, Hs], [Rs, Hs], [Bs, Gs]);
    }(t2);
    return Yi(n2, r2, e2, "HTTP", e2);
  }
  static fromFormat(t2, e2, n2 = {}) {
    if (tr(t2) || tr(e2))
      throw new Tn("fromFormat requires an input string and a format");
    const {locale: r2 = null, numberingSystem: s2 = null} = n2, i2 = ys.fromOpts({locale: r2, numberingSystem: s2, defaultToEN: true}), [a2, o2, u2, c2] = function(t3, e3, n3) {
      const {result: r3, zone: s3, specificOffset: i3, invalidReason: a3} = Ii(t3, e3, n3);
      return [r3, s3, i3, a3];
    }(i2, t2, e2);
    return c2 ? la.invalid(c2) : Yi(a2, o2, n2, `format ${e2}`, t2, u2);
  }
  static fromString(t2, e2, n2 = {}) {
    return la.fromFormat(t2, e2, n2);
  }
  static fromSQL(t2, e2 = {}) {
    const [n2, r2] = function(t3) {
      return vs(t3, [ti, Ks], [ei, ni]);
    }(t2);
    return Yi(n2, r2, e2, "SQL", t2);
  }
  static invalid(t2, e2 = null) {
    if (!t2)
      throw new Tn("need to specify a reason the DateTime is invalid");
    const n2 = t2 instanceof Rr ? t2 : new Rr(t2, e2);
    if (is.throwOnInvalid)
      throw new En(n2);
    return new la({invalid: n2});
  }
  static isDateTime(t2) {
    return t2 && t2.isLuxonDateTime || false;
  }
  static parseFormatForOpts(t2, e2 = {}) {
    const n2 = Zi(t2, ys.fromObject(e2));
    return n2 ? n2.map((t3) => t3 ? t3.val : null).join("") : null;
  }
  get(t2) {
    return this[t2];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this.nt;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? Wi(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? Wi(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? Wi(this).weekday : NaN;
  }
  get ordinal() {
    return this.isValid ? ji(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? fi.months("short", {locObj: this.loc})[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? fi.months("long", {locObj: this.loc})[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? fi.weekdays("short", {locObj: this.loc})[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? fi.weekdays("long", {locObj: this.loc})[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {format: "short", locale: this.locale}) : null;
  }
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {format: "long", locale: this.locale}) : null;
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    return !this.isOffsetFixed && (this.offset > this.set({month: 1, day: 1}).offset || this.offset > this.set({month: 5}).offset);
  }
  get isInLeapYear() {
    return dr(this.year);
  }
  get daysInMonth() {
    return mr(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? fr(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? yr(this.weekYear) : NaN;
  }
  resolvedLocaleOptions(t2 = {}) {
    const {locale: e2, numberingSystem: n2, calendar: r2} = Fr.create(this.loc.clone(t2), t2).resolvedOptions(this);
    return {locale: e2, numberingSystem: n2, outputCalendar: r2};
  }
  toUTC(t2 = 0, e2 = {}) {
    return this.setZone(Jr.instance(t2), e2);
  }
  toLocal() {
    return this.setZone(is.defaultZone);
  }
  setZone(t2, {keepLocalTime: e2 = false, keepCalendarTime: n2 = false} = {}) {
    if ((t2 = Qr(t2, is.defaultZone)).equals(this.zone))
      return this;
    if (t2.isValid) {
      let r2 = this.ts;
      if (e2 || n2) {
        const e3 = t2.offset(this.ts), n3 = this.toObject();
        [r2] = Ki(n3, e3, t2);
      }
      return qi(this, {ts: r2, zone: t2});
    }
    return la.invalid(Gi(t2));
  }
  reconfigure({locale: t2, numberingSystem: e2, outputCalendar: n2} = {}) {
    return qi(this, {loc: this.loc.clone({locale: t2, numberingSystem: e2, outputCalendar: n2})});
  }
  setLocale(t2) {
    return this.reconfigure({locale: t2});
  }
  set(t2) {
    if (!this.isValid)
      return this;
    const e2 = xr(t2, oa), n2 = !tr(e2.weekYear) || !tr(e2.weekNumber) || !tr(e2.weekday), r2 = !tr(e2.ordinal), s2 = !tr(e2.year), i2 = !tr(e2.month) || !tr(e2.day);
    if ((s2 || i2 || r2) && (e2.weekYear || e2.weekNumber))
      throw new Mn("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    if (i2 && r2)
      throw new Mn("Can't mix ordinal dates with month/day");
    let a2;
    n2 ? a2 = Pi({...Ci(this.c), ...e2}) : tr(e2.ordinal) ? (a2 = {...this.toObject(), ...e2}, tr(e2.day) && (a2.day = Math.min(mr(a2.year, a2.month), a2.day))) : a2 = Fi({...ji(this.c), ...e2});
    const [o2, u2] = Ki(a2, this.o, this.zone);
    return qi(this, {ts: o2, o: u2});
  }
  plus(t2) {
    return this.isValid ? qi(this, Ji(this, hi.fromDurationLike(t2))) : this;
  }
  minus(t2) {
    return this.isValid ? qi(this, Ji(this, hi.fromDurationLike(t2).negate())) : this;
  }
  startOf(t2) {
    if (!this.isValid)
      return this;
    const e2 = {}, n2 = hi.normalizeUnit(t2);
    switch (n2) {
      case "years":
        e2.month = 1;
      case "quarters":
      case "months":
        e2.day = 1;
      case "weeks":
      case "days":
        e2.hour = 0;
      case "hours":
        e2.minute = 0;
      case "minutes":
        e2.second = 0;
      case "seconds":
        e2.millisecond = 0;
    }
    if (n2 === "weeks" && (e2.weekday = 1), n2 === "quarters") {
      const t3 = Math.ceil(this.month / 3);
      e2.month = 3 * (t3 - 1) + 1;
    }
    return this.set(e2);
  }
  endOf(t2) {
    return this.isValid ? this.plus({[t2]: 1}).startOf(t2).minus(1) : this;
  }
  toFormat(t2, e2 = {}) {
    return this.isValid ? Fr.create(this.loc.redefaultToEN(e2)).formatDateTimeFromString(this, t2) : Hi;
  }
  toLocaleString(t2 = Dn, e2 = {}) {
    return this.isValid ? Fr.create(this.loc.clone(e2), t2).formatDateTime(this) : Hi;
  }
  toLocaleParts(t2 = {}) {
    return this.isValid ? Fr.create(this.loc.clone(t2), t2).formatDateTimeParts(this) : [];
  }
  toISO({format: t2 = "extended", suppressSeconds: e2 = false, suppressMilliseconds: n2 = false, includeOffset: r2 = true, extendedZone: s2 = false} = {}) {
    if (!this.isValid)
      return null;
    const i2 = t2 === "extended";
    let a2 = Xi(this, i2);
    return a2 += "T", a2 += ta(this, i2, e2, n2, r2, s2), a2;
  }
  toISODate({format: t2 = "extended"} = {}) {
    return this.isValid ? Xi(this, t2 === "extended") : null;
  }
  toISOWeekDate() {
    return Qi(this, "kkkk-'W'WW-c");
  }
  toISOTime({suppressMilliseconds: t2 = false, suppressSeconds: e2 = false, includeOffset: n2 = true, includePrefix: r2 = false, extendedZone: s2 = false, format: i2 = "extended"} = {}) {
    return this.isValid ? (r2 ? "T" : "") + ta(this, i2 === "extended", e2, t2, n2, s2) : null;
  }
  toRFC2822() {
    return Qi(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  toHTTP() {
    return Qi(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    return this.isValid ? Xi(this, true) : null;
  }
  toSQLTime({includeOffset: t2 = true, includeZone: e2 = false, includeOffsetSpace: n2 = true} = {}) {
    let r2 = "HH:mm:ss.SSS";
    return (e2 || t2) && (n2 && (r2 += " "), e2 ? r2 += "z" : t2 && (r2 += "ZZ")), Qi(this, r2, true);
  }
  toSQL(t2 = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(t2)}` : null;
  }
  toString() {
    return this.isValid ? this.toISO() : Hi;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(t2 = {}) {
    if (!this.isValid)
      return {};
    const e2 = {...this.c};
    return t2.includeConfig && (e2.outputCalendar = this.outputCalendar, e2.numberingSystem = this.loc.numberingSystem, e2.locale = this.loc.locale), e2;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(t2, e2 = "milliseconds", n2 = {}) {
    if (!this.isValid || !t2.isValid)
      return hi.invalid("created by diffing an invalid DateTime");
    const r2 = {locale: this.locale, numberingSystem: this.numberingSystem, ...n2}, s2 = (o2 = e2, Array.isArray(o2) ? o2 : [o2]).map(hi.normalizeUnit), i2 = t2.valueOf() > this.valueOf(), a2 = function(t3, e3, n3, r3) {
      let [s3, i3, a3, o3] = function(t4, e4, n4) {
        const r4 = [["years", (t5, e5) => e5.year - t5.year], ["quarters", (t5, e5) => e5.quarter - t5.quarter], ["months", (t5, e5) => e5.month - t5.month + 12 * (e5.year - t5.year)], ["weeks", (t5, e5) => {
          const n5 = mi(t5, e5);
          return (n5 - n5 % 7) / 7;
        }], ["days", mi]], s4 = {};
        let i4, a4;
        for (const [o4, u3] of r4)
          if (n4.indexOf(o4) >= 0) {
            i4 = o4;
            let n5 = u3(t4, e4);
            a4 = t4.plus({[o4]: n5}), a4 > e4 ? (t4 = t4.plus({[o4]: n5 - 1}), n5 -= 1) : t4 = a4, s4[o4] = n5;
          }
        return [t4, s4, a4, i4];
      }(t3, e3, n3);
      const u2 = e3 - s3, c2 = n3.filter((t4) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(t4) >= 0);
      c2.length === 0 && (a3 < e3 && (a3 = s3.plus({[o3]: 1})), a3 !== s3 && (i3[o3] = (i3[o3] || 0) + u2 / (a3 - s3)));
      const h2 = hi.fromObject(i3, r3);
      return c2.length > 0 ? hi.fromMillis(u2, r3).shiftTo(...c2).plus(h2) : h2;
    }(i2 ? this : t2, i2 ? t2 : this, s2, r2);
    var o2;
    return i2 ? a2.negate() : a2;
  }
  diffNow(t2 = "milliseconds", e2 = {}) {
    return this.diff(la.now(), t2, e2);
  }
  until(t2) {
    return this.isValid ? di.fromDateTimes(this, t2) : this;
  }
  hasSame(t2, e2) {
    if (!this.isValid)
      return false;
    const n2 = t2.valueOf(), r2 = this.setZone(t2.zone, {keepLocalTime: true});
    return r2.startOf(e2) <= n2 && n2 <= r2.endOf(e2);
  }
  equals(t2) {
    return this.isValid && t2.isValid && this.valueOf() === t2.valueOf() && this.zone.equals(t2.zone) && this.loc.equals(t2.loc);
  }
  toRelative(t2 = {}) {
    if (!this.isValid)
      return null;
    const e2 = t2.base || la.fromObject({}, {zone: this.zone}), n2 = t2.padding ? this < e2 ? -t2.padding : t2.padding : 0;
    let r2 = ["years", "months", "days", "hours", "minutes", "seconds"], s2 = t2.unit;
    return Array.isArray(t2.unit) && (r2 = t2.unit, s2 = void 0), ca(e2, this.plus(n2), {...t2, numeric: "always", units: r2, unit: s2});
  }
  toRelativeCalendar(t2 = {}) {
    return this.isValid ? ca(t2.base || la.fromObject({}, {zone: this.zone}), this, {...t2, numeric: "auto", units: ["years", "months", "days"], calendary: true}) : null;
  }
  static min(...t2) {
    if (!t2.every(la.isDateTime))
      throw new Tn("min requires all arguments be DateTimes");
    return sr(t2, (t3) => t3.valueOf(), Math.min);
  }
  static max(...t2) {
    if (!t2.every(la.isDateTime))
      throw new Tn("max requires all arguments be DateTimes");
    return sr(t2, (t3) => t3.valueOf(), Math.max);
  }
  static fromFormatExplain(t2, e2, n2 = {}) {
    const {locale: r2 = null, numberingSystem: s2 = null} = n2;
    return Ii(ys.fromOpts({locale: r2, numberingSystem: s2, defaultToEN: true}), t2, e2);
  }
  static fromStringExplain(t2, e2, n2 = {}) {
    return la.fromFormatExplain(t2, e2, n2);
  }
  static get DATE_SHORT() {
    return Dn;
  }
  static get DATE_MED() {
    return $n;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return On;
  }
  static get DATE_FULL() {
    return Ln;
  }
  static get DATE_HUGE() {
    return Un;
  }
  static get TIME_SIMPLE() {
    return Cn;
  }
  static get TIME_WITH_SECONDS() {
    return Pn;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return jn;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return Fn;
  }
  static get TIME_24_SIMPLE() {
    return Rn;
  }
  static get TIME_24_WITH_SECONDS() {
    return Bn;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return Hn;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return Gn;
  }
  static get DATETIME_SHORT() {
    return Wn;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return qn;
  }
  static get DATETIME_MED() {
    return zn;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return Vn;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return Kn;
  }
  static get DATETIME_FULL() {
    return Jn;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return Yn;
  }
  static get DATETIME_HUGE() {
    return Qn;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return Xn;
  }
}
function da(t2) {
  if (la.isDateTime(t2))
    return t2;
  if (t2 && t2.valueOf && er(t2.valueOf()))
    return la.fromJSDate(t2);
  if (t2 && typeof t2 == "object")
    return la.fromObject(t2);
  throw new Tn(`Unknown datetime argument: ${t2}, of type ${typeof t2}`);
}
var fa, ma = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global$1 != "undefined" ? global$1 : typeof self != "undefined" ? self : {}, pa = ma && ma.rt || (fa = function(t2, e2) {
  return (fa = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(t3, e3) {
    t3.__proto__ = e3;
  } || function(t3, e3) {
    for (var n2 in e3)
      e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
  })(t2, e2);
}, function(t2, e2) {
  function n2() {
    this.constructor = t2;
  }
  fa(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
}), ya = function() {
  function t2(t3) {
    t3 === void 0 && (t3 = "="), this.st = t3;
  }
  return t2.prototype.encodedLength = function(t3) {
    return this.st ? (t3 + 2) / 3 * 4 | 0 : (8 * t3 + 5) / 6 | 0;
  }, t2.prototype.encode = function(t3) {
    for (var e2 = "", n2 = 0; n2 < t3.length - 2; n2 += 3)
      e2 += this.it((r2 = t3[n2] << 16 | t3[n2 + 1] << 8 | t3[n2 + 2]) >>> 18 & 63), e2 += this.it(r2 >>> 12 & 63), e2 += this.it(r2 >>> 6 & 63), e2 += this.it(r2 >>> 0 & 63);
    var r2, s2 = t3.length - n2;
    return s2 > 0 && (e2 += this.it((r2 = t3[n2] << 16 | (s2 === 2 ? t3[n2 + 1] << 8 : 0)) >>> 18 & 63), e2 += this.it(r2 >>> 12 & 63), e2 += s2 === 2 ? this.it(r2 >>> 6 & 63) : this.st || "", e2 += this.st || ""), e2;
  }, t2.prototype.maxDecodedLength = function(t3) {
    return this.st ? t3 / 4 * 3 | 0 : (6 * t3 + 7) / 8 | 0;
  }, t2.prototype.decodedLength = function(t3) {
    return this.maxDecodedLength(t3.length - this.at(t3));
  }, t2.prototype.decode = function(t3) {
    if (t3.length === 0)
      return new Uint8Array(0);
    for (var e2 = this.at(t3), n2 = t3.length - e2, r2 = new Uint8Array(this.maxDecodedLength(n2)), s2 = 0, i2 = 0, a2 = 0, o2 = 0, u2 = 0, c2 = 0, h2 = 0; i2 < n2 - 4; i2 += 4)
      o2 = this.ot(t3.charCodeAt(i2 + 0)), u2 = this.ot(t3.charCodeAt(i2 + 1)), c2 = this.ot(t3.charCodeAt(i2 + 2)), h2 = this.ot(t3.charCodeAt(i2 + 3)), r2[s2++] = o2 << 2 | u2 >>> 4, r2[s2++] = u2 << 4 | c2 >>> 2, r2[s2++] = c2 << 6 | h2, a2 |= 256 & o2, a2 |= 256 & u2, a2 |= 256 & c2, a2 |= 256 & h2;
    if (i2 < n2 - 1 && (o2 = this.ot(t3.charCodeAt(i2)), u2 = this.ot(t3.charCodeAt(i2 + 1)), r2[s2++] = o2 << 2 | u2 >>> 4, a2 |= 256 & o2, a2 |= 256 & u2), i2 < n2 - 2 && (c2 = this.ot(t3.charCodeAt(i2 + 2)), r2[s2++] = u2 << 4 | c2 >>> 2, a2 |= 256 & c2), i2 < n2 - 3 && (h2 = this.ot(t3.charCodeAt(i2 + 3)), r2[s2++] = c2 << 6 | h2, a2 |= 256 & h2), a2 !== 0)
      throw new Error("Base64Coder: incorrect characters for decoding");
    return r2;
  }, t2.prototype.it = function(t3) {
    var e2 = t3;
    return e2 += 65, e2 += 25 - t3 >>> 8 & 6, e2 += 51 - t3 >>> 8 & -75, e2 += 61 - t3 >>> 8 & -15, e2 += 62 - t3 >>> 8 & 3, String.fromCharCode(e2);
  }, t2.prototype.ot = function(t3) {
    var e2 = 256;
    return e2 += (42 - t3 & t3 - 44) >>> 8 & -256 + t3 - 43 + 62, e2 += (46 - t3 & t3 - 48) >>> 8 & -256 + t3 - 47 + 63, e2 += (47 - t3 & t3 - 58) >>> 8 & -256 + t3 - 48 + 52, (e2 += (64 - t3 & t3 - 91) >>> 8 & -256 + t3 - 65 + 0) + ((96 - t3 & t3 - 123) >>> 8 & -256 + t3 - 97 + 26);
  }, t2.prototype.at = function(t3) {
    var e2 = 0;
    if (this.st) {
      for (var n2 = t3.length - 1; n2 >= 0 && t3[n2] === this.st; n2--)
        e2++;
      if (t3.length < 4 || e2 > 2)
        throw new Error("Base64Coder: incorrect padding");
    }
    return e2;
  }, t2;
}(), wa = new ya();
new (function(t2) {
  function e2() {
    return t2 !== null && t2.apply(this, arguments) || this;
  }
  return pa(e2, t2), e2.prototype.it = function(t3) {
    var e3 = t3;
    return e3 += 65, e3 += 25 - t3 >>> 8 & 6, e3 += 51 - t3 >>> 8 & -75, e3 += 61 - t3 >>> 8 & -13, e3 += 62 - t3 >>> 8 & 49, String.fromCharCode(e3);
  }, e2.prototype.ot = function(t3) {
    var e3 = 256;
    return e3 += (44 - t3 & t3 - 46) >>> 8 & -256 + t3 - 45 + 62, e3 += (94 - t3 & t3 - 96) >>> 8 & -256 + t3 - 95 + 63, e3 += (47 - t3 & t3 - 58) >>> 8 & -256 + t3 - 48 + 52, (e3 += (64 - t3 & t3 - 91) >>> 8 & -256 + t3 - 65 + 0) + ((96 - t3 & t3 - 123) >>> 8 & -256 + t3 - 97 + 26);
  }, e2;
}(ya))();
var ga, va = (function(t2, e2) {
  function n2(t3) {
    return e2.ISO_3166_ALPHA_2.indexOf(t3) != -1;
  }
  Object.defineProperty(e2, "l", {value: true}), e2.getIso3166CountryName = e2.isIso3166Alpha2Code = e2.ISO_3166_ALPHA_2 = e2.ISO_3166_ALPHA_2_MAPPINGS = void 0, e2.ISO_3166_ALPHA_2_MAPPINGS = {AD: "Andorra", AE: "United Arab Emirates", AF: "Afghanistan", AG: "Antigua and Barbuda", AI: "Anguilla", AL: "Albania", AM: "Armenia", AO: "Angola", AQ: "Antarctica", AR: "Argentina", AS: "American Samoa", AT: "Austria", AU: "Australia", AW: "Aruba", AX: "\xC5land Islands", AZ: "Azerbaijan", BA: "Bosnia and Herzegovina", BB: "Barbados", BD: "Bangladesh", BE: "Belgium", BF: "Burkina Faso", BG: "Bulgaria", BH: "Bahrain", BI: "Burundi", BJ: "Benin", BL: "Saint Barth\xC3\xA9lemy", BM: "Bermuda", BN: "Brunei Darussalam", BO: "Bolivia (Plurinational State of)", BQ: "Bonaire, Sint Eustatius and Saba", BR: "Brazil", BS: "Bahamas", BT: "Bhutan", BV: "Bouvet Island", BW: "Botswana", BY: "Belarus", BZ: "Belize", CA: "Canada", CC: "Cocos (Keeling) Islands", CD: "Congo, Democratic Republic of the", CF: "Central African Republic", CG: "Congo", CH: "Switzerland", CI: "C\xF3te d'Ivoire", CK: "Cook Islands", CL: "Chile", CM: "Cameroon", CN: "China", CO: "Colombia", CR: "Costa Rica", CU: "Cuba", CV: "Cabo Verde", CW: "Cura\xC3\xA7ao", CX: "Christmas Island", CY: "Cyprus", CZ: "Czechia", DE: "Germany", DJ: "Djibouti", DK: "Denmark", DM: "Dominica", DO: "Dominican Republic", DZ: "Algeria", EC: "Ecuador", EE: "Estonia", EG: "Egypt", EH: "Western Sahara", ER: "Eritrea", ES: "Spain", ET: "Ethiopia", FI: "Finland", FJ: "Fiji", FK: "Falkland Islands (Malvinas)", FM: "Micronesia (Federated States of)", FO: "Faroe Islands", FR: "France", GA: "Gabon", GB: "United Kingdom of Great Britain and Northern Ireland", GD: "Grenada", GE: "Georgia", GF: "French Guiana", GG: "Guernsey", GH: "Ghana", GI: "Gibraltar", GL: "Greenland", GM: "Gambia", GN: "Guinea", GP: "Guadeloupe", GQ: "Equatorial Guinea", GR: "Greece", GS: "South Georgia and the South Sandwich Islands", GT: "Guatemala", GU: "Guam", GW: "Guinea-Bissau", GY: "Guyana", HK: "Hong Kong", HM: "Heard Island and McDonald Islands", HN: "Honduras", HR: "Croatia", HT: "Haiti", HU: "Hungary", ID: "Indonesia", IE: "Ireland", IL: "Israel", IM: "Isle of Man", IN: "India", IO: "British Indian Ocean Territory", IQ: "Iraq", IR: "Iran (Islamic Republic of)", IS: "Iceland", IT: "Italy", JE: "Jersey", JM: "Jamaica", JO: "Jordan", JP: "Japan", KE: "Kenya", KG: "Kyrgyzstan", KH: "Cambodia", KI: "Kiribati", KM: "Comoros", KN: "Saint Kitts and Nevis", KP: "Korea (Democratic People's Republic of) ", KR: "Korea, Republic of", KW: "Kuwait", KY: "Cayman Islands", KZ: "Kazakhstan", LA: "Lao People's Democratic Republic", LB: "Lebanon", LC: "Saint Lucia", LI: "Liechtenstein", LK: "Sri Lanka", LR: "Liberia", LS: "Lesotho", LT: "Lithuania", LU: "Luxembourg", LV: "Latvia", LY: "Libya", MA: "Morocco", MC: "Monaco", MD: "Moldova, Republic of", ME: "Montenegro", MF: "Saint Martin (French part)", MG: "Madagascar", MH: "Marshall Islands", MK: "North Macedonia", ML: "Mali", MM: "Myanmar", MN: "Mongolia", MO: "Macao", MP: "Northern Mariana Islands", MQ: "Martinique", MR: "Mauritania", MS: "Montserrat", MT: "Malta", MU: "Mauritius", MV: "Maldives", MW: "Malawi", MX: "Mexico", MY: "Malaysia", MZ: "Mozambique", NA: "Namibia", NC: "New Caledonia", NE: "Niger", NF: "Norfolk Island", NG: "Nigeria", NI: "Nicaragua", NL: "Netherlands", NO: "Norway", NP: "Nepal", NR: "Nauru", NU: "Niue", NZ: "New Zealand", OM: "Oman", PA: "Panama", PE: "Peru", PF: "French Polynesia", PG: "Papua New Guinea", PH: "Philippines", PK: "Pakistan", PL: "Poland", PM: "Saint Pierre and Miquelon", PN: "Pitcairn", PR: "Puerto Rico", PS: "Palestine, State of", PT: "Portugal", PW: "Palau", PY: "Paraguay", QA: "Qatar", RE: "R\xE9union", RO: "Romania", RS: "Serbia", RU: "Russian Federation", RW: "Rwanda", SA: "Saudi Arabia", SB: "Solomon Islands", SC: "Seychelles", SD: "Sudan", SE: "Sweden", SG: "Singapore", SH: "Saint Helena, Ascension and Tristan da Cunha", SI: "Slovenia", SJ: "Svalbard and Jan Mayen", SK: "Slovakia", SL: "Sierra Leone", SM: "San Marino", SN: "Senegal", SO: "Somalia", SR: "Suriname", SS: "South Sudan", ST: "Sao Tome and Principe", SV: "El Salvador", SX: "Sint Maarten (Dutch part)", SY: "Syrian Arab Republic", SZ: "Eswatini", TC: "Turks and Caicos Islands", TD: "Chad", TF: "French Southern Territories", TG: "Togo", TH: "Thailand", TJ: "Tajikistan", TK: "Tokelau", TL: "Timor-Leste", TM: "Turkmenistan", TN: "Tunisia", TO: "Tonga", TR: "Turkey", TT: "Trinidad and Tobago", TV: "Tuvalu", TW: "Taiwan, Province of China", TZ: "Tanzania, United Republic of", UA: "Ukraine", UG: "Uganda", UM: "United States Minor Outlying Islands", US: "United States of America", UY: "Uruguay", UZ: "Uzbekistan", VA: "Holy See", VC: "Saint Vincent and the Grenadines", VE: "Venezuela (Bolivarian Republic of)", VG: "Virgin Islands (British)", VI: "Virgin Islands (U.S.)", VN: "Viet Nam", VU: "Vanuatu", WF: "Wallis and Futuna", WS: "Samoa", XK: "Kosovo", YE: "Yemen", YT: "Mayotte", ZA: "South Africa", ZM: "Zambia", ZW: "Zimbabwe"}, e2.ISO_3166_ALPHA_2 = Object.keys(e2.ISO_3166_ALPHA_2_MAPPINGS), e2.isIso3166Alpha2Code = n2, e2.getIso3166CountryName = function(t3) {
    if (n2(t3))
      return e2.ISO_3166_ALPHA_2_MAPPINGS[t3];
  };
}(ga = {exports: {}}, ga.exports), ga.exports);
const ba = bn.string().regex(/^(([a-f0-9]{2}){32})$/i), xa = bn.string().regex(/^(([a-f0-9]{2}){20,64})$/i), Ea = bn.string().regex(/^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$/), Na = bn.union([bn.literal("sha1"), bn.literal("sha-256"), bn.literal("sha-384"), bn.literal("sha-512")]), Sa = bn.union([bn.literal("sha224"), bn.literal("sha256"), bn.literal("sha384"), bn.literal("sha512"), bn.literal("sha512_256"), bn.literal("sha3_224"), bn.literal("sha3_256"), bn.literal("sha3_384"), bn.literal("sha3_512")]), Ma = bn.union([bn.literal("bitcoin"), bn.literal("ethereum"), bn.literal("stellar"), bn.literal("twitter")]), ka = bn.union([bn.literal("development"), bn.literal("staging"), bn.literal("production")]), Ta = bn.object({minBytes: bn.number().min(20).max(64), maxBytes: bn.number().min(20).max(64)});
bn.record(bn.string(), Ta);
const _a = bn.string().refine((t2) => {
  try {
    return ((t3) => {
      try {
        return ee(t3), true;
      } catch (t4) {
        return false;
      }
    })(t2);
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid Truestamp Id string"}), Ia = bn.string().refine((t2) => {
  try {
    return function(t3) {
      wa.decode(t3);
    }(t2), true;
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid Base64 encoded string"}), Za = bn.string().refine((t2) => {
  try {
    return la.fromISO(t2).isValid;
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid ISO8601 timestamp"}), Aa = bn.string().refine((t2) => {
  try {
    if (!t2.endsWith("Z") && !t2.endsWith("+00:00"))
      return false;
    const e2 = la.fromISO(t2, {zone: "utc"});
    return e2.isValid && e2.offsetNameShort === "UTC";
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid ISO8601 UTC timestamp"}), Da = bn.string().length(2).refine((t2) => {
  try {
    return va.isIso3166Alpha2Code(t2);
  } catch (t3) {
    return false;
  }
}, {message: "is not an ISO3166 Alpha 2 country code"}), $a = bn.object({streetNo: bn.optional(bn.string().min(1).max(8)), streetName: bn.optional(bn.string().min(1).max(64)), streetType: bn.optional(bn.string().min(1).max(16)), floor: bn.optional(bn.string().min(1).max(8)), town: bn.optional(bn.string().min(1).max(64)), region: bn.optional(bn.string().min(1).max(64)), postcode: bn.optional(bn.string().min(1).max(16)), countryCode: bn.optional(Da)}), Oa = bn.string().refine((t2) => {
  try {
    if (!/^[-+]?[0-9]*\.?[0-9]+$/.test(t2))
      return false;
    const e2 = parseFloat(t2);
    return e2 >= -90 && e2 <= 90;
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid Latitude"}), La = bn.string().refine((t2) => {
  try {
    if (!/^[-+]?[0-9]*\.?[0-9]+$/.test(t2))
      return false;
    const e2 = parseFloat(t2);
    return e2 >= -180 && e2 <= 180;
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid Longitude"}), Ua = bn.object({latitude: Oa, longitude: La}), Ca = bn.object({coordinate: Ua, altitude: bn.optional(bn.number().int().min(-1e5).max(1e5)), ellipsoidalAltitude: bn.optional(bn.number().int().min(-1e5).max(1e5)), floor: bn.optional(bn.number().int().min(0).max(200)), horizontalAccuracy: bn.optional(bn.number().int().min(-1e5).max(1e5)), verticalAccuracy: bn.optional(bn.number().int().min(-1e5).max(1e5)), timestamp: bn.optional(Za), speed: bn.optional(bn.number().int().min(-1e5).max(1e5)), speedAccuracy: bn.optional(bn.number().int().min(-1e4).max(1e4)), course: bn.optional(bn.number().int().min(-360).max(360)), courseAccuracy: bn.optional(bn.number().int().min(-360).max(360)), magneticHeading: bn.optional(bn.number().int().min(0).max(359)), headingAccuracy: bn.optional(bn.number().int().min(-180).max(180)), trueHeading: bn.optional(bn.number().int().min(0).max(359))}), Pa = bn.object({givenName: bn.optional(bn.string().min(1).max(32)), surname: bn.optional(bn.string().min(1).max(32)), organizationName: bn.optional(bn.string().min(1).max(64)), roles: bn.optional(bn.array(bn.string()).min(1).max(32)), email: bn.optional(bn.string().email()), uri: bn.optional(bn.string().url()), address: bn.optional($a)}), ja = bn.object({publicKey: Ia, signature: Ia, signatureType: bn.literal("ed25519"), signer: bn.optional(Pa)}), Fa = bn.object({asn: bn.optional(bn.nullable(bn.union([bn.number().int(), bn.string()]))), colo: bn.optional(bn.nullable(bn.string().min(1))), country: bn.optional(bn.nullable(bn.string().min(1))), city: bn.optional(bn.nullable(bn.string().min(1))), continent: bn.optional(bn.nullable(bn.string().min(1))), latitude: bn.optional(bn.nullable(bn.string().min(1))), longitude: bn.optional(bn.nullable(bn.string().min(1))), postalCode: bn.optional(bn.nullable(bn.string().min(1))), metroCode: bn.optional(bn.nullable(bn.string().min(1))), region: bn.optional(bn.nullable(bn.string().min(1))), regionCode: bn.optional(bn.nullable(bn.string().min(1))), timezone: bn.optional(bn.nullable(bn.string().min(1)))}), Ra = bn.union([bn.string(), bn.number(), bn.boolean(), bn.null()]), Ba = bn.lazy(() => bn.union([Ra, bn.array(Ba), bn.record(Ba)])), Ha = bn.object({hash: xa, hashType: Na, people: bn.optional(bn.array(Pa).min(1)), description: bn.optional(bn.string().min(1).max(256)), address: bn.optional($a), location: bn.optional(Ca), timestamp: bn.optional(Za), extra: bn.optional(Ba)}), Ga = bn.object({cf: bn.optional(Fa), observableEntropy: bn.optional(ba), submittedAt: Aa}), Wa = bn.object({itemData: bn.array(Ha).min(1), itemSignals: bn.optional(Ga), itemDataSignatures: bn.optional(bn.array(ja).min(1))}), qa = Wa.pick({itemData: true, itemDataSignatures: true});
bn.object({id: _a}), bn.object({owner: bn.string().min(1).max(255), ulid: Ea, item: Wa}), bn.object({owner: bn.optional(bn.string().min(1)), inputHash: ba});
const za = bn.tuple([bn.number().int().min(0).max(1), xa]), Va = bn.object({v: bn.number().int().min(1).max(1), h: Sa, p: bn.array(za)}), Ka = bn.object({inputHash: ba, inclusionProof: Va, merkleRoot: ba}), Ja = bn.object({inputHash: ba}), Ya = Ja.extend({intent: bn.literal("bitcoin"), hash: bn.string().regex(/(0x)?[0-9a-f]+/i)}).strict(), Qa = Ja.extend({intent: bn.literal("ethereum"), hash: bn.string().regex(/(0x)?[0-9a-f]+/i)}).strict(), Xa = Ja.extend({intent: bn.literal("stellar"), hash: ba, ledger: bn.number().int().min(11111)}).strict(), to = Ja.extend({intent: bn.literal("twitter"), id: bn.string().regex(/[0-9]+/i)}).strict(), eo = bn.discriminatedUnion("intent", [Ya, Qa, Xa, to]), no = bn.object({id: _a, itemData: bn.array(Ha).min(1), itemDataSignatures: bn.optional(bn.array(ja).min(1)), itemSignals: bn.optional(Ga), proofs: bn.array(Ka), transactions: bn.record(bn.string(), bn.array(eo).min(1))});
bn.object({commitmentData: no, commitmentDataSignatures: bn.array(ja).min(1)});
const ro = bn.object({t: bn.number(), ts: Aa, ulid: Ea});
bn.array(ro);
const so = bn.object({inputHash: ba, merkleRoot: ba}).strict(), io = bn.object({intent: Ma, verified: bn.boolean(), transaction: eo, timestamp: bn.optional(Aa), urls: bn.optional(bn.object({machine: bn.optional(bn.array(bn.string().url())), human: bn.optional(bn.array(bn.string().url()))})), error: bn.optional(bn.string())}).strict();
bn.object({verified: bn.boolean(), id: bn.optional(_a), idData: bn.optional(bn.object({test: bn.boolean(), timestamp: bn.string(), ulid: Ea})), itemData: bn.optional(bn.object({hash: ba, hashType: Na, signaturesCount: bn.optional(bn.number().int())})), item: bn.optional(bn.object({hash: ba, hashType: bn.literal("sha-256")})), commitmentData: bn.optional(bn.object({hash: ba, hashType: bn.literal("sha-256"), signaturesCount: bn.optional(bn.number().int())})), proofs: bn.optional(bn.array(so).min(1)), transactions: bn.optional(bn.array(io).min(1)), commitsTo: bn.optional(bn.object({hashes: bn.array(bn.object({hash: xa, hashType: bn.string()})).min(1), observableEntropy: bn.optional(ba), timestamps: bn.object({submittedAfter: bn.optional(Aa), submittedAt: Aa, submittedBefore: bn.optional(bn.array(bn.string())), submitWindowMilliseconds: bn.optional(bn.number().int().min(0).max(31536e6))})})), error: bn.optional(bn.string())}).strict();
const ao = bn.object({environment: ka, expired: bn.boolean(), handle: bn.string().min(1), publicKey: Ia, type: bn.literal("ed25519"), selfSignature: Ia});
bn.array(ao).min(1), ao.omit({selfSignature: true}), bn.object({hash: bn.instanceof(Uint8Array), hashHex: ba, hashType: Na, canonicalData: bn.optional(bn.string())});
const oo = bn.object({name: bn.string(), hash: ba, hashType: bn.literal("sha256")});
bn.object({hash: ba, hashType: bn.literal("sha256"), hashIterations: bn.number().int().min(1), createdAt: Aa, signature: Ia, prevHash: bn.optional(ba), files: bn.optional(bn.array(oo).min(1))});
class uo extends s {
}
var co;
co = uo, [class extends s {
  getCommitment(t2) {
    return ee(t2), this.request(`commitments/${t2}`);
  }
  getCommitmentVerification(t2) {
    return ee(t2), this.request(`commitments/${t2}/verify`);
  }
}, class extends s {
  getHealth() {
    return this.request("health");
  }
}, class extends s {
  createItem(t2) {
    const e2 = qa.parse(t2);
    return this.request("items", {method: "POST", body: JSON.stringify(e2)});
  }
  updateItem(t2, e2) {
    ee(t2);
    let n2 = `items/${t2}`;
    const r2 = qa.parse(e2);
    return this.request(n2, {method: "PUT", body: JSON.stringify(r2)});
  }
}, class extends s {
  createApiKey(t2) {
    return this.request("apikeys", {method: "POST", body: JSON.stringify(t2)});
  }
}].forEach((t2) => {
  Object.getOwnPropertyNames(t2.prototype).forEach((e2) => {
    Object.defineProperty(co.prototype, e2, Object.getOwnPropertyDescriptor(t2.prototype, e2));
  });
});
export default uo;
