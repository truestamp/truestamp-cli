var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
function t() {
  return (t = Object.assign || function(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var n2 = arguments[e2];
      for (var r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (t2[r2] = n2[r2]);
    }
    return t2;
  }).apply(this, arguments);
}
function e(t2, e2) {
  t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, r(t2, e2);
}
function n(t2) {
  return (n = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  })(t2);
}
function r(t2, e2) {
  return (r = Object.setPrototypeOf || function(t3, e3) {
    return t3.__proto__ = e3, t3;
  })(t2, e2);
}
function i() {
  if (typeof Reflect == "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy == "function")
    return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch (t2) {
    return false;
  }
}
function s(t2, e2, n2) {
  return (s = i() ? Reflect.construct : function(t3, e3, n3) {
    var i2 = [null];
    i2.push.apply(i2, e3);
    var s2 = new (Function.bind.apply(t3, i2))();
    return n3 && r(s2, n3.prototype), s2;
  }).apply(null, arguments);
}
function a(t2) {
  var e2 = typeof Map == "function" ? new Map() : void 0;
  return (a = function(t3) {
    if (t3 === null || Function.toString.call(t3).indexOf("[native code]") === -1)
      return t3;
    if (typeof t3 != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (e2 !== void 0) {
      if (e2.has(t3))
        return e2.get(t3);
      e2.set(t3, i2);
    }
    function i2() {
      return s(t3, arguments, n(this).constructor);
    }
    return i2.prototype = Object.create(t3.prototype, {constructor: {value: i2, enumerable: false, writable: true, configurable: true}}), r(i2, t3);
  })(t2);
}
var u, o, c = {__proto__: null, default: function(t2, e2) {
  return e2 = e2 || {}, new Promise(function(n2, r2) {
    var i2 = new XMLHttpRequest(), s2 = [], a2 = [], u2 = {}, o2 = function() {
      return {ok: (i2.status / 100 | 0) == 2, statusText: i2.statusText, status: i2.status, url: i2.responseURL, text: function() {
        return Promise.resolve(i2.responseText);
      }, json: function() {
        return Promise.resolve(i2.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([i2.response]));
      }, clone: o2, headers: {keys: function() {
        return s2;
      }, entries: function() {
        return a2;
      }, get: function(t3) {
        return u2[t3.toLowerCase()];
      }, has: function(t3) {
        return t3.toLowerCase() in u2;
      }}};
    };
    for (var c2 in i2.open(e2.method || "get", t2, true), i2.onload = function() {
      i2.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(t3, e3, n3) {
        s2.push(e3 = e3.toLowerCase()), a2.push([e3, n3]), u2[e3] = u2[e3] ? u2[e3] + "," + n3 : n3;
      }), n2(o2());
    }, i2.onerror = r2, i2.withCredentials = e2.credentials == "include", e2.headers)
      i2.setRequestHeader(c2, e2.headers[c2]);
    i2.send(e2.body || null);
  });
}}, h = self.fetch || (self.fetch = c.default || c), d = /* @__PURE__ */ function(t2) {
  function n2(e2) {
    var n3;
    return (n3 = t2.call.apply(t2, [this, e2.status + " " + e2.statusText].concat([].slice.call(arguments, 1))) || this).response = void 0, n3.response = e2, n3;
  }
  return e(n2, t2), n2;
}(/* @__PURE__ */ a(Error)), l = /* @__PURE__ */ function() {
  function e2(t2) {
    this.apiKey = void 0, this.apiEnv = void 0, this.apiKey = t2.apiKey, this.apiEnv = t2.apiEnv || "production";
  }
  return e2.prototype.request = function(e3, n2) {
    try {
      var r2 = function(t2) {
        var e4 = {development: "https://dev-api.truestamp.com/v1/", staging: "https://staging-api.truestamp.com/v1/", production: "https://api.truestamp.com/v1/"}[t2];
        if (!e4)
          throw new Error("Unknown environment: " + t2);
        return e4;
      }(this.apiEnv) + e3, i2 = t({}, n2, {headers: {Authorization: "Bearer " + this.apiKey, "Content-Type": "application/json", Accept: "application/json"}});
      return Promise.resolve(h(r2, i2)).then(function(t2) {
        return function(t3) {
          if (t3.ok)
            return t3;
          throw new d(t3);
        }(t2), Promise.resolve(t2.json()).then(function(t3) {
          return new Promise(function(e4) {
            e4(t3);
          });
        });
      });
    } catch (t2) {
      return Promise.reject(t2);
    }
  }, e2;
}();
(o = u || (u = {})).assertNever = function(t2) {
  throw new Error();
}, o.arrayToEnum = (t2) => {
  const e2 = {};
  for (const n2 of t2)
    e2[n2] = n2;
  return e2;
}, o.getValidEnumValues = (t2) => {
  const e2 = o.objectKeys(t2).filter((e3) => typeof t2[t2[e3]] != "number"), n2 = {};
  for (const r2 of e2)
    n2[r2] = t2[r2];
  return o.objectValues(n2);
}, o.objectValues = (t2) => o.objectKeys(t2).map(function(e2) {
  return t2[e2];
}), o.objectKeys = typeof Object.keys == "function" ? (t2) => Object.keys(t2) : (t2) => {
  const e2 = [];
  for (const n2 in t2)
    Object.prototype.hasOwnProperty.call(t2, n2) && e2.push(n2);
  return e2;
}, o.find = (t2, e2) => {
  for (const n2 of t2)
    if (e2(n2))
      return n2;
}, o.isInteger = typeof Number.isInteger == "function" ? (t2) => Number.isInteger(t2) : (t2) => typeof t2 == "number" && isFinite(t2) && Math.floor(t2) === t2, o.joinValues = function(t2, e2 = " | ") {
  return t2.map((t3) => typeof t3 == "string" ? `'${t3}'` : t3).join(e2);
};
var f = u.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), m = (t2) => {
  switch (typeof t2) {
    case "undefined":
      return f.undefined;
    case "string":
      return f.string;
    case "number":
      return isNaN(t2) ? f.nan : f.number;
    case "boolean":
      return f.boolean;
    case "function":
      return f.function;
    case "bigint":
      return f.bigint;
    case "object":
      return Array.isArray(t2) ? f.array : t2 === null ? f.null : t2.then && typeof t2.then == "function" && t2.catch && typeof t2.catch == "function" ? f.promise : typeof Map != "undefined" && t2 instanceof Map ? f.map : typeof Set != "undefined" && t2 instanceof Set ? f.set : typeof Date != "undefined" && t2 instanceof Date ? f.date : f.object;
    default:
      return f.unknown;
  }
}, v = u.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of"]), y = class extends Error {
  constructor(t2) {
    super(), this.issues = [], this.addIssue = (t3) => {
      this.issues = [...this.issues, t3];
    }, this.addIssues = (t3 = []) => {
      this.issues = [...this.issues, ...t3];
    };
    const e2 = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, e2) : this.__proto__ = e2, this.name = "ZodError", this.issues = t2;
  }
  get errors() {
    return this.issues;
  }
  format(t2) {
    const e2 = t2 || function(t3) {
      return t3.message;
    }, n2 = {i: []}, r2 = (t3) => {
      for (const i2 of t3.issues)
        if (i2.code === "invalid_union")
          i2.unionErrors.map(r2);
        else if (i2.code === "invalid_return_type")
          r2(i2.returnTypeError);
        else if (i2.code === "invalid_arguments")
          r2(i2.argumentsError);
        else if (i2.path.length === 0)
          n2.i.push(e2(i2));
        else {
          let t4 = n2, r3 = 0;
          for (; r3 < i2.path.length; ) {
            const n3 = i2.path[r3];
            r3 === i2.path.length - 1 ? (t4[n3] = t4[n3] || {i: []}, t4[n3].i.push(e2(i2))) : t4[n3] = t4[n3] || {i: []}, t4 = t4[n3], r3++;
          }
        }
    };
    return r2(this), n2;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, null, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t2 = (t3) => t3.message) {
    const e2 = {}, n2 = [];
    for (const r2 of this.issues)
      r2.path.length > 0 ? (e2[r2.path[0]] = e2[r2.path[0]] || [], e2[r2.path[0]].push(t2(r2))) : n2.push(t2(r2));
    return {formErrors: n2, fieldErrors: e2};
  }
  get formErrors() {
    return this.flatten();
  }
};
y.create = (t2) => new y(t2);
var p = (t2, e2) => {
  let n2;
  switch (t2.code) {
    case v.invalid_type:
      n2 = t2.received === f.undefined ? "Required" : `Expected ${t2.expected}, received ${t2.received}`;
      break;
    case v.invalid_literal:
      n2 = `Invalid literal value, expected ${JSON.stringify(t2.expected)}`;
      break;
    case v.unrecognized_keys:
      n2 = `Unrecognized key(s) in object: ${u.joinValues(t2.keys, ", ")}`;
      break;
    case v.invalid_union:
      n2 = "Invalid input";
      break;
    case v.invalid_union_discriminator:
      n2 = `Invalid discriminator value. Expected ${u.joinValues(t2.options)}`;
      break;
    case v.invalid_enum_value:
      n2 = `Invalid enum value. Expected ${u.joinValues(t2.options)}, received '${t2.received}'`;
      break;
    case v.invalid_arguments:
      n2 = "Invalid function arguments";
      break;
    case v.invalid_return_type:
      n2 = "Invalid function return type";
      break;
    case v.invalid_date:
      n2 = "Invalid date";
      break;
    case v.invalid_string:
      n2 = t2.validation !== "regex" ? `Invalid ${t2.validation}` : "Invalid";
      break;
    case v.too_small:
      n2 = t2.type === "array" ? `Array must contain ${t2.inclusive ? "at least" : "more than"} ${t2.minimum} element(s)` : t2.type === "string" ? `String must contain ${t2.inclusive ? "at least" : "over"} ${t2.minimum} character(s)` : t2.type === "number" ? `Number must be greater than ${t2.inclusive ? "or equal to " : ""}${t2.minimum}` : "Invalid input";
      break;
    case v.too_big:
      n2 = t2.type === "array" ? `Array must contain ${t2.inclusive ? "at most" : "less than"} ${t2.maximum} element(s)` : t2.type === "string" ? `String must contain ${t2.inclusive ? "at most" : "under"} ${t2.maximum} character(s)` : t2.type === "number" ? `Number must be less than ${t2.inclusive ? "or equal to " : ""}${t2.maximum}` : "Invalid input";
      break;
    case v.custom:
      n2 = "Invalid input";
      break;
    case v.invalid_intersection_types:
      n2 = "Intersection results could not be merged";
      break;
    case v.not_multiple_of:
      n2 = `Number must be a multiple of ${t2.multipleOf}`;
      break;
    default:
      n2 = e2.defaultError, u.assertNever(t2);
  }
  return {message: n2};
}, g = p, w = (t2) => {
  const {data: e2, path: n2, errorMaps: r2, issueData: i2} = t2, s2 = [...n2, ...i2.path || []], a2 = {...i2, path: s2};
  let u2 = "";
  const o2 = r2.filter((t3) => !!t3).slice().reverse();
  for (const t3 of o2)
    u2 = t3(a2, {data: e2, defaultError: u2}).message;
  return {...i2, path: s2, message: i2.message || u2};
};
function b(t2, e2) {
  const n2 = w({issueData: e2, data: t2.data, path: t2.path, errorMaps: [t2.common.contextualErrorMap, t2.schemaErrorMap, g, p].filter((t3) => !!t3)});
  t2.common.issues.push(n2);
}
var k, N, M = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t2, e2) {
    const n2 = [];
    for (const r2 of e2) {
      if (r2.status === "aborted")
        return x;
      r2.status === "dirty" && t2.dirty(), n2.push(r2.value);
    }
    return {status: t2.value, value: n2};
  }
  static async mergeObjectAsync(t2, e2) {
    const n2 = [];
    for (const t3 of e2)
      n2.push({key: await t3.key, value: await t3.value});
    return M.mergeObjectSync(t2, n2);
  }
  static mergeObjectSync(t2, e2) {
    const n2 = {};
    for (const r2 of e2) {
      const {key: e3, value: i2} = r2;
      if (e3.status === "aborted")
        return x;
      if (i2.status === "aborted")
        return x;
      e3.status === "dirty" && t2.dirty(), i2.status === "dirty" && t2.dirty(), (i2.value !== void 0 || r2.alwaysSet) && (n2[e3.value] = i2.value);
    }
    return {status: t2.value, value: n2};
  }
}, x = Object.freeze({status: "aborted"}), E = (t2) => ({status: "valid", value: t2}), S = (t2) => t2.status === "aborted", T = (t2) => t2.status === "dirty", _ = (t2) => t2.status === "valid", I = (t2) => typeof Promise !== void 0 && t2 instanceof Promise;
(N = k || (k = {})).errToObj = (t2) => typeof t2 == "string" ? {message: t2} : t2 || {}, N.toString = (t2) => typeof t2 == "string" ? t2 : t2 == null ? void 0 : t2.message;
var Z = class {
  constructor(t2, e2, n2, r2) {
    this.parent = t2, this.data = e2, this.l = n2, this.m = r2;
  }
  get path() {
    return this.l.concat(this.m);
  }
}, A = (t2, e2) => {
  if (_(e2))
    return {success: true, data: e2.value};
  if (!t2.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {success: false, error: new y(t2.common.issues)};
};
function D(t2) {
  if (!t2)
    return {};
  const {errorMap: e2, invalid_type_error: n2, required_error: r2, description: i2} = t2;
  if (e2 && (n2 || r2))
    throw new Error(`Can't use "invalid" or "required" in conjunction with custom error map.`);
  return e2 ? {errorMap: e2, description: i2} : {errorMap: (e3, n3) => e3.code !== "invalid_type" ? {message: n3.defaultError} : n3.data === void 0 && r2 ? {message: r2} : t2.invalid_type_error ? {message: t2.invalid_type_error} : {message: n3.defaultError}, description: i2};
}
var O = class {
  constructor(t2) {
    this.spa = this.safeParseAsync, this.superRefine = this.g, this.k = t2, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.default = this.default.bind(this), this.describe = this.describe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this.k.description;
  }
  N(t2) {
    return m(t2.data);
  }
  _(t2, e2) {
    return e2 || {common: t2.parent.common, data: t2.data, parsedType: m(t2.data), schemaErrorMap: this.k.errorMap, path: t2.path, parent: t2.parent};
  }
  I(t2) {
    return {status: new M(), ctx: {common: t2.parent.common, data: t2.data, parsedType: m(t2.data), schemaErrorMap: this.k.errorMap, path: t2.path, parent: t2.parent}};
  }
  O(t2) {
    const e2 = this.P(t2);
    if (I(e2))
      throw new Error("Synchronous parse encountered promise.");
    return e2;
  }
  L(t2) {
    const e2 = this.P(t2);
    return Promise.resolve(e2);
  }
  parse(t2, e2) {
    const n2 = this.safeParse(t2, e2);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  safeParse(t2, e2) {
    var n2;
    const r2 = {common: {issues: [], async: (n2 = e2 == null ? void 0 : e2.async) !== null && n2 !== void 0 && n2, contextualErrorMap: e2 == null ? void 0 : e2.errorMap}, path: (e2 == null ? void 0 : e2.path) || [], schemaErrorMap: this.k.errorMap, parent: null, data: t2, parsedType: m(t2)}, i2 = this.O({data: t2, path: r2.path, parent: r2});
    return A(r2, i2);
  }
  async parseAsync(t2, e2) {
    const n2 = await this.safeParseAsync(t2, e2);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  async safeParseAsync(t2, e2) {
    const n2 = {common: {issues: [], contextualErrorMap: e2 == null ? void 0 : e2.errorMap, async: true}, path: (e2 == null ? void 0 : e2.path) || [], schemaErrorMap: this.k.errorMap, parent: null, data: t2, parsedType: m(t2)}, r2 = this.P({data: t2, path: [], parent: n2}), i2 = await (I(r2) ? r2 : Promise.resolve(r2));
    return A(n2, i2);
  }
  refine(t2, e2) {
    const n2 = (t3) => typeof e2 == "string" || e2 === void 0 ? {message: e2} : typeof e2 == "function" ? e2(t3) : e2;
    return this.g((e3, r2) => {
      const i2 = t2(e3), s2 = () => r2.addIssue({code: v.custom, ...n2(e3)});
      return typeof Promise != "undefined" && i2 instanceof Promise ? i2.then((t3) => !!t3 || (s2(), false)) : !!i2 || (s2(), false);
    });
  }
  refinement(t2, e2) {
    return this.g((n2, r2) => !!t2(n2) || (r2.addIssue(typeof e2 == "function" ? e2(n2, r2) : e2), false));
  }
  g(t2) {
    return new mt({schema: this, typeName: wt.ZodEffects, effect: {type: "refinement", refinement: t2}});
  }
  optional() {
    return vt.create(this);
  }
  nullable() {
    return yt.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return W.create(this);
  }
  promise() {
    return ft.create(this);
  }
  or(t2) {
    return tt.create([this, t2]);
  }
  and(t2) {
    return rt.create(this, t2);
  }
  transform(t2) {
    return new mt({schema: this, typeName: wt.ZodEffects, effect: {type: "transform", transform: t2}});
  }
  default(t2) {
    return new pt({innerType: this, defaultValue: typeof t2 == "function" ? t2 : () => t2, typeName: wt.ZodDefault});
  }
  describe(t2) {
    return new this.constructor({...this.k, description: t2});
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}, P = /^c[^\s-]{8,}$/i, C = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, L = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i, U = class extends O {
  constructor() {
    super(...arguments), this.U = (t2, e2, n2) => this.refinement((e3) => t2.test(e3), {validation: e2, code: v.invalid_string, ...k.errToObj(n2)}), this.nonempty = (t2) => this.min(1, k.errToObj(t2)), this.trim = () => new U({...this.k, checks: [...this.k.checks, {kind: "trim"}]});
  }
  P(t2) {
    if (this.N(t2) !== f.string) {
      const e3 = this._(t2);
      return b(e3, {code: v.invalid_type, expected: f.string, received: e3.parsedType}), x;
    }
    const e2 = new M();
    let n2;
    for (const r2 of this.k.checks)
      if (r2.kind === "min")
        t2.data.length < r2.value && (n2 = this._(t2, n2), b(n2, {code: v.too_small, minimum: r2.value, type: "string", inclusive: true, message: r2.message}), e2.dirty());
      else if (r2.kind === "max")
        t2.data.length > r2.value && (n2 = this._(t2, n2), b(n2, {code: v.too_big, maximum: r2.value, type: "string", inclusive: true, message: r2.message}), e2.dirty());
      else if (r2.kind === "email")
        L.test(t2.data) || (n2 = this._(t2, n2), b(n2, {validation: "email", code: v.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "uuid")
        C.test(t2.data) || (n2 = this._(t2, n2), b(n2, {validation: "uuid", code: v.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "cuid")
        P.test(t2.data) || (n2 = this._(t2, n2), b(n2, {validation: "cuid", code: v.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "url")
        try {
          new URL(t2.data);
        } catch (i2) {
          n2 = this._(t2, n2), b(n2, {validation: "url", code: v.invalid_string, message: r2.message}), e2.dirty();
        }
      else
        r2.kind === "regex" ? (r2.regex.lastIndex = 0, r2.regex.test(t2.data) || (n2 = this._(t2, n2), b(n2, {validation: "regex", code: v.invalid_string, message: r2.message}), e2.dirty())) : r2.kind === "trim" ? t2.data = t2.data.trim() : u.assertNever(r2);
    return {status: e2.value, value: t2.data};
  }
  j(t2) {
    return new U({...this.k, checks: [...this.k.checks, t2]});
  }
  email(t2) {
    return this.j({kind: "email", ...k.errToObj(t2)});
  }
  url(t2) {
    return this.j({kind: "url", ...k.errToObj(t2)});
  }
  uuid(t2) {
    return this.j({kind: "uuid", ...k.errToObj(t2)});
  }
  cuid(t2) {
    return this.j({kind: "cuid", ...k.errToObj(t2)});
  }
  regex(t2, e2) {
    return this.j({kind: "regex", regex: t2, ...k.errToObj(e2)});
  }
  min(t2, e2) {
    return this.j({kind: "min", value: t2, ...k.errToObj(e2)});
  }
  max(t2, e2) {
    return this.j({kind: "max", value: t2, ...k.errToObj(e2)});
  }
  length(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  get isEmail() {
    return !!this.k.checks.find((t2) => t2.kind === "email");
  }
  get isURL() {
    return !!this.k.checks.find((t2) => t2.kind === "url");
  }
  get isUUID() {
    return !!this.k.checks.find((t2) => t2.kind === "uuid");
  }
  get isCUID() {
    return !!this.k.checks.find((t2) => t2.kind === "cuid");
  }
  get minLength() {
    let t2 = -Infinity;
    return this.k.checks.map((e2) => {
      e2.kind === "min" && (t2 === null || e2.value > t2) && (t2 = e2.value);
    }), t2;
  }
  get maxLength() {
    let t2 = null;
    return this.k.checks.map((e2) => {
      e2.kind === "max" && (t2 === null || e2.value < t2) && (t2 = e2.value);
    }), t2;
  }
};
function j(t2, e2) {
  const n2 = (t2.toString().split(".")[1] || "").length, r2 = (e2.toString().split(".")[1] || "").length, i2 = n2 > r2 ? n2 : r2;
  return parseInt(t2.toFixed(i2).replace(".", "")) % parseInt(e2.toFixed(i2).replace(".", "")) / Math.pow(10, i2);
}
U.create = (t2) => new U({checks: [], typeName: wt.ZodString, ...D(t2)});
var R = class extends O {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  P(t2) {
    if (this.N(t2) !== f.number) {
      const e3 = this._(t2);
      return b(e3, {code: v.invalid_type, expected: f.number, received: e3.parsedType}), x;
    }
    let e2;
    const n2 = new M();
    for (const r2 of this.k.checks)
      r2.kind === "int" ? u.isInteger(t2.data) || (e2 = this._(t2, e2), b(e2, {code: v.invalid_type, expected: "integer", received: "float", message: r2.message}), n2.dirty()) : r2.kind === "min" ? (r2.inclusive ? t2.data < r2.value : t2.data <= r2.value) && (e2 = this._(t2, e2), b(e2, {code: v.too_small, minimum: r2.value, type: "number", inclusive: r2.inclusive, message: r2.message}), n2.dirty()) : r2.kind === "max" ? (r2.inclusive ? t2.data > r2.value : t2.data >= r2.value) && (e2 = this._(t2, e2), b(e2, {code: v.too_big, maximum: r2.value, type: "number", inclusive: r2.inclusive, message: r2.message}), n2.dirty()) : r2.kind === "multipleOf" ? j(t2.data, r2.value) !== 0 && (e2 = this._(t2, e2), b(e2, {code: v.not_multiple_of, multipleOf: r2.value, message: r2.message}), n2.dirty()) : u.assertNever(r2);
    return {status: n2.value, value: t2.data};
  }
  gte(t2, e2) {
    return this.setLimit("min", t2, true, k.toString(e2));
  }
  gt(t2, e2) {
    return this.setLimit("min", t2, false, k.toString(e2));
  }
  lte(t2, e2) {
    return this.setLimit("max", t2, true, k.toString(e2));
  }
  lt(t2, e2) {
    return this.setLimit("max", t2, false, k.toString(e2));
  }
  setLimit(t2, e2, n2, r2) {
    return new R({...this.k, checks: [...this.k.checks, {kind: t2, value: e2, inclusive: n2, message: k.toString(r2)}]});
  }
  j(t2) {
    return new R({...this.k, checks: [...this.k.checks, t2]});
  }
  int(t2) {
    return this.j({kind: "int", message: k.toString(t2)});
  }
  positive(t2) {
    return this.j({kind: "min", value: 0, inclusive: false, message: k.toString(t2)});
  }
  negative(t2) {
    return this.j({kind: "max", value: 0, inclusive: false, message: k.toString(t2)});
  }
  nonpositive(t2) {
    return this.j({kind: "max", value: 0, inclusive: true, message: k.toString(t2)});
  }
  nonnegative(t2) {
    return this.j({kind: "min", value: 0, inclusive: true, message: k.toString(t2)});
  }
  multipleOf(t2, e2) {
    return this.j({kind: "multipleOf", value: t2, message: k.toString(e2)});
  }
  get minValue() {
    let t2 = null;
    for (const e2 of this.k.checks)
      e2.kind === "min" && (t2 === null || e2.value > t2) && (t2 = e2.value);
    return t2;
  }
  get maxValue() {
    let t2 = null;
    for (const e2 of this.k.checks)
      e2.kind === "max" && (t2 === null || e2.value < t2) && (t2 = e2.value);
    return t2;
  }
  get isInt() {
    return !!this.k.checks.find((t2) => t2.kind === "int");
  }
};
R.create = (t2) => new R({checks: [], typeName: wt.ZodNumber, ...D(t2)});
var F = class extends O {
  P(t2) {
    if (this.N(t2) !== f.bigint) {
      const e2 = this._(t2);
      return b(e2, {code: v.invalid_type, expected: f.bigint, received: e2.parsedType}), x;
    }
    return E(t2.data);
  }
};
F.create = (t2) => new F({typeName: wt.ZodBigInt, ...D(t2)});
var $ = class extends O {
  P(t2) {
    if (this.N(t2) !== f.boolean) {
      const e2 = this._(t2);
      return b(e2, {code: v.invalid_type, expected: f.boolean, received: e2.parsedType}), x;
    }
    return E(t2.data);
  }
};
$.create = (t2) => new $({typeName: wt.ZodBoolean, ...D(t2)});
var B = class extends O {
  P(t2) {
    if (this.N(t2) !== f.date) {
      const e2 = this._(t2);
      return b(e2, {code: v.invalid_type, expected: f.date, received: e2.parsedType}), x;
    }
    return isNaN(t2.data.getTime()) ? (b(this._(t2), {code: v.invalid_date}), x) : {status: "valid", value: new Date(t2.data.getTime())};
  }
};
B.create = (t2) => new B({typeName: wt.ZodDate, ...D(t2)});
var G = class extends O {
  P(t2) {
    if (this.N(t2) !== f.undefined) {
      const e2 = this._(t2);
      return b(e2, {code: v.invalid_type, expected: f.undefined, received: e2.parsedType}), x;
    }
    return E(t2.data);
  }
};
G.create = (t2) => new G({typeName: wt.ZodUndefined, ...D(t2)});
var H = class extends O {
  P(t2) {
    if (this.N(t2) !== f.null) {
      const e2 = this._(t2);
      return b(e2, {code: v.invalid_type, expected: f.null, received: e2.parsedType}), x;
    }
    return E(t2.data);
  }
};
H.create = (t2) => new H({typeName: wt.ZodNull, ...D(t2)});
var K = class extends O {
  constructor() {
    super(...arguments), this.R = true;
  }
  P(t2) {
    return E(t2.data);
  }
};
K.create = (t2) => new K({typeName: wt.ZodAny, ...D(t2)});
var z = class extends O {
  constructor() {
    super(...arguments), this.$ = true;
  }
  P(t2) {
    return E(t2.data);
  }
};
z.create = (t2) => new z({typeName: wt.ZodUnknown, ...D(t2)});
var q = class extends O {
  P(t2) {
    const e2 = this._(t2);
    return b(e2, {code: v.invalid_type, expected: f.never, received: e2.parsedType}), x;
  }
};
q.create = (t2) => new q({typeName: wt.ZodNever, ...D(t2)});
var V = class extends O {
  P(t2) {
    if (this.N(t2) !== f.undefined) {
      const e2 = this._(t2);
      return b(e2, {code: v.invalid_type, expected: f.void, received: e2.parsedType}), x;
    }
    return E(t2.data);
  }
};
V.create = (t2) => new V({typeName: wt.ZodVoid, ...D(t2)});
var J, W = class extends O {
  P(t2) {
    const {ctx: e2, status: n2} = this.I(t2), r2 = this.k;
    if (e2.parsedType !== f.array)
      return b(e2, {code: v.invalid_type, expected: f.array, received: e2.parsedType}), x;
    if (r2.minLength !== null && e2.data.length < r2.minLength.value && (b(e2, {code: v.too_small, minimum: r2.minLength.value, type: "array", inclusive: true, message: r2.minLength.message}), n2.dirty()), r2.maxLength !== null && e2.data.length > r2.maxLength.value && (b(e2, {code: v.too_big, maximum: r2.maxLength.value, type: "array", inclusive: true, message: r2.maxLength.message}), n2.dirty()), e2.common.async)
      return Promise.all(e2.data.map((t3, n3) => r2.type.L(new Z(e2, t3, e2.path, n3)))).then((t3) => M.mergeArray(n2, t3));
    const i2 = e2.data.map((t3, n3) => r2.type.O(new Z(e2, t3, e2.path, n3)));
    return M.mergeArray(n2, i2);
  }
  get element() {
    return this.k.type;
  }
  min(t2, e2) {
    return new W({...this.k, minLength: {value: t2, message: k.toString(e2)}});
  }
  max(t2, e2) {
    return new W({...this.k, maxLength: {value: t2, message: k.toString(e2)}});
  }
  length(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  nonempty(t2) {
    return this.min(1, t2);
  }
};
W.create = (t2, e2) => new W({type: t2, minLength: null, maxLength: null, typeName: wt.ZodArray, ...D(e2)}), (J || (J = {})).mergeShapes = (t2, e2) => ({...t2, ...e2});
var Y = (t2) => (e2) => new X({...t2, shape: () => ({...t2.shape(), ...e2})});
function Q(t2) {
  if (t2 instanceof X) {
    const e2 = {};
    for (const n2 in t2.shape)
      e2[n2] = vt.create(Q(t2.shape[n2]));
    return new X({...t2.k, shape: () => e2});
  }
  return t2 instanceof W ? W.create(Q(t2.element)) : t2 instanceof vt ? vt.create(Q(t2.unwrap())) : t2 instanceof yt ? yt.create(Q(t2.unwrap())) : t2 instanceof it ? it.create(t2.items.map((t3) => Q(t3))) : t2;
}
var X = class extends O {
  constructor() {
    super(...arguments), this.K = null, this.nonstrict = this.passthrough, this.augment = Y(this.k), this.extend = Y(this.k);
  }
  V() {
    if (this.K !== null)
      return this.K;
    const t2 = this.k.shape(), e2 = u.objectKeys(t2);
    return this.K = {shape: t2, keys: e2};
  }
  P(t2) {
    if (this.N(t2) !== f.object) {
      const e3 = this._(t2);
      return b(e3, {code: v.invalid_type, expected: f.object, received: e3.parsedType}), x;
    }
    const {status: e2, ctx: n2} = this.I(t2), {shape: r2, keys: i2} = this.V(), s2 = [];
    for (const t3 in n2.data)
      i2.includes(t3) || s2.push(t3);
    const a2 = [];
    for (const t3 of i2)
      a2.push({key: {status: "valid", value: t3}, value: r2[t3].P(new Z(n2, n2.data[t3], n2.path, t3)), alwaysSet: t3 in n2.data});
    if (this.k.catchall instanceof q) {
      const t3 = this.k.unknownKeys;
      if (t3 === "passthrough")
        for (const t4 of s2)
          a2.push({key: {status: "valid", value: t4}, value: {status: "valid", value: n2.data[t4]}});
      else if (t3 === "strict")
        s2.length > 0 && (b(n2, {code: v.unrecognized_keys, keys: s2}), e2.dirty());
      else if (t3 !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const t3 = this.k.catchall;
      for (const e3 of s2)
        a2.push({key: {status: "valid", value: e3}, value: t3.P(new Z(n2, n2.data[e3], n2.path, e3)), alwaysSet: e3 in n2.data});
    }
    return n2.common.async ? Promise.resolve().then(async () => {
      const t3 = [];
      for (const e3 of a2) {
        const n3 = await e3.key;
        t3.push({key: n3, value: await e3.value, alwaysSet: e3.alwaysSet});
      }
      return t3;
    }).then((t3) => M.mergeObjectSync(e2, t3)) : M.mergeObjectSync(e2, a2);
  }
  get shape() {
    return this.k.shape();
  }
  strict(t2) {
    return new X({...this.k, unknownKeys: "strict", ...t2 !== void 0 ? {errorMap: (e2, n2) => {
      var r2, i2, s2, a2;
      const u2 = (s2 = (i2 = (r2 = this.k).errorMap) === null || i2 === void 0 ? void 0 : i2.call(r2, e2, n2).message) !== null && s2 !== void 0 ? s2 : n2.defaultError;
      return e2.code === "unrecognized_keys" ? {message: (a2 = k.errToObj(t2).message) !== null && a2 !== void 0 ? a2 : u2} : {message: u2};
    }} : {}});
  }
  strip() {
    return new X({...this.k, unknownKeys: "strip"});
  }
  passthrough() {
    return new X({...this.k, unknownKeys: "passthrough"});
  }
  setKey(t2, e2) {
    return this.augment({[t2]: e2});
  }
  merge(t2) {
    return new X({unknownKeys: t2.k.unknownKeys, catchall: t2.k.catchall, shape: () => J.mergeShapes(this.k.shape(), t2.k.shape()), typeName: wt.ZodObject});
  }
  catchall(t2) {
    return new X({...this.k, catchall: t2});
  }
  pick(t2) {
    const e2 = {};
    return u.objectKeys(t2).map((t3) => {
      this.shape[t3] && (e2[t3] = this.shape[t3]);
    }), new X({...this.k, shape: () => e2});
  }
  omit(t2) {
    const e2 = {};
    return u.objectKeys(this.shape).map((n2) => {
      u.objectKeys(t2).indexOf(n2) === -1 && (e2[n2] = this.shape[n2]);
    }), new X({...this.k, shape: () => e2});
  }
  deepPartial() {
    return Q(this);
  }
  partial(t2) {
    const e2 = {};
    if (t2)
      return u.objectKeys(this.shape).map((n2) => {
        e2[n2] = u.objectKeys(t2).indexOf(n2) === -1 ? this.shape[n2] : this.shape[n2].optional();
      }), new X({...this.k, shape: () => e2});
    for (const t3 in this.shape)
      e2[t3] = this.shape[t3].optional();
    return new X({...this.k, shape: () => e2});
  }
  required() {
    const t2 = {};
    for (const e2 in this.shape) {
      let n2 = this.shape[e2];
      for (; n2 instanceof vt; )
        n2 = n2.k.innerType;
      t2[e2] = n2;
    }
    return new X({...this.k, shape: () => t2});
  }
};
X.create = (t2, e2) => new X({shape: () => t2, unknownKeys: "strip", catchall: q.create(), typeName: wt.ZodObject, ...D(e2)}), X.strictCreate = (t2, e2) => new X({shape: () => t2, unknownKeys: "strict", catchall: q.create(), typeName: wt.ZodObject, ...D(e2)}), X.lazycreate = (t2, e2) => new X({shape: t2, unknownKeys: "strip", catchall: q.create(), typeName: wt.ZodObject, ...D(e2)});
var tt = class extends O {
  P(t2) {
    const {ctx: e2} = this.I(t2), n2 = this.k.options;
    if (e2.common.async)
      return Promise.all(n2.map(async (t3) => {
        const n3 = {...e2, common: {...e2.common, issues: []}, parent: null};
        return {result: await t3.L({data: e2.data, path: e2.path, parent: n3}), ctx: n3};
      })).then(function(t3) {
        for (const e3 of t3)
          if (e3.result.status === "valid")
            return e3.result;
        for (const n4 of t3)
          if (n4.result.status === "dirty")
            return e2.common.issues.push(...n4.ctx.common.issues), n4.result;
        const n3 = t3.map((t4) => new y(t4.ctx.common.issues));
        return b(e2, {code: v.invalid_union, unionErrors: n3}), x;
      });
    {
      let t3;
      const r2 = [];
      for (const i3 of n2) {
        const n3 = {...e2, common: {...e2.common, issues: []}, parent: null}, s2 = i3.O({data: e2.data, path: e2.path, parent: n3});
        if (s2.status === "valid")
          return s2;
        s2.status !== "dirty" || t3 || (t3 = {result: s2, ctx: n3}), n3.common.issues.length && r2.push(n3.common.issues);
      }
      if (t3)
        return e2.common.issues.push(...t3.ctx.common.issues), t3.result;
      const i2 = r2.map((t4) => new y(t4));
      return b(e2, {code: v.invalid_union, unionErrors: i2}), x;
    }
  }
  get options() {
    return this.k.options;
  }
};
tt.create = (t2, e2) => new tt({options: t2, typeName: wt.ZodUnion, ...D(e2)});
var et = class extends O {
  P(t2) {
    const {ctx: e2} = this.I(t2);
    if (e2.parsedType !== f.object)
      return b(e2, {code: v.invalid_type, expected: f.object, received: e2.parsedType}), x;
    const n2 = this.discriminator, r2 = this.options.get(e2.data[n2]);
    return r2 ? e2.common.async ? r2.L({data: e2.data, path: e2.path, parent: e2}) : r2.O({data: e2.data, path: e2.path, parent: e2}) : (b(e2, {code: v.invalid_union_discriminator, options: this.validDiscriminatorValues, path: [n2]}), x);
  }
  get discriminator() {
    return this.k.discriminator;
  }
  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }
  get options() {
    return this.k.options;
  }
  static create(t2, e2, n2) {
    const r2 = /* @__PURE__ */ new Map();
    try {
      e2.forEach((e3) => {
        r2.set(e3.shape[t2].value, e3);
      });
    } catch (t3) {
      throw new Error("The discriminator value could not be extracted from all the provided schemas");
    }
    if (r2.size !== e2.length)
      throw new Error("Some of the discriminator values are not unique");
    return new et({typeName: wt.ZodDiscriminatedUnion, discriminator: t2, options: r2, ...D(n2)});
  }
};
function nt(t2, e2) {
  const n2 = m(t2), r2 = m(e2);
  if (t2 === e2)
    return {valid: true, data: t2};
  if (n2 === f.object && r2 === f.object) {
    const n3 = u.objectKeys(e2), r3 = u.objectKeys(t2).filter((t3) => n3.indexOf(t3) !== -1), i2 = {...t2, ...e2};
    for (const n4 of r3) {
      const r4 = nt(t2[n4], e2[n4]);
      if (!r4.valid)
        return {valid: false};
      i2[n4] = r4.data;
    }
    return {valid: true, data: i2};
  }
  if (n2 === f.array && r2 === f.array) {
    if (t2.length !== e2.length)
      return {valid: false};
    const n3 = [];
    for (let r3 = 0; r3 < t2.length; r3++) {
      const i2 = nt(t2[r3], e2[r3]);
      if (!i2.valid)
        return {valid: false};
      n3.push(i2.data);
    }
    return {valid: true, data: n3};
  }
  return n2 === f.date && r2 === f.date && +t2 == +e2 ? {valid: true, data: t2} : {valid: false};
}
var rt = class extends O {
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2), r2 = (t3, r3) => {
      if (S(t3) || S(r3))
        return x;
      const i2 = nt(t3.value, r3.value);
      return i2.valid ? ((T(t3) || T(r3)) && e2.dirty(), {status: e2.value, value: i2.data}) : (b(n2, {code: v.invalid_intersection_types}), x);
    };
    return n2.common.async ? Promise.all([this.k.left.L({data: n2.data, path: n2.path, parent: n2}), this.k.right.L({data: n2.data, path: n2.path, parent: n2})]).then(([t3, e3]) => r2(t3, e3)) : r2(this.k.left.O({data: n2.data, path: n2.path, parent: n2}), this.k.right.O({data: n2.data, path: n2.path, parent: n2}));
  }
};
rt.create = (t2, e2, n2) => new rt({left: t2, right: e2, typeName: wt.ZodIntersection, ...D(n2)});
var it = class extends O {
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2);
    if (n2.parsedType !== f.array)
      return b(n2, {code: v.invalid_type, expected: f.array, received: n2.parsedType}), x;
    if (n2.data.length < this.k.items.length)
      return b(n2, {code: v.too_small, minimum: this.k.items.length, inclusive: true, type: "array"}), x;
    !this.k.rest && n2.data.length > this.k.items.length && (b(n2, {code: v.too_big, maximum: this.k.items.length, inclusive: true, type: "array"}), e2.dirty());
    const r2 = n2.data.map((t3, e3) => {
      const r3 = this.k.items[e3] || this.k.rest;
      return r3 ? r3.P(new Z(n2, t3, n2.path, e3)) : null;
    }).filter((t3) => !!t3);
    return n2.common.async ? Promise.all(r2).then((t3) => M.mergeArray(e2, t3)) : M.mergeArray(e2, r2);
  }
  get items() {
    return this.k.items;
  }
  rest(t2) {
    return new it({...this.k, rest: t2});
  }
};
it.create = (t2, e2) => new it({items: t2, typeName: wt.ZodTuple, rest: null, ...D(e2)});
var st = class extends O {
  get keySchema() {
    return this.k.keyType;
  }
  get valueSchema() {
    return this.k.valueType;
  }
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2);
    if (n2.parsedType !== f.object)
      return b(n2, {code: v.invalid_type, expected: f.object, received: n2.parsedType}), x;
    const r2 = [], i2 = this.k.keyType, s2 = this.k.valueType;
    for (const t3 in n2.data)
      r2.push({key: i2.P(new Z(n2, t3, n2.path, t3)), value: s2.P(new Z(n2, n2.data[t3], n2.path, t3))});
    return n2.common.async ? M.mergeObjectAsync(e2, r2) : M.mergeObjectSync(e2, r2);
  }
  get element() {
    return this.k.valueType;
  }
  static create(t2, e2, n2) {
    return new st(e2 instanceof O ? {keyType: t2, valueType: e2, typeName: wt.ZodRecord, ...D(n2)} : {keyType: U.create(), valueType: t2, typeName: wt.ZodRecord, ...D(e2)});
  }
}, at = class extends O {
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2);
    if (n2.parsedType !== f.map)
      return b(n2, {code: v.invalid_type, expected: f.map, received: n2.parsedType}), x;
    const r2 = this.k.keyType, i2 = this.k.valueType, s2 = [...n2.data.entries()].map(([t3, e3], s3) => ({key: r2.P(new Z(n2, t3, n2.path, [s3, "key"])), value: i2.P(new Z(n2, e3, n2.path, [s3, "value"]))}));
    if (n2.common.async) {
      const t3 = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const n3 of s2) {
          const r3 = await n3.key, i3 = await n3.value;
          if (r3.status === "aborted" || i3.status === "aborted")
            return x;
          r3.status !== "dirty" && i3.status !== "dirty" || e2.dirty(), t3.set(r3.value, i3.value);
        }
        return {status: e2.value, value: t3};
      });
    }
    {
      const t3 = /* @__PURE__ */ new Map();
      for (const n3 of s2) {
        const r3 = n3.key, i3 = n3.value;
        if (r3.status === "aborted" || i3.status === "aborted")
          return x;
        r3.status !== "dirty" && i3.status !== "dirty" || e2.dirty(), t3.set(r3.value, i3.value);
      }
      return {status: e2.value, value: t3};
    }
  }
};
at.create = (t2, e2, n2) => new at({valueType: e2, keyType: t2, typeName: wt.ZodMap, ...D(n2)});
var ut = class extends O {
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2);
    if (n2.parsedType !== f.set)
      return b(n2, {code: v.invalid_type, expected: f.set, received: n2.parsedType}), x;
    const r2 = this.k;
    r2.minSize !== null && n2.data.size < r2.minSize.value && (b(n2, {code: v.too_small, minimum: r2.minSize.value, type: "set", inclusive: true, message: r2.minSize.message}), e2.dirty()), r2.maxSize !== null && n2.data.size > r2.maxSize.value && (b(n2, {code: v.too_big, maximum: r2.maxSize.value, type: "set", inclusive: true, message: r2.maxSize.message}), e2.dirty());
    const i2 = this.k.valueType;
    function s2(t3) {
      const n3 = /* @__PURE__ */ new Set();
      for (const r3 of t3) {
        if (r3.status === "aborted")
          return x;
        r3.status === "dirty" && e2.dirty(), n3.add(r3.value);
      }
      return {status: e2.value, value: n3};
    }
    const a2 = [...n2.data.values()].map((t3, e3) => i2.P(new Z(n2, t3, n2.path, e3)));
    return n2.common.async ? Promise.all(a2).then((t3) => s2(t3)) : s2(a2);
  }
  min(t2, e2) {
    return new ut({...this.k, minSize: {value: t2, message: k.toString(e2)}});
  }
  max(t2, e2) {
    return new ut({...this.k, maxSize: {value: t2, message: k.toString(e2)}});
  }
  size(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  nonempty(t2) {
    return this.min(1, t2);
  }
};
ut.create = (t2, e2) => new ut({valueType: t2, minSize: null, maxSize: null, typeName: wt.ZodSet, ...D(e2)});
var ot = class extends O {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  P(t2) {
    const {ctx: e2} = this.I(t2);
    if (e2.parsedType !== f.function)
      return b(e2, {code: v.invalid_type, expected: f.function, received: e2.parsedType}), x;
    function n2(t3, n3) {
      return w({data: t3, path: e2.path, errorMaps: [e2.common.contextualErrorMap, e2.schemaErrorMap, g, p].filter((t4) => !!t4), issueData: {code: v.invalid_arguments, argumentsError: n3}});
    }
    function r2(t3, n3) {
      return w({data: t3, path: e2.path, errorMaps: [e2.common.contextualErrorMap, e2.schemaErrorMap, g, p].filter((t4) => !!t4), issueData: {code: v.invalid_return_type, returnTypeError: n3}});
    }
    const i2 = {errorMap: e2.common.contextualErrorMap}, s2 = e2.data;
    return E(this.k.returns instanceof ft ? async (...t3) => {
      const e3 = new y([]), a2 = await this.k.args.parseAsync(t3, i2).catch((r3) => {
        throw e3.addIssue(n2(t3, r3)), e3;
      }), u2 = await s2(...a2);
      return await this.k.returns.k.type.parseAsync(u2, i2).catch((t4) => {
        throw e3.addIssue(r2(u2, t4)), e3;
      });
    } : (...t3) => {
      const e3 = this.k.args.safeParse(t3, i2);
      if (!e3.success)
        throw new y([n2(t3, e3.error)]);
      const a2 = s2(...e3.data), u2 = this.k.returns.safeParse(a2, i2);
      if (!u2.success)
        throw new y([r2(a2, u2.error)]);
      return u2.data;
    });
  }
  parameters() {
    return this.k.args;
  }
  returnType() {
    return this.k.returns;
  }
  args(...t2) {
    return new ot({...this.k, args: it.create(t2).rest(z.create())});
  }
  returns(t2) {
    return new ot({...this.k, returns: t2});
  }
  implement(t2) {
    return this.parse(t2);
  }
  strictImplement(t2) {
    return this.parse(t2);
  }
};
ot.create = (t2, e2, n2) => new ot({args: t2 ? t2.rest(z.create()) : it.create([]).rest(z.create()), returns: e2 || z.create(), typeName: wt.ZodFunction, ...D(n2)});
var ct = class extends O {
  get schema() {
    return this.k.getter();
  }
  P(t2) {
    const {ctx: e2} = this.I(t2);
    return this.k.getter().P({data: e2.data, path: e2.path, parent: e2});
  }
};
ct.create = (t2, e2) => new ct({getter: t2, typeName: wt.ZodLazy, ...D(e2)});
var ht = class extends O {
  P(t2) {
    return t2.data !== this.k.value ? (b(this._(t2), {code: v.invalid_literal, expected: this.k.value}), x) : {status: "valid", value: t2.data};
  }
  get value() {
    return this.k.value;
  }
};
ht.create = (t2, e2) => new ht({value: t2, typeName: wt.ZodLiteral, ...D(e2)});
var dt = class extends O {
  P(t2) {
    if (typeof t2.data != "string") {
      const e2 = this._(t2);
      return b(e2, {expected: u.joinValues(this.k.values), received: e2.parsedType, code: v.invalid_type}), x;
    }
    if (this.k.values.indexOf(t2.data) === -1) {
      const e2 = this._(t2);
      return b(e2, {received: e2.data, code: v.invalid_enum_value, options: this.k.values}), x;
    }
    return E(t2.data);
  }
  get options() {
    return this.k.values;
  }
  get enum() {
    const t2 = {};
    for (const e2 of this.k.values)
      t2[e2] = e2;
    return t2;
  }
  get Values() {
    const t2 = {};
    for (const e2 of this.k.values)
      t2[e2] = e2;
    return t2;
  }
  get Enum() {
    const t2 = {};
    for (const e2 of this.k.values)
      t2[e2] = e2;
    return t2;
  }
};
dt.create = function(t2, e2) {
  return new dt({values: t2, typeName: wt.ZodEnum, ...D(e2)});
};
var lt = class extends O {
  P(t2) {
    const e2 = u.getValidEnumValues(this.k.values), n2 = this._(t2);
    if (n2.parsedType !== f.string && n2.parsedType !== f.number) {
      const t3 = u.objectValues(e2);
      return b(n2, {expected: u.joinValues(t3), received: n2.parsedType, code: v.invalid_type}), x;
    }
    if (e2.indexOf(t2.data) === -1) {
      const t3 = u.objectValues(e2);
      return b(n2, {received: n2.data, code: v.invalid_enum_value, options: t3}), x;
    }
    return E(t2.data);
  }
  get enum() {
    return this.k.values;
  }
};
lt.create = (t2, e2) => new lt({values: t2, typeName: wt.ZodNativeEnum, ...D(e2)});
var ft = class extends O {
  P(t2) {
    const {ctx: e2} = this.I(t2);
    if (e2.parsedType !== f.promise && e2.common.async === false)
      return b(e2, {code: v.invalid_type, expected: f.promise, received: e2.parsedType}), x;
    const n2 = e2.parsedType === f.promise ? e2.data : Promise.resolve(e2.data);
    return E(n2.then((t3) => this.k.type.parseAsync(t3, {path: e2.path, errorMap: e2.common.contextualErrorMap})));
  }
};
ft.create = (t2, e2) => new ft({type: t2, typeName: wt.ZodPromise, ...D(e2)});
var mt = class extends O {
  innerType() {
    return this.k.schema;
  }
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2), r2 = this.k.effect || null;
    if (r2.type === "preprocess") {
      const t3 = r2.transform(n2.data);
      return n2.common.async ? Promise.resolve(t3).then((t4) => this.k.schema.L({data: t4, path: n2.path, parent: n2})) : this.k.schema.O({data: t3, path: n2.path, parent: n2});
    }
    const i2 = {addIssue: (t3) => {
      b(n2, t3), t3.fatal ? e2.abort() : e2.dirty();
    }, get path() {
      return n2.path;
    }};
    if (i2.addIssue = i2.addIssue.bind(i2), r2.type === "refinement") {
      const t3 = (t4) => {
        const e3 = r2.refinement(t4, i2);
        if (n2.common.async)
          return Promise.resolve(e3);
        if (e3 instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return t4;
      };
      if (n2.common.async === false) {
        const r3 = this.k.schema.O({data: n2.data, path: n2.path, parent: n2});
        return r3.status === "aborted" ? x : (r3.status === "dirty" && e2.dirty(), t3(r3.value), {status: e2.value, value: r3.value});
      }
      return this.k.schema.L({data: n2.data, path: n2.path, parent: n2}).then((n3) => n3.status === "aborted" ? x : (n3.status === "dirty" && e2.dirty(), t3(n3.value).then(() => ({status: e2.value, value: n3.value}))));
    }
    if (r2.type === "transform") {
      if (n2.common.async === false) {
        const t3 = this.k.schema.O({data: n2.data, path: n2.path, parent: n2});
        if (!_(t3))
          return t3;
        const s2 = r2.transform(t3.value, i2);
        if (s2 instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return {status: e2.value, value: s2};
      }
      return this.k.schema.L({data: n2.data, path: n2.path, parent: n2}).then((t3) => _(t3) ? Promise.resolve(r2.transform(t3.value, i2)).then((t4) => ({status: e2.value, value: t4})) : t3);
    }
    u.assertNever(r2);
  }
};
mt.create = (t2, e2, n2) => new mt({schema: t2, typeName: wt.ZodEffects, effect: e2, ...D(n2)}), mt.createWithPreprocess = (t2, e2, n2) => new mt({schema: e2, effect: {type: "preprocess", transform: t2}, typeName: wt.ZodEffects, ...D(n2)});
var vt = class extends O {
  P(t2) {
    return this.N(t2) === f.undefined ? E(void 0) : this.k.innerType.P(t2);
  }
  unwrap() {
    return this.k.innerType;
  }
};
vt.create = (t2, e2) => new vt({innerType: t2, typeName: wt.ZodOptional, ...D(e2)});
var yt = class extends O {
  P(t2) {
    return this.N(t2) === f.null ? E(null) : this.k.innerType.P(t2);
  }
  unwrap() {
    return this.k.innerType;
  }
};
yt.create = (t2, e2) => new yt({innerType: t2, typeName: wt.ZodNullable, ...D(e2)});
var pt = class extends O {
  P(t2) {
    const {ctx: e2} = this.I(t2);
    let n2 = e2.data;
    return e2.parsedType === f.undefined && (n2 = this.k.defaultValue()), this.k.innerType.P({data: n2, path: e2.path, parent: e2});
  }
  removeDefault() {
    return this.k.innerType;
  }
};
pt.create = (t2, e2) => new vt({innerType: t2, typeName: wt.ZodOptional, ...D(e2)});
var gt = class extends O {
  P(t2) {
    if (this.N(t2) !== f.nan) {
      const e2 = this._(t2);
      return b(e2, {code: v.invalid_type, expected: f.nan, received: e2.parsedType}), x;
    }
    return {status: "valid", value: t2.data};
  }
};
gt.create = (t2) => new gt({typeName: wt.ZodNaN, ...D(t2)});
var wt, bt, kt = (t2, e2 = {}, n2) => t2 ? K.create().superRefine((r2, i2) => {
  if (!t2(r2)) {
    const t3 = typeof e2 == "function" ? e2(r2) : e2;
    i2.addIssue({code: "custom", ...typeof t3 == "string" ? {message: t3} : t3, fatal: n2});
  }
}) : K.create(), Nt = {object: X.lazycreate};
(bt = wt || (wt = {})).ZodString = "ZodString", bt.ZodNumber = "ZodNumber", bt.ZodNaN = "ZodNaN", bt.ZodBigInt = "ZodBigInt", bt.ZodBoolean = "ZodBoolean", bt.ZodDate = "ZodDate", bt.ZodUndefined = "ZodUndefined", bt.ZodNull = "ZodNull", bt.ZodAny = "ZodAny", bt.ZodUnknown = "ZodUnknown", bt.ZodNever = "ZodNever", bt.ZodVoid = "ZodVoid", bt.ZodArray = "ZodArray", bt.ZodObject = "ZodObject", bt.ZodUnion = "ZodUnion", bt.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", bt.ZodIntersection = "ZodIntersection", bt.ZodTuple = "ZodTuple", bt.ZodRecord = "ZodRecord", bt.ZodMap = "ZodMap", bt.ZodSet = "ZodSet", bt.ZodFunction = "ZodFunction", bt.ZodLazy = "ZodLazy", bt.ZodLiteral = "ZodLiteral", bt.ZodEnum = "ZodEnum", bt.ZodEffects = "ZodEffects", bt.ZodNativeEnum = "ZodNativeEnum", bt.ZodOptional = "ZodOptional", bt.ZodNullable = "ZodNullable", bt.ZodDefault = "ZodDefault", bt.ZodPromise = "ZodPromise";
var Mt = U.create, xt = R.create, Et = $.create, St = mt.create, Tt = /* @__PURE__ */ Object.freeze({__proto__: null, getParsedType: m, ZodParsedType: f, makeIssue: w, EMPTY_PATH: [], addIssueToContext: b, ParseStatus: M, INVALID: x, DIRTY: (t2) => ({status: "dirty", value: t2}), OK: E, isAborted: S, isDirty: T, isValid: _, isAsync: I, ZodType: O, ZodString: U, ZodNumber: R, ZodBigInt: F, ZodBoolean: $, ZodDate: B, ZodUndefined: G, ZodNull: H, ZodAny: K, ZodUnknown: z, ZodNever: q, ZodVoid: V, ZodArray: W, get objectUtil() {
  return J;
}, ZodObject: X, ZodUnion: tt, ZodDiscriminatedUnion: et, ZodIntersection: rt, ZodTuple: it, ZodRecord: st, ZodMap: at, ZodSet: ut, ZodFunction: ot, ZodLazy: ct, ZodLiteral: ht, ZodEnum: dt, ZodNativeEnum: lt, ZodPromise: ft, ZodEffects: mt, ZodTransformer: mt, ZodOptional: vt, ZodNullable: yt, ZodDefault: pt, ZodNaN: gt, custom: kt, Schema: O, ZodSchema: O, late: Nt, get ZodFirstPartyTypeKind() {
  return wt;
}, any: K.create, array: W.create, bigint: F.create, boolean: Et, date: B.create, discriminatedUnion: et.create, effect: St, enum: dt.create, function: ot.create, instanceof: (t2, e2 = {message: `Input not instance of ${t2.name}`}) => kt((e3) => e3 instanceof t2, e2, true), intersection: rt.create, lazy: ct.create, literal: ht.create, map: at.create, nan: gt.create, nativeEnum: lt.create, never: q.create, null: H.create, nullable: yt.create, number: xt, object: X.create, oboolean: () => Et().optional(), onumber: () => xt().optional(), optional: vt.create, ostring: () => Mt().optional(), preprocess: mt.createWithPreprocess, promise: ft.create, record: st.create, set: ut.create, strictObject: X.strictCreate, string: Mt, transformer: St, tuple: it.create, undefined: G.create, union: tt.create, unknown: z.create, void: V.create, ZodIssueCode: v, quotelessJson: (t2) => JSON.stringify(t2, null, 2).replace(/"([^"]+)":/g, "$1:"), ZodError: y, defaultErrorMap: p, get overrideErrorMap() {
  return g;
}, setErrorMap: (t2) => {
  g = t2;
}}), _t = function(t2, e2 = true) {
  if (t2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e2 && t2.finished)
    throw new Error("Hash#digest() has already been called");
}, It = (t2) => new DataView(t2.buffer, t2.byteOffset, t2.byteLength), Zt = (t2, e2) => t2 << 32 - e2 | t2 >>> e2;
if (new Uint8Array(new Uint32Array([287454020]).buffer)[0] !== 68)
  throw new Error("Non little-endian hardware is not supported");
function At(t2) {
  if (typeof t2 == "string" && (t2 = function(t3) {
    if (typeof t3 != "string")
      throw new TypeError("utf8ToBytes expected string, got " + typeof t3);
    return new TextEncoder().encode(t3);
  }(t2)), !(t2 instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof t2})`);
  return t2;
}
Array.from({length: 256}, (t2, e2) => e2.toString(16).padStart(2, "0"));
var Dt = (t2, e2, n2) => t2 & e2 ^ t2 & n2 ^ e2 & n2, Ot = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), Pt = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), Ct = new Uint32Array(64);
!function(t2) {
  const n2 = t2();
  n2.outputLen, n2.blockLen, () => t2();
}(() => new class extends class extends class {
  clone() {
    return this.J();
  }
} {
  constructor(t2, e2, n2, r2) {
    super(), this.blockLen = t2, this.outputLen = e2, this.padOffset = n2, this.isLE = r2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t2), this.view = It(this.buffer);
  }
  update(t2) {
    _t(this);
    const {view: e2, buffer: n2, blockLen: r2} = this, i2 = (t2 = At(t2)).length;
    for (let s2 = 0; s2 < i2; ) {
      const a2 = Math.min(r2 - this.pos, i2 - s2);
      if (a2 !== r2)
        n2.set(t2.subarray(s2, s2 + a2), this.pos), this.pos += a2, s2 += a2, this.pos === r2 && (this.process(e2, 0), this.pos = 0);
      else {
        const e3 = It(t2);
        for (; r2 <= i2 - s2; s2 += r2)
          this.process(e3, s2);
      }
    }
    return this.length += t2.length, this.roundClean(), this;
  }
  digestInto(t2) {
    _t(this), function(t3, e3) {
      !function(t4, ...e4) {
        if (!(t4 instanceof Uint8Array))
          throw new TypeError("Expected Uint8Array");
        if (e4.length > 0 && !e4.includes(t4.length))
          throw new TypeError(`Expected Uint8Array of length ${e4}, not of length=${t4.length}`);
      }(t3);
      const n3 = e3.outputLen;
      if (t3.length < n3)
        throw new Error(`digestInto() expects output buffer of length at least ${n3}`);
    }(t2, this), this.finished = true;
    const {buffer: e2, view: n2, blockLen: r2, isLE: i2} = this;
    let {pos: s2} = this;
    e2[s2++] = 128, this.buffer.subarray(s2).fill(0), this.padOffset > r2 - s2 && (this.process(n2, 0), s2 = 0);
    for (let t3 = s2; t3 < r2; t3++)
      e2[t3] = 0;
    !function(t3, e3, n3, r3) {
      if (typeof t3.setBigUint64 == "function")
        return t3.setBigUint64(e3, n3, r3);
      const i3 = BigInt(32), s3 = BigInt(4294967295), a3 = Number(n3 >> i3 & s3), u2 = Number(n3 & s3), o2 = r3 ? 0 : 4;
      t3.setUint32(e3 + (r3 ? 4 : 0), a3, r3), t3.setUint32(e3 + o2, u2, r3);
    }(n2, r2 - 8, BigInt(8 * this.length), i2), this.process(n2, 0);
    const a2 = It(t2);
    this.get().forEach((t3, e3) => a2.setUint32(4 * e3, t3, i2));
  }
  digest() {
    const {buffer: t2, outputLen: e2} = this;
    this.digestInto(t2);
    const n2 = t2.slice(0, e2);
    return this.destroy(), n2;
  }
  J(t2) {
    t2 || (t2 = new this.constructor()), t2.set(...this.get());
    const {blockLen: e2, buffer: n2, length: r2, finished: i2, destroyed: s2, pos: a2} = this;
    return t2.length = r2, t2.pos = a2, t2.finished = i2, t2.destroyed = s2, r2 % e2 && t2.buffer.set(n2), t2;
  }
} {
  constructor() {
    super(64, 32, 8, false), this.A = 0 | Pt[0], this.B = 0 | Pt[1], this.C = 0 | Pt[2], this.D = 0 | Pt[3], this.E = 0 | Pt[4], this.F = 0 | Pt[5], this.G = 0 | Pt[6], this.H = 0 | Pt[7];
  }
  get() {
    const {A: t2, B: e2, C: n2, D: r2, E: i2, F: s2, G: a2, H: u2} = this;
    return [t2, e2, n2, r2, i2, s2, a2, u2];
  }
  set(t2, e2, n2, r2, i2, s2, a2, u2) {
    this.A = 0 | t2, this.B = 0 | e2, this.C = 0 | n2, this.D = 0 | r2, this.E = 0 | i2, this.F = 0 | s2, this.G = 0 | a2, this.H = 0 | u2;
  }
  process(t2, e2) {
    for (let n3 = 0; n3 < 16; n3++, e2 += 4)
      Ct[n3] = t2.getUint32(e2, false);
    for (let t3 = 16; t3 < 64; t3++) {
      const e3 = Ct[t3 - 15], n3 = Ct[t3 - 2], r3 = Zt(e3, 7) ^ Zt(e3, 18) ^ e3 >>> 3, i3 = Zt(n3, 17) ^ Zt(n3, 19) ^ n3 >>> 10;
      Ct[t3] = i3 + Ct[t3 - 7] + r3 + Ct[t3 - 16] | 0;
    }
    let {A: n2, B: r2, C: i2, D: s2, E: a2, F: u2, G: o2, H: c2} = this;
    for (let t3 = 0; t3 < 64; t3++) {
      const e3 = c2 + (Zt(a2, 6) ^ Zt(a2, 11) ^ Zt(a2, 25)) + ((h2 = a2) & u2 ^ ~h2 & o2) + Ot[t3] + Ct[t3] | 0, d2 = (Zt(n2, 2) ^ Zt(n2, 13) ^ Zt(n2, 22)) + Dt(n2, r2, i2) | 0;
      c2 = o2, o2 = u2, u2 = a2, a2 = s2 + e3 | 0, s2 = i2, i2 = r2, r2 = n2, n2 = e3 + d2 | 0;
    }
    var h2;
    n2 = n2 + this.A | 0, r2 = r2 + this.B | 0, i2 = i2 + this.C | 0, s2 = s2 + this.D | 0, a2 = a2 + this.E | 0, u2 = u2 + this.F | 0, o2 = o2 + this.G | 0, c2 = c2 + this.H | 0, this.set(n2, r2, i2, s2, a2, u2, o2, c2);
  }
  roundClean() {
    Ct.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}());
var Lt = Tt.object({prefix: Tt.enum(["T"]).default("T"), version: Tt.literal(1).default(1), test: Tt.boolean().default(false), ulid: Tt.string().regex(/^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$/), timestamp: Tt.number().int().min(16409952e8), envelopeHash: Tt.string().regex(/^(([a-f0-9]{2}){20,64})$/i), hmacKey: Tt.string().regex(/^(([a-f0-9]{2}){32,64})$/i), hmac: Tt.string().regex(/^(([A-F0-9]{2}){16})$/i), id: Tt.string().regex(/^T(1)(0|1)_[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}_[0-9]{16}_[0-9A-F]{32}$/)}), Ut = Lt.pick({id: true}), jt = Lt.pick({hmac: true, prefix: true, test: true, timestamp: true, ulid: true, version: true});
Lt.pick({envelopeHash: true, hmacKey: true, test: true, timestamp: true, ulid: true, version: true}), Lt.pick({envelopeHash: true, hmacKey: true, id: true}), Lt.pick({envelopeHash: true, test: true, timestamp: true, ulid: true, version: true});
var Rt, Ft = Lt.pick({test: true, timestamp: true, ulid: true, version: true}), $t = ({id: t2}) => {
  try {
    const {version: e2, test: n2, ulid: r2, timestamp: i2} = ((t3) => {
      try {
        const e3 = Ut.parse(t3), [n3, r3, i3, s2] = e3.id.split("_"), [a2, u2, o2] = n3.split("");
        return jt.parse({prefix: a2, version: parseInt(u2, 10), test: parseInt(o2, 10) == 1, ulid: r3, timestamp: parseInt(i3, 10), hmac: s2});
      } catch (t4) {
        throw t4 instanceof Tt.ZodError ? t4 : t4 instanceof Error ? new Error(`Invalid Id: ${t4.message}`) : t4;
      }
    })({id: t2});
    return Ft.parse({version: e2, test: n2, ulid: r2, timestamp: i2});
  } catch (t3) {
    if (t3 instanceof Tt.ZodError) {
      const e2 = t3.issues.map((t4) => `${t4.code} : [${t4.path.join(", ")}] : ${t4.message}`).join("; ");
      throw new Error(`Invalid Id:  ${e2}`);
    }
    throw t3 instanceof Error ? new Error(`Invalid Id: ${t3.message}`) : t3;
  }
}, Bt = /* @__PURE__ */ function(t2) {
  function n2() {
    return t2.apply(this, arguments) || this;
  }
  e(n2, t2);
  var r2 = n2.prototype;
  return r2.getCommitment = function(t3) {
    return $t({id: t3}), this.request("commitments/" + t3);
  }, r2.getCommitmentVerification = function(t3) {
    return $t({id: t3}), this.request("commitments/" + t3 + "/verify");
  }, n2;
}(l), Gt = /* @__PURE__ */ function(t2) {
  function n2() {
    return t2.apply(this, arguments) || this;
  }
  return e(n2, t2), n2.prototype.getHealth = function() {
    return this.request("health");
  }, n2;
}(l);
!function(t2) {
  t2.assertNever = function(t3) {
    throw new Error();
  }, t2.arrayToEnum = (t3) => {
    const e2 = {};
    for (const n2 of t3)
      e2[n2] = n2;
    return e2;
  }, t2.getValidEnumValues = (e2) => {
    const n2 = t2.objectKeys(e2).filter((t3) => typeof e2[e2[t3]] != "number"), r2 = {};
    for (const t3 of n2)
      r2[t3] = e2[t3];
    return t2.objectValues(r2);
  }, t2.objectValues = (e2) => t2.objectKeys(e2).map(function(t3) {
    return e2[t3];
  }), t2.objectKeys = typeof Object.keys == "function" ? (t3) => Object.keys(t3) : (t3) => {
    const e2 = [];
    for (const n2 in t3)
      Object.prototype.hasOwnProperty.call(t3, n2) && e2.push(n2);
    return e2;
  }, t2.find = (t3, e2) => {
    for (const n2 of t3)
      if (e2(n2))
        return n2;
  }, t2.isInteger = typeof Number.isInteger == "function" ? (t3) => Number.isInteger(t3) : (t3) => typeof t3 == "number" && isFinite(t3) && Math.floor(t3) === t3, t2.joinValues = function(t3, e2 = " | ") {
    return t3.map((t4) => typeof t4 == "string" ? `'${t4}'` : t4).join(e2);
  };
}(Rt || (Rt = {}));
const Ht = Rt.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), Kt = (t2) => {
  switch (typeof t2) {
    case "undefined":
      return Ht.undefined;
    case "string":
      return Ht.string;
    case "number":
      return isNaN(t2) ? Ht.nan : Ht.number;
    case "boolean":
      return Ht.boolean;
    case "function":
      return Ht.function;
    case "bigint":
      return Ht.bigint;
    case "object":
      return Array.isArray(t2) ? Ht.array : t2 === null ? Ht.null : t2.then && typeof t2.then == "function" && t2.catch && typeof t2.catch == "function" ? Ht.promise : typeof Map != "undefined" && t2 instanceof Map ? Ht.map : typeof Set != "undefined" && t2 instanceof Set ? Ht.set : typeof Date != "undefined" && t2 instanceof Date ? Ht.date : Ht.object;
    default:
      return Ht.unknown;
  }
}, zt = Rt.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of"]);
class qt extends Error {
  constructor(t2) {
    super(), this.issues = [], this.addIssue = (t3) => {
      this.issues = [...this.issues, t3];
    }, this.addIssues = (t3 = []) => {
      this.issues = [...this.issues, ...t3];
    };
    const e2 = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, e2) : this.__proto__ = e2, this.name = "ZodError", this.issues = t2;
  }
  get errors() {
    return this.issues;
  }
  format(t2) {
    const e2 = t2 || function(t3) {
      return t3.message;
    }, n2 = {i: []}, r2 = (t3) => {
      for (const i2 of t3.issues)
        if (i2.code === "invalid_union")
          i2.unionErrors.map(r2);
        else if (i2.code === "invalid_return_type")
          r2(i2.returnTypeError);
        else if (i2.code === "invalid_arguments")
          r2(i2.argumentsError);
        else if (i2.path.length === 0)
          n2.i.push(e2(i2));
        else {
          let t4 = n2, r3 = 0;
          for (; r3 < i2.path.length; ) {
            const n3 = i2.path[r3];
            r3 === i2.path.length - 1 ? (t4[n3] = t4[n3] || {i: []}, t4[n3].i.push(e2(i2))) : t4[n3] = t4[n3] || {i: []}, t4 = t4[n3], r3++;
          }
        }
    };
    return r2(this), n2;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, null, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t2 = (t3) => t3.message) {
    const e2 = {}, n2 = [];
    for (const r2 of this.issues)
      r2.path.length > 0 ? (e2[r2.path[0]] = e2[r2.path[0]] || [], e2[r2.path[0]].push(t2(r2))) : n2.push(t2(r2));
    return {formErrors: n2, fieldErrors: e2};
  }
  get formErrors() {
    return this.flatten();
  }
}
qt.create = (t2) => new qt(t2);
const Vt = (t2, e2) => {
  let n2;
  switch (t2.code) {
    case zt.invalid_type:
      n2 = t2.received === Ht.undefined ? "Required" : `Expected ${t2.expected}, received ${t2.received}`;
      break;
    case zt.invalid_literal:
      n2 = `Invalid literal value, expected ${JSON.stringify(t2.expected)}`;
      break;
    case zt.unrecognized_keys:
      n2 = `Unrecognized key(s) in object: ${Rt.joinValues(t2.keys, ", ")}`;
      break;
    case zt.invalid_union:
      n2 = "Invalid input";
      break;
    case zt.invalid_union_discriminator:
      n2 = `Invalid discriminator value. Expected ${Rt.joinValues(t2.options)}`;
      break;
    case zt.invalid_enum_value:
      n2 = `Invalid enum value. Expected ${Rt.joinValues(t2.options)}, received '${t2.received}'`;
      break;
    case zt.invalid_arguments:
      n2 = "Invalid function arguments";
      break;
    case zt.invalid_return_type:
      n2 = "Invalid function return type";
      break;
    case zt.invalid_date:
      n2 = "Invalid date";
      break;
    case zt.invalid_string:
      n2 = t2.validation !== "regex" ? `Invalid ${t2.validation}` : "Invalid";
      break;
    case zt.too_small:
      n2 = t2.type === "array" ? `Array must contain ${t2.inclusive ? "at least" : "more than"} ${t2.minimum} element(s)` : t2.type === "string" ? `String must contain ${t2.inclusive ? "at least" : "over"} ${t2.minimum} character(s)` : t2.type === "number" ? `Number must be greater than ${t2.inclusive ? "or equal to " : ""}${t2.minimum}` : "Invalid input";
      break;
    case zt.too_big:
      n2 = t2.type === "array" ? `Array must contain ${t2.inclusive ? "at most" : "less than"} ${t2.maximum} element(s)` : t2.type === "string" ? `String must contain ${t2.inclusive ? "at most" : "under"} ${t2.maximum} character(s)` : t2.type === "number" ? `Number must be less than ${t2.inclusive ? "or equal to " : ""}${t2.maximum}` : "Invalid input";
      break;
    case zt.custom:
      n2 = "Invalid input";
      break;
    case zt.invalid_intersection_types:
      n2 = "Intersection results could not be merged";
      break;
    case zt.not_multiple_of:
      n2 = `Number must be a multiple of ${t2.multipleOf}`;
      break;
    default:
      n2 = e2.defaultError, Rt.assertNever(t2);
  }
  return {message: n2};
};
let Jt = Vt;
const Wt = (t2) => {
  const {data: e2, path: n2, errorMaps: r2, issueData: i2} = t2, s2 = [...n2, ...i2.path || []], a2 = {...i2, path: s2};
  let u2 = "";
  const o2 = r2.filter((t3) => !!t3).slice().reverse();
  for (const t3 of o2)
    u2 = t3(a2, {data: e2, defaultError: u2}).message;
  return {...i2, path: s2, message: i2.message || u2};
};
function Yt(t2, e2) {
  const n2 = Wt({issueData: e2, data: t2.data, path: t2.path, errorMaps: [t2.common.contextualErrorMap, t2.schemaErrorMap, Jt, Vt].filter((t3) => !!t3)});
  t2.common.issues.push(n2);
}
class Qt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t2, e2) {
    const n2 = [];
    for (const r2 of e2) {
      if (r2.status === "aborted")
        return Xt;
      r2.status === "dirty" && t2.dirty(), n2.push(r2.value);
    }
    return {status: t2.value, value: n2};
  }
  static async mergeObjectAsync(t2, e2) {
    const n2 = [];
    for (const t3 of e2)
      n2.push({key: await t3.key, value: await t3.value});
    return Qt.mergeObjectSync(t2, n2);
  }
  static mergeObjectSync(t2, e2) {
    const n2 = {};
    for (const r2 of e2) {
      const {key: e3, value: i2} = r2;
      if (e3.status === "aborted")
        return Xt;
      if (i2.status === "aborted")
        return Xt;
      e3.status === "dirty" && t2.dirty(), i2.status === "dirty" && t2.dirty(), (i2.value !== void 0 || r2.alwaysSet) && (n2[e3.value] = i2.value);
    }
    return {status: t2.value, value: n2};
  }
}
const Xt = Object.freeze({status: "aborted"}), te = (t2) => ({status: "valid", value: t2}), ee = (t2) => t2.status === "aborted", ne = (t2) => t2.status === "dirty", re = (t2) => t2.status === "valid", ie = (t2) => typeof Promise !== void 0 && t2 instanceof Promise;
var se;
!function(t2) {
  t2.errToObj = (t3) => typeof t3 == "string" ? {message: t3} : t3 || {}, t2.toString = (t3) => typeof t3 == "string" ? t3 : t3 == null ? void 0 : t3.message;
}(se || (se = {}));
class ae {
  constructor(t2, e2, n2, r2) {
    this.parent = t2, this.data = e2, this.l = n2, this.m = r2;
  }
  get path() {
    return this.l.concat(this.m);
  }
}
const ue = (t2, e2) => {
  if (re(e2))
    return {success: true, data: e2.value};
  if (!t2.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {success: false, error: new qt(t2.common.issues)};
};
function oe(t2) {
  if (!t2)
    return {};
  const {errorMap: e2, invalid_type_error: n2, required_error: r2, description: i2} = t2;
  if (e2 && (n2 || r2))
    throw new Error(`Can't use "invalid" or "required" in conjunction with custom error map.`);
  return e2 ? {errorMap: e2, description: i2} : {errorMap: (e3, n3) => e3.code !== "invalid_type" ? {message: n3.defaultError} : n3.data === void 0 && r2 ? {message: r2} : t2.invalid_type_error ? {message: t2.invalid_type_error} : {message: n3.defaultError}, description: i2};
}
class ce {
  constructor(t2) {
    this.spa = this.safeParseAsync, this.superRefine = this.g, this.k = t2, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.default = this.default.bind(this), this.describe = this.describe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this.k.description;
  }
  N(t2) {
    return Kt(t2.data);
  }
  _(t2, e2) {
    return e2 || {common: t2.parent.common, data: t2.data, parsedType: Kt(t2.data), schemaErrorMap: this.k.errorMap, path: t2.path, parent: t2.parent};
  }
  I(t2) {
    return {status: new Qt(), ctx: {common: t2.parent.common, data: t2.data, parsedType: Kt(t2.data), schemaErrorMap: this.k.errorMap, path: t2.path, parent: t2.parent}};
  }
  O(t2) {
    const e2 = this.P(t2);
    if (ie(e2))
      throw new Error("Synchronous parse encountered promise.");
    return e2;
  }
  L(t2) {
    const e2 = this.P(t2);
    return Promise.resolve(e2);
  }
  parse(t2, e2) {
    const n2 = this.safeParse(t2, e2);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  safeParse(t2, e2) {
    var n2;
    const r2 = {common: {issues: [], async: (n2 = e2 == null ? void 0 : e2.async) !== null && n2 !== void 0 && n2, contextualErrorMap: e2 == null ? void 0 : e2.errorMap}, path: (e2 == null ? void 0 : e2.path) || [], schemaErrorMap: this.k.errorMap, parent: null, data: t2, parsedType: Kt(t2)}, i2 = this.O({data: t2, path: r2.path, parent: r2});
    return ue(r2, i2);
  }
  async parseAsync(t2, e2) {
    const n2 = await this.safeParseAsync(t2, e2);
    if (n2.success)
      return n2.data;
    throw n2.error;
  }
  async safeParseAsync(t2, e2) {
    const n2 = {common: {issues: [], contextualErrorMap: e2 == null ? void 0 : e2.errorMap, async: true}, path: (e2 == null ? void 0 : e2.path) || [], schemaErrorMap: this.k.errorMap, parent: null, data: t2, parsedType: Kt(t2)}, r2 = this.P({data: t2, path: [], parent: n2}), i2 = await (ie(r2) ? r2 : Promise.resolve(r2));
    return ue(n2, i2);
  }
  refine(t2, e2) {
    const n2 = (t3) => typeof e2 == "string" || e2 === void 0 ? {message: e2} : typeof e2 == "function" ? e2(t3) : e2;
    return this.g((e3, r2) => {
      const i2 = t2(e3), s2 = () => r2.addIssue({code: zt.custom, ...n2(e3)});
      return typeof Promise != "undefined" && i2 instanceof Promise ? i2.then((t3) => !!t3 || (s2(), false)) : !!i2 || (s2(), false);
    });
  }
  refinement(t2, e2) {
    return this.g((n2, r2) => !!t2(n2) || (r2.addIssue(typeof e2 == "function" ? e2(n2, r2) : e2), false));
  }
  g(t2) {
    return new He({schema: this, typeName: Ye.ZodEffects, effect: {type: "refinement", refinement: t2}});
  }
  optional() {
    return Ke.create(this);
  }
  nullable() {
    return ze.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return Ee.create(this);
  }
  promise() {
    return Ge.create(this);
  }
  or(t2) {
    return Ze.create([this, t2]);
  }
  and(t2) {
    return Oe.create(this, t2);
  }
  transform(t2) {
    return new He({schema: this, typeName: Ye.ZodEffects, effect: {type: "transform", transform: t2}});
  }
  default(t2) {
    return new qe({innerType: this, defaultValue: typeof t2 == "function" ? t2 : () => t2, typeName: Ye.ZodDefault});
  }
  describe(t2) {
    return new this.constructor({...this.k, description: t2});
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const he = /^c[^\s-]{8,}$/i, de = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, le = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
class fe extends ce {
  constructor() {
    super(...arguments), this.U = (t2, e2, n2) => this.refinement((e3) => t2.test(e3), {validation: e2, code: zt.invalid_string, ...se.errToObj(n2)}), this.nonempty = (t2) => this.min(1, se.errToObj(t2)), this.trim = () => new fe({...this.k, checks: [...this.k.checks, {kind: "trim"}]});
  }
  P(t2) {
    if (this.N(t2) !== Ht.string) {
      const e3 = this._(t2);
      return Yt(e3, {code: zt.invalid_type, expected: Ht.string, received: e3.parsedType}), Xt;
    }
    const e2 = new Qt();
    let n2;
    for (const r2 of this.k.checks)
      if (r2.kind === "min")
        t2.data.length < r2.value && (n2 = this._(t2, n2), Yt(n2, {code: zt.too_small, minimum: r2.value, type: "string", inclusive: true, message: r2.message}), e2.dirty());
      else if (r2.kind === "max")
        t2.data.length > r2.value && (n2 = this._(t2, n2), Yt(n2, {code: zt.too_big, maximum: r2.value, type: "string", inclusive: true, message: r2.message}), e2.dirty());
      else if (r2.kind === "email")
        le.test(t2.data) || (n2 = this._(t2, n2), Yt(n2, {validation: "email", code: zt.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "uuid")
        de.test(t2.data) || (n2 = this._(t2, n2), Yt(n2, {validation: "uuid", code: zt.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "cuid")
        he.test(t2.data) || (n2 = this._(t2, n2), Yt(n2, {validation: "cuid", code: zt.invalid_string, message: r2.message}), e2.dirty());
      else if (r2.kind === "url")
        try {
          new URL(t2.data);
        } catch (i2) {
          n2 = this._(t2, n2), Yt(n2, {validation: "url", code: zt.invalid_string, message: r2.message}), e2.dirty();
        }
      else
        r2.kind === "regex" ? (r2.regex.lastIndex = 0, r2.regex.test(t2.data) || (n2 = this._(t2, n2), Yt(n2, {validation: "regex", code: zt.invalid_string, message: r2.message}), e2.dirty())) : r2.kind === "trim" ? t2.data = t2.data.trim() : Rt.assertNever(r2);
    return {status: e2.value, value: t2.data};
  }
  j(t2) {
    return new fe({...this.k, checks: [...this.k.checks, t2]});
  }
  email(t2) {
    return this.j({kind: "email", ...se.errToObj(t2)});
  }
  url(t2) {
    return this.j({kind: "url", ...se.errToObj(t2)});
  }
  uuid(t2) {
    return this.j({kind: "uuid", ...se.errToObj(t2)});
  }
  cuid(t2) {
    return this.j({kind: "cuid", ...se.errToObj(t2)});
  }
  regex(t2, e2) {
    return this.j({kind: "regex", regex: t2, ...se.errToObj(e2)});
  }
  min(t2, e2) {
    return this.j({kind: "min", value: t2, ...se.errToObj(e2)});
  }
  max(t2, e2) {
    return this.j({kind: "max", value: t2, ...se.errToObj(e2)});
  }
  length(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  get isEmail() {
    return !!this.k.checks.find((t2) => t2.kind === "email");
  }
  get isURL() {
    return !!this.k.checks.find((t2) => t2.kind === "url");
  }
  get isUUID() {
    return !!this.k.checks.find((t2) => t2.kind === "uuid");
  }
  get isCUID() {
    return !!this.k.checks.find((t2) => t2.kind === "cuid");
  }
  get minLength() {
    let t2 = -Infinity;
    return this.k.checks.map((e2) => {
      e2.kind === "min" && (t2 === null || e2.value > t2) && (t2 = e2.value);
    }), t2;
  }
  get maxLength() {
    let t2 = null;
    return this.k.checks.map((e2) => {
      e2.kind === "max" && (t2 === null || e2.value < t2) && (t2 = e2.value);
    }), t2;
  }
}
function me(t2, e2) {
  const n2 = (t2.toString().split(".")[1] || "").length, r2 = (e2.toString().split(".")[1] || "").length, i2 = n2 > r2 ? n2 : r2;
  return parseInt(t2.toFixed(i2).replace(".", "")) % parseInt(e2.toFixed(i2).replace(".", "")) / Math.pow(10, i2);
}
fe.create = (t2) => new fe({checks: [], typeName: Ye.ZodString, ...oe(t2)});
class ve extends ce {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  P(t2) {
    if (this.N(t2) !== Ht.number) {
      const e3 = this._(t2);
      return Yt(e3, {code: zt.invalid_type, expected: Ht.number, received: e3.parsedType}), Xt;
    }
    let e2;
    const n2 = new Qt();
    for (const r2 of this.k.checks)
      r2.kind === "int" ? Rt.isInteger(t2.data) || (e2 = this._(t2, e2), Yt(e2, {code: zt.invalid_type, expected: "integer", received: "float", message: r2.message}), n2.dirty()) : r2.kind === "min" ? (r2.inclusive ? t2.data < r2.value : t2.data <= r2.value) && (e2 = this._(t2, e2), Yt(e2, {code: zt.too_small, minimum: r2.value, type: "number", inclusive: r2.inclusive, message: r2.message}), n2.dirty()) : r2.kind === "max" ? (r2.inclusive ? t2.data > r2.value : t2.data >= r2.value) && (e2 = this._(t2, e2), Yt(e2, {code: zt.too_big, maximum: r2.value, type: "number", inclusive: r2.inclusive, message: r2.message}), n2.dirty()) : r2.kind === "multipleOf" ? me(t2.data, r2.value) !== 0 && (e2 = this._(t2, e2), Yt(e2, {code: zt.not_multiple_of, multipleOf: r2.value, message: r2.message}), n2.dirty()) : Rt.assertNever(r2);
    return {status: n2.value, value: t2.data};
  }
  gte(t2, e2) {
    return this.setLimit("min", t2, true, se.toString(e2));
  }
  gt(t2, e2) {
    return this.setLimit("min", t2, false, se.toString(e2));
  }
  lte(t2, e2) {
    return this.setLimit("max", t2, true, se.toString(e2));
  }
  lt(t2, e2) {
    return this.setLimit("max", t2, false, se.toString(e2));
  }
  setLimit(t2, e2, n2, r2) {
    return new ve({...this.k, checks: [...this.k.checks, {kind: t2, value: e2, inclusive: n2, message: se.toString(r2)}]});
  }
  j(t2) {
    return new ve({...this.k, checks: [...this.k.checks, t2]});
  }
  int(t2) {
    return this.j({kind: "int", message: se.toString(t2)});
  }
  positive(t2) {
    return this.j({kind: "min", value: 0, inclusive: false, message: se.toString(t2)});
  }
  negative(t2) {
    return this.j({kind: "max", value: 0, inclusive: false, message: se.toString(t2)});
  }
  nonpositive(t2) {
    return this.j({kind: "max", value: 0, inclusive: true, message: se.toString(t2)});
  }
  nonnegative(t2) {
    return this.j({kind: "min", value: 0, inclusive: true, message: se.toString(t2)});
  }
  multipleOf(t2, e2) {
    return this.j({kind: "multipleOf", value: t2, message: se.toString(e2)});
  }
  get minValue() {
    let t2 = null;
    for (const e2 of this.k.checks)
      e2.kind === "min" && (t2 === null || e2.value > t2) && (t2 = e2.value);
    return t2;
  }
  get maxValue() {
    let t2 = null;
    for (const e2 of this.k.checks)
      e2.kind === "max" && (t2 === null || e2.value < t2) && (t2 = e2.value);
    return t2;
  }
  get isInt() {
    return !!this.k.checks.find((t2) => t2.kind === "int");
  }
}
ve.create = (t2) => new ve({checks: [], typeName: Ye.ZodNumber, ...oe(t2)});
class ye extends ce {
  P(t2) {
    if (this.N(t2) !== Ht.bigint) {
      const e2 = this._(t2);
      return Yt(e2, {code: zt.invalid_type, expected: Ht.bigint, received: e2.parsedType}), Xt;
    }
    return te(t2.data);
  }
}
ye.create = (t2) => new ye({typeName: Ye.ZodBigInt, ...oe(t2)});
class pe extends ce {
  P(t2) {
    if (this.N(t2) !== Ht.boolean) {
      const e2 = this._(t2);
      return Yt(e2, {code: zt.invalid_type, expected: Ht.boolean, received: e2.parsedType}), Xt;
    }
    return te(t2.data);
  }
}
pe.create = (t2) => new pe({typeName: Ye.ZodBoolean, ...oe(t2)});
class ge extends ce {
  P(t2) {
    if (this.N(t2) !== Ht.date) {
      const e2 = this._(t2);
      return Yt(e2, {code: zt.invalid_type, expected: Ht.date, received: e2.parsedType}), Xt;
    }
    return isNaN(t2.data.getTime()) ? (Yt(this._(t2), {code: zt.invalid_date}), Xt) : {status: "valid", value: new Date(t2.data.getTime())};
  }
}
ge.create = (t2) => new ge({typeName: Ye.ZodDate, ...oe(t2)});
class we extends ce {
  P(t2) {
    if (this.N(t2) !== Ht.undefined) {
      const e2 = this._(t2);
      return Yt(e2, {code: zt.invalid_type, expected: Ht.undefined, received: e2.parsedType}), Xt;
    }
    return te(t2.data);
  }
}
we.create = (t2) => new we({typeName: Ye.ZodUndefined, ...oe(t2)});
class be extends ce {
  P(t2) {
    if (this.N(t2) !== Ht.null) {
      const e2 = this._(t2);
      return Yt(e2, {code: zt.invalid_type, expected: Ht.null, received: e2.parsedType}), Xt;
    }
    return te(t2.data);
  }
}
be.create = (t2) => new be({typeName: Ye.ZodNull, ...oe(t2)});
class ke extends ce {
  constructor() {
    super(...arguments), this.R = true;
  }
  P(t2) {
    return te(t2.data);
  }
}
ke.create = (t2) => new ke({typeName: Ye.ZodAny, ...oe(t2)});
class Ne extends ce {
  constructor() {
    super(...arguments), this.$ = true;
  }
  P(t2) {
    return te(t2.data);
  }
}
Ne.create = (t2) => new Ne({typeName: Ye.ZodUnknown, ...oe(t2)});
class Me extends ce {
  P(t2) {
    const e2 = this._(t2);
    return Yt(e2, {code: zt.invalid_type, expected: Ht.never, received: e2.parsedType}), Xt;
  }
}
Me.create = (t2) => new Me({typeName: Ye.ZodNever, ...oe(t2)});
class xe extends ce {
  P(t2) {
    if (this.N(t2) !== Ht.undefined) {
      const e2 = this._(t2);
      return Yt(e2, {code: zt.invalid_type, expected: Ht.void, received: e2.parsedType}), Xt;
    }
    return te(t2.data);
  }
}
xe.create = (t2) => new xe({typeName: Ye.ZodVoid, ...oe(t2)});
class Ee extends ce {
  P(t2) {
    const {ctx: e2, status: n2} = this.I(t2), r2 = this.k;
    if (e2.parsedType !== Ht.array)
      return Yt(e2, {code: zt.invalid_type, expected: Ht.array, received: e2.parsedType}), Xt;
    if (r2.minLength !== null && e2.data.length < r2.minLength.value && (Yt(e2, {code: zt.too_small, minimum: r2.minLength.value, type: "array", inclusive: true, message: r2.minLength.message}), n2.dirty()), r2.maxLength !== null && e2.data.length > r2.maxLength.value && (Yt(e2, {code: zt.too_big, maximum: r2.maxLength.value, type: "array", inclusive: true, message: r2.maxLength.message}), n2.dirty()), e2.common.async)
      return Promise.all(e2.data.map((t3, n3) => r2.type.L(new ae(e2, t3, e2.path, n3)))).then((t3) => Qt.mergeArray(n2, t3));
    const i2 = e2.data.map((t3, n3) => r2.type.O(new ae(e2, t3, e2.path, n3)));
    return Qt.mergeArray(n2, i2);
  }
  get element() {
    return this.k.type;
  }
  min(t2, e2) {
    return new Ee({...this.k, minLength: {value: t2, message: se.toString(e2)}});
  }
  max(t2, e2) {
    return new Ee({...this.k, maxLength: {value: t2, message: se.toString(e2)}});
  }
  length(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  nonempty(t2) {
    return this.min(1, t2);
  }
}
var Se;
Ee.create = (t2, e2) => new Ee({type: t2, minLength: null, maxLength: null, typeName: Ye.ZodArray, ...oe(e2)}), function(t2) {
  t2.mergeShapes = (t3, e2) => ({...t3, ...e2});
}(Se || (Se = {}));
const Te = (t2) => (e2) => new Ie({...t2, shape: () => ({...t2.shape(), ...e2})});
function _e(t2) {
  if (t2 instanceof Ie) {
    const e2 = {};
    for (const n2 in t2.shape)
      e2[n2] = Ke.create(_e(t2.shape[n2]));
    return new Ie({...t2.k, shape: () => e2});
  }
  return t2 instanceof Ee ? Ee.create(_e(t2.element)) : t2 instanceof Ke ? Ke.create(_e(t2.unwrap())) : t2 instanceof ze ? ze.create(_e(t2.unwrap())) : t2 instanceof Pe ? Pe.create(t2.items.map((t3) => _e(t3))) : t2;
}
class Ie extends ce {
  constructor() {
    super(...arguments), this.K = null, this.nonstrict = this.passthrough, this.augment = Te(this.k), this.extend = Te(this.k);
  }
  V() {
    if (this.K !== null)
      return this.K;
    const t2 = this.k.shape(), e2 = Rt.objectKeys(t2);
    return this.K = {shape: t2, keys: e2};
  }
  P(t2) {
    if (this.N(t2) !== Ht.object) {
      const e3 = this._(t2);
      return Yt(e3, {code: zt.invalid_type, expected: Ht.object, received: e3.parsedType}), Xt;
    }
    const {status: e2, ctx: n2} = this.I(t2), {shape: r2, keys: i2} = this.V(), s2 = [];
    for (const t3 in n2.data)
      i2.includes(t3) || s2.push(t3);
    const a2 = [];
    for (const t3 of i2)
      a2.push({key: {status: "valid", value: t3}, value: r2[t3].P(new ae(n2, n2.data[t3], n2.path, t3)), alwaysSet: t3 in n2.data});
    if (this.k.catchall instanceof Me) {
      const t3 = this.k.unknownKeys;
      if (t3 === "passthrough")
        for (const t4 of s2)
          a2.push({key: {status: "valid", value: t4}, value: {status: "valid", value: n2.data[t4]}});
      else if (t3 === "strict")
        s2.length > 0 && (Yt(n2, {code: zt.unrecognized_keys, keys: s2}), e2.dirty());
      else if (t3 !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const t3 = this.k.catchall;
      for (const e3 of s2)
        a2.push({key: {status: "valid", value: e3}, value: t3.P(new ae(n2, n2.data[e3], n2.path, e3)), alwaysSet: e3 in n2.data});
    }
    return n2.common.async ? Promise.resolve().then(async () => {
      const t3 = [];
      for (const e3 of a2) {
        const n3 = await e3.key;
        t3.push({key: n3, value: await e3.value, alwaysSet: e3.alwaysSet});
      }
      return t3;
    }).then((t3) => Qt.mergeObjectSync(e2, t3)) : Qt.mergeObjectSync(e2, a2);
  }
  get shape() {
    return this.k.shape();
  }
  strict(t2) {
    return new Ie({...this.k, unknownKeys: "strict", ...t2 !== void 0 ? {errorMap: (e2, n2) => {
      var r2, i2, s2, a2;
      const u2 = (s2 = (i2 = (r2 = this.k).errorMap) === null || i2 === void 0 ? void 0 : i2.call(r2, e2, n2).message) !== null && s2 !== void 0 ? s2 : n2.defaultError;
      return e2.code === "unrecognized_keys" ? {message: (a2 = se.errToObj(t2).message) !== null && a2 !== void 0 ? a2 : u2} : {message: u2};
    }} : {}});
  }
  strip() {
    return new Ie({...this.k, unknownKeys: "strip"});
  }
  passthrough() {
    return new Ie({...this.k, unknownKeys: "passthrough"});
  }
  setKey(t2, e2) {
    return this.augment({[t2]: e2});
  }
  merge(t2) {
    return new Ie({unknownKeys: t2.k.unknownKeys, catchall: t2.k.catchall, shape: () => Se.mergeShapes(this.k.shape(), t2.k.shape()), typeName: Ye.ZodObject});
  }
  catchall(t2) {
    return new Ie({...this.k, catchall: t2});
  }
  pick(t2) {
    const e2 = {};
    return Rt.objectKeys(t2).map((t3) => {
      this.shape[t3] && (e2[t3] = this.shape[t3]);
    }), new Ie({...this.k, shape: () => e2});
  }
  omit(t2) {
    const e2 = {};
    return Rt.objectKeys(this.shape).map((n2) => {
      Rt.objectKeys(t2).indexOf(n2) === -1 && (e2[n2] = this.shape[n2]);
    }), new Ie({...this.k, shape: () => e2});
  }
  deepPartial() {
    return _e(this);
  }
  partial(t2) {
    const e2 = {};
    if (t2)
      return Rt.objectKeys(this.shape).map((n2) => {
        e2[n2] = Rt.objectKeys(t2).indexOf(n2) === -1 ? this.shape[n2] : this.shape[n2].optional();
      }), new Ie({...this.k, shape: () => e2});
    for (const t3 in this.shape)
      e2[t3] = this.shape[t3].optional();
    return new Ie({...this.k, shape: () => e2});
  }
  required() {
    const t2 = {};
    for (const e2 in this.shape) {
      let n2 = this.shape[e2];
      for (; n2 instanceof Ke; )
        n2 = n2.k.innerType;
      t2[e2] = n2;
    }
    return new Ie({...this.k, shape: () => t2});
  }
}
Ie.create = (t2, e2) => new Ie({shape: () => t2, unknownKeys: "strip", catchall: Me.create(), typeName: Ye.ZodObject, ...oe(e2)}), Ie.strictCreate = (t2, e2) => new Ie({shape: () => t2, unknownKeys: "strict", catchall: Me.create(), typeName: Ye.ZodObject, ...oe(e2)}), Ie.lazycreate = (t2, e2) => new Ie({shape: t2, unknownKeys: "strip", catchall: Me.create(), typeName: Ye.ZodObject, ...oe(e2)});
class Ze extends ce {
  P(t2) {
    const {ctx: e2} = this.I(t2), n2 = this.k.options;
    if (e2.common.async)
      return Promise.all(n2.map(async (t3) => {
        const n3 = {...e2, common: {...e2.common, issues: []}, parent: null};
        return {result: await t3.L({data: e2.data, path: e2.path, parent: n3}), ctx: n3};
      })).then(function(t3) {
        for (const e3 of t3)
          if (e3.result.status === "valid")
            return e3.result;
        for (const n4 of t3)
          if (n4.result.status === "dirty")
            return e2.common.issues.push(...n4.ctx.common.issues), n4.result;
        const n3 = t3.map((t4) => new qt(t4.ctx.common.issues));
        return Yt(e2, {code: zt.invalid_union, unionErrors: n3}), Xt;
      });
    {
      let t3;
      const r2 = [];
      for (const i3 of n2) {
        const n3 = {...e2, common: {...e2.common, issues: []}, parent: null}, s2 = i3.O({data: e2.data, path: e2.path, parent: n3});
        if (s2.status === "valid")
          return s2;
        s2.status !== "dirty" || t3 || (t3 = {result: s2, ctx: n3}), n3.common.issues.length && r2.push(n3.common.issues);
      }
      if (t3)
        return e2.common.issues.push(...t3.ctx.common.issues), t3.result;
      const i2 = r2.map((t4) => new qt(t4));
      return Yt(e2, {code: zt.invalid_union, unionErrors: i2}), Xt;
    }
  }
  get options() {
    return this.k.options;
  }
}
Ze.create = (t2, e2) => new Ze({options: t2, typeName: Ye.ZodUnion, ...oe(e2)});
class Ae extends ce {
  P(t2) {
    const {ctx: e2} = this.I(t2);
    if (e2.parsedType !== Ht.object)
      return Yt(e2, {code: zt.invalid_type, expected: Ht.object, received: e2.parsedType}), Xt;
    const n2 = this.discriminator, r2 = this.options.get(e2.data[n2]);
    return r2 ? e2.common.async ? r2.L({data: e2.data, path: e2.path, parent: e2}) : r2.O({data: e2.data, path: e2.path, parent: e2}) : (Yt(e2, {code: zt.invalid_union_discriminator, options: this.validDiscriminatorValues, path: [n2]}), Xt);
  }
  get discriminator() {
    return this.k.discriminator;
  }
  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }
  get options() {
    return this.k.options;
  }
  static create(t2, e2, n2) {
    const r2 = new Map();
    try {
      e2.forEach((e3) => {
        r2.set(e3.shape[t2].value, e3);
      });
    } catch (t3) {
      throw new Error("The discriminator value could not be extracted from all the provided schemas");
    }
    if (r2.size !== e2.length)
      throw new Error("Some of the discriminator values are not unique");
    return new Ae({typeName: Ye.ZodDiscriminatedUnion, discriminator: t2, options: r2, ...oe(n2)});
  }
}
function De(t2, e2) {
  const n2 = Kt(t2), r2 = Kt(e2);
  if (t2 === e2)
    return {valid: true, data: t2};
  if (n2 === Ht.object && r2 === Ht.object) {
    const n3 = Rt.objectKeys(e2), r3 = Rt.objectKeys(t2).filter((t3) => n3.indexOf(t3) !== -1), i2 = {...t2, ...e2};
    for (const n4 of r3) {
      const r4 = De(t2[n4], e2[n4]);
      if (!r4.valid)
        return {valid: false};
      i2[n4] = r4.data;
    }
    return {valid: true, data: i2};
  }
  if (n2 === Ht.array && r2 === Ht.array) {
    if (t2.length !== e2.length)
      return {valid: false};
    const n3 = [];
    for (let r3 = 0; r3 < t2.length; r3++) {
      const i2 = De(t2[r3], e2[r3]);
      if (!i2.valid)
        return {valid: false};
      n3.push(i2.data);
    }
    return {valid: true, data: n3};
  }
  return n2 === Ht.date && r2 === Ht.date && +t2 == +e2 ? {valid: true, data: t2} : {valid: false};
}
class Oe extends ce {
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2), r2 = (t3, r3) => {
      if (ee(t3) || ee(r3))
        return Xt;
      const i2 = De(t3.value, r3.value);
      return i2.valid ? ((ne(t3) || ne(r3)) && e2.dirty(), {status: e2.value, value: i2.data}) : (Yt(n2, {code: zt.invalid_intersection_types}), Xt);
    };
    return n2.common.async ? Promise.all([this.k.left.L({data: n2.data, path: n2.path, parent: n2}), this.k.right.L({data: n2.data, path: n2.path, parent: n2})]).then(([t3, e3]) => r2(t3, e3)) : r2(this.k.left.O({data: n2.data, path: n2.path, parent: n2}), this.k.right.O({data: n2.data, path: n2.path, parent: n2}));
  }
}
Oe.create = (t2, e2, n2) => new Oe({left: t2, right: e2, typeName: Ye.ZodIntersection, ...oe(n2)});
class Pe extends ce {
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2);
    if (n2.parsedType !== Ht.array)
      return Yt(n2, {code: zt.invalid_type, expected: Ht.array, received: n2.parsedType}), Xt;
    if (n2.data.length < this.k.items.length)
      return Yt(n2, {code: zt.too_small, minimum: this.k.items.length, inclusive: true, type: "array"}), Xt;
    !this.k.rest && n2.data.length > this.k.items.length && (Yt(n2, {code: zt.too_big, maximum: this.k.items.length, inclusive: true, type: "array"}), e2.dirty());
    const r2 = n2.data.map((t3, e3) => {
      const r3 = this.k.items[e3] || this.k.rest;
      return r3 ? r3.P(new ae(n2, t3, n2.path, e3)) : null;
    }).filter((t3) => !!t3);
    return n2.common.async ? Promise.all(r2).then((t3) => Qt.mergeArray(e2, t3)) : Qt.mergeArray(e2, r2);
  }
  get items() {
    return this.k.items;
  }
  rest(t2) {
    return new Pe({...this.k, rest: t2});
  }
}
Pe.create = (t2, e2) => new Pe({items: t2, typeName: Ye.ZodTuple, rest: null, ...oe(e2)});
class Ce extends ce {
  get keySchema() {
    return this.k.keyType;
  }
  get valueSchema() {
    return this.k.valueType;
  }
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2);
    if (n2.parsedType !== Ht.object)
      return Yt(n2, {code: zt.invalid_type, expected: Ht.object, received: n2.parsedType}), Xt;
    const r2 = [], i2 = this.k.keyType, s2 = this.k.valueType;
    for (const t3 in n2.data)
      r2.push({key: i2.P(new ae(n2, t3, n2.path, t3)), value: s2.P(new ae(n2, n2.data[t3], n2.path, t3))});
    return n2.common.async ? Qt.mergeObjectAsync(e2, r2) : Qt.mergeObjectSync(e2, r2);
  }
  get element() {
    return this.k.valueType;
  }
  static create(t2, e2, n2) {
    return new Ce(e2 instanceof ce ? {keyType: t2, valueType: e2, typeName: Ye.ZodRecord, ...oe(n2)} : {keyType: fe.create(), valueType: t2, typeName: Ye.ZodRecord, ...oe(e2)});
  }
}
class Le extends ce {
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2);
    if (n2.parsedType !== Ht.map)
      return Yt(n2, {code: zt.invalid_type, expected: Ht.map, received: n2.parsedType}), Xt;
    const r2 = this.k.keyType, i2 = this.k.valueType, s2 = [...n2.data.entries()].map(([t3, e3], s3) => ({key: r2.P(new ae(n2, t3, n2.path, [s3, "key"])), value: i2.P(new ae(n2, e3, n2.path, [s3, "value"]))}));
    if (n2.common.async) {
      const t3 = new Map();
      return Promise.resolve().then(async () => {
        for (const n3 of s2) {
          const r3 = await n3.key, i3 = await n3.value;
          if (r3.status === "aborted" || i3.status === "aborted")
            return Xt;
          r3.status !== "dirty" && i3.status !== "dirty" || e2.dirty(), t3.set(r3.value, i3.value);
        }
        return {status: e2.value, value: t3};
      });
    }
    {
      const t3 = new Map();
      for (const n3 of s2) {
        const r3 = n3.key, i3 = n3.value;
        if (r3.status === "aborted" || i3.status === "aborted")
          return Xt;
        r3.status !== "dirty" && i3.status !== "dirty" || e2.dirty(), t3.set(r3.value, i3.value);
      }
      return {status: e2.value, value: t3};
    }
  }
}
Le.create = (t2, e2, n2) => new Le({valueType: e2, keyType: t2, typeName: Ye.ZodMap, ...oe(n2)});
class Ue extends ce {
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2);
    if (n2.parsedType !== Ht.set)
      return Yt(n2, {code: zt.invalid_type, expected: Ht.set, received: n2.parsedType}), Xt;
    const r2 = this.k;
    r2.minSize !== null && n2.data.size < r2.minSize.value && (Yt(n2, {code: zt.too_small, minimum: r2.minSize.value, type: "set", inclusive: true, message: r2.minSize.message}), e2.dirty()), r2.maxSize !== null && n2.data.size > r2.maxSize.value && (Yt(n2, {code: zt.too_big, maximum: r2.maxSize.value, type: "set", inclusive: true, message: r2.maxSize.message}), e2.dirty());
    const i2 = this.k.valueType;
    function s2(t3) {
      const n3 = new Set();
      for (const r3 of t3) {
        if (r3.status === "aborted")
          return Xt;
        r3.status === "dirty" && e2.dirty(), n3.add(r3.value);
      }
      return {status: e2.value, value: n3};
    }
    const a2 = [...n2.data.values()].map((t3, e3) => i2.P(new ae(n2, t3, n2.path, e3)));
    return n2.common.async ? Promise.all(a2).then((t3) => s2(t3)) : s2(a2);
  }
  min(t2, e2) {
    return new Ue({...this.k, minSize: {value: t2, message: se.toString(e2)}});
  }
  max(t2, e2) {
    return new Ue({...this.k, maxSize: {value: t2, message: se.toString(e2)}});
  }
  size(t2, e2) {
    return this.min(t2, e2).max(t2, e2);
  }
  nonempty(t2) {
    return this.min(1, t2);
  }
}
Ue.create = (t2, e2) => new Ue({valueType: t2, minSize: null, maxSize: null, typeName: Ye.ZodSet, ...oe(e2)});
class je extends ce {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  P(t2) {
    const {ctx: e2} = this.I(t2);
    if (e2.parsedType !== Ht.function)
      return Yt(e2, {code: zt.invalid_type, expected: Ht.function, received: e2.parsedType}), Xt;
    function n2(t3, n3) {
      return Wt({data: t3, path: e2.path, errorMaps: [e2.common.contextualErrorMap, e2.schemaErrorMap, Jt, Vt].filter((t4) => !!t4), issueData: {code: zt.invalid_arguments, argumentsError: n3}});
    }
    function r2(t3, n3) {
      return Wt({data: t3, path: e2.path, errorMaps: [e2.common.contextualErrorMap, e2.schemaErrorMap, Jt, Vt].filter((t4) => !!t4), issueData: {code: zt.invalid_return_type, returnTypeError: n3}});
    }
    const i2 = {errorMap: e2.common.contextualErrorMap}, s2 = e2.data;
    return te(this.k.returns instanceof Ge ? async (...t3) => {
      const e3 = new qt([]), a2 = await this.k.args.parseAsync(t3, i2).catch((r3) => {
        throw e3.addIssue(n2(t3, r3)), e3;
      }), u2 = await s2(...a2);
      return await this.k.returns.k.type.parseAsync(u2, i2).catch((t4) => {
        throw e3.addIssue(r2(u2, t4)), e3;
      });
    } : (...t3) => {
      const e3 = this.k.args.safeParse(t3, i2);
      if (!e3.success)
        throw new qt([n2(t3, e3.error)]);
      const a2 = s2(...e3.data), u2 = this.k.returns.safeParse(a2, i2);
      if (!u2.success)
        throw new qt([r2(a2, u2.error)]);
      return u2.data;
    });
  }
  parameters() {
    return this.k.args;
  }
  returnType() {
    return this.k.returns;
  }
  args(...t2) {
    return new je({...this.k, args: Pe.create(t2).rest(Ne.create())});
  }
  returns(t2) {
    return new je({...this.k, returns: t2});
  }
  implement(t2) {
    return this.parse(t2);
  }
  strictImplement(t2) {
    return this.parse(t2);
  }
}
je.create = (t2, e2, n2) => new je({args: t2 ? t2.rest(Ne.create()) : Pe.create([]).rest(Ne.create()), returns: e2 || Ne.create(), typeName: Ye.ZodFunction, ...oe(n2)});
class Re extends ce {
  get schema() {
    return this.k.getter();
  }
  P(t2) {
    const {ctx: e2} = this.I(t2);
    return this.k.getter().P({data: e2.data, path: e2.path, parent: e2});
  }
}
Re.create = (t2, e2) => new Re({getter: t2, typeName: Ye.ZodLazy, ...oe(e2)});
class Fe extends ce {
  P(t2) {
    return t2.data !== this.k.value ? (Yt(this._(t2), {code: zt.invalid_literal, expected: this.k.value}), Xt) : {status: "valid", value: t2.data};
  }
  get value() {
    return this.k.value;
  }
}
Fe.create = (t2, e2) => new Fe({value: t2, typeName: Ye.ZodLiteral, ...oe(e2)});
class $e extends ce {
  P(t2) {
    if (typeof t2.data != "string") {
      const e2 = this._(t2);
      return Yt(e2, {expected: Rt.joinValues(this.k.values), received: e2.parsedType, code: zt.invalid_type}), Xt;
    }
    if (this.k.values.indexOf(t2.data) === -1) {
      const e2 = this._(t2);
      return Yt(e2, {received: e2.data, code: zt.invalid_enum_value, options: this.k.values}), Xt;
    }
    return te(t2.data);
  }
  get options() {
    return this.k.values;
  }
  get enum() {
    const t2 = {};
    for (const e2 of this.k.values)
      t2[e2] = e2;
    return t2;
  }
  get Values() {
    const t2 = {};
    for (const e2 of this.k.values)
      t2[e2] = e2;
    return t2;
  }
  get Enum() {
    const t2 = {};
    for (const e2 of this.k.values)
      t2[e2] = e2;
    return t2;
  }
}
$e.create = function(t2, e2) {
  return new $e({values: t2, typeName: Ye.ZodEnum, ...oe(e2)});
};
class Be extends ce {
  P(t2) {
    const e2 = Rt.getValidEnumValues(this.k.values), n2 = this._(t2);
    if (n2.parsedType !== Ht.string && n2.parsedType !== Ht.number) {
      const t3 = Rt.objectValues(e2);
      return Yt(n2, {expected: Rt.joinValues(t3), received: n2.parsedType, code: zt.invalid_type}), Xt;
    }
    if (e2.indexOf(t2.data) === -1) {
      const t3 = Rt.objectValues(e2);
      return Yt(n2, {received: n2.data, code: zt.invalid_enum_value, options: t3}), Xt;
    }
    return te(t2.data);
  }
  get enum() {
    return this.k.values;
  }
}
Be.create = (t2, e2) => new Be({values: t2, typeName: Ye.ZodNativeEnum, ...oe(e2)});
class Ge extends ce {
  P(t2) {
    const {ctx: e2} = this.I(t2);
    if (e2.parsedType !== Ht.promise && e2.common.async === false)
      return Yt(e2, {code: zt.invalid_type, expected: Ht.promise, received: e2.parsedType}), Xt;
    const n2 = e2.parsedType === Ht.promise ? e2.data : Promise.resolve(e2.data);
    return te(n2.then((t3) => this.k.type.parseAsync(t3, {path: e2.path, errorMap: e2.common.contextualErrorMap})));
  }
}
Ge.create = (t2, e2) => new Ge({type: t2, typeName: Ye.ZodPromise, ...oe(e2)});
class He extends ce {
  innerType() {
    return this.k.schema;
  }
  P(t2) {
    const {status: e2, ctx: n2} = this.I(t2), r2 = this.k.effect || null;
    if (r2.type === "preprocess") {
      const t3 = r2.transform(n2.data);
      return n2.common.async ? Promise.resolve(t3).then((t4) => this.k.schema.L({data: t4, path: n2.path, parent: n2})) : this.k.schema.O({data: t3, path: n2.path, parent: n2});
    }
    const i2 = {addIssue: (t3) => {
      Yt(n2, t3), t3.fatal ? e2.abort() : e2.dirty();
    }, get path() {
      return n2.path;
    }};
    if (i2.addIssue = i2.addIssue.bind(i2), r2.type === "refinement") {
      const t3 = (t4) => {
        const e3 = r2.refinement(t4, i2);
        if (n2.common.async)
          return Promise.resolve(e3);
        if (e3 instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return t4;
      };
      if (n2.common.async === false) {
        const r3 = this.k.schema.O({data: n2.data, path: n2.path, parent: n2});
        return r3.status === "aborted" ? Xt : (r3.status === "dirty" && e2.dirty(), t3(r3.value), {status: e2.value, value: r3.value});
      }
      return this.k.schema.L({data: n2.data, path: n2.path, parent: n2}).then((n3) => n3.status === "aborted" ? Xt : (n3.status === "dirty" && e2.dirty(), t3(n3.value).then(() => ({status: e2.value, value: n3.value}))));
    }
    if (r2.type === "transform") {
      if (n2.common.async === false) {
        const t3 = this.k.schema.O({data: n2.data, path: n2.path, parent: n2});
        if (!re(t3))
          return t3;
        const s2 = r2.transform(t3.value, i2);
        if (s2 instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return {status: e2.value, value: s2};
      }
      return this.k.schema.L({data: n2.data, path: n2.path, parent: n2}).then((t3) => re(t3) ? Promise.resolve(r2.transform(t3.value, i2)).then((t4) => ({status: e2.value, value: t4})) : t3);
    }
    Rt.assertNever(r2);
  }
}
He.create = (t2, e2, n2) => new He({schema: t2, typeName: Ye.ZodEffects, effect: e2, ...oe(n2)}), He.createWithPreprocess = (t2, e2, n2) => new He({schema: e2, effect: {type: "preprocess", transform: t2}, typeName: Ye.ZodEffects, ...oe(n2)});
class Ke extends ce {
  P(t2) {
    return this.N(t2) === Ht.undefined ? te(void 0) : this.k.innerType.P(t2);
  }
  unwrap() {
    return this.k.innerType;
  }
}
Ke.create = (t2, e2) => new Ke({innerType: t2, typeName: Ye.ZodOptional, ...oe(e2)});
class ze extends ce {
  P(t2) {
    return this.N(t2) === Ht.null ? te(null) : this.k.innerType.P(t2);
  }
  unwrap() {
    return this.k.innerType;
  }
}
ze.create = (t2, e2) => new ze({innerType: t2, typeName: Ye.ZodNullable, ...oe(e2)});
class qe extends ce {
  P(t2) {
    const {ctx: e2} = this.I(t2);
    let n2 = e2.data;
    return e2.parsedType === Ht.undefined && (n2 = this.k.defaultValue()), this.k.innerType.P({data: n2, path: e2.path, parent: e2});
  }
  removeDefault() {
    return this.k.innerType;
  }
}
qe.create = (t2, e2) => new Ke({innerType: t2, typeName: Ye.ZodOptional, ...oe(e2)});
class Ve extends ce {
  P(t2) {
    if (this.N(t2) !== Ht.nan) {
      const e2 = this._(t2);
      return Yt(e2, {code: zt.invalid_type, expected: Ht.nan, received: e2.parsedType}), Xt;
    }
    return {status: "valid", value: t2.data};
  }
}
Ve.create = (t2) => new Ve({typeName: Ye.ZodNaN, ...oe(t2)});
const Je = (t2, e2 = {}, n2) => t2 ? ke.create().superRefine((r2, i2) => {
  if (!t2(r2)) {
    const t3 = typeof e2 == "function" ? e2(r2) : e2;
    i2.addIssue({code: "custom", ...typeof t3 == "string" ? {message: t3} : t3, fatal: n2});
  }
}) : ke.create(), We = {object: Ie.lazycreate};
var Ye;
!function(t2) {
  t2.ZodString = "ZodString", t2.ZodNumber = "ZodNumber", t2.ZodNaN = "ZodNaN", t2.ZodBigInt = "ZodBigInt", t2.ZodBoolean = "ZodBoolean", t2.ZodDate = "ZodDate", t2.ZodUndefined = "ZodUndefined", t2.ZodNull = "ZodNull", t2.ZodAny = "ZodAny", t2.ZodUnknown = "ZodUnknown", t2.ZodNever = "ZodNever", t2.ZodVoid = "ZodVoid", t2.ZodArray = "ZodArray", t2.ZodObject = "ZodObject", t2.ZodUnion = "ZodUnion", t2.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t2.ZodIntersection = "ZodIntersection", t2.ZodTuple = "ZodTuple", t2.ZodRecord = "ZodRecord", t2.ZodMap = "ZodMap", t2.ZodSet = "ZodSet", t2.ZodFunction = "ZodFunction", t2.ZodLazy = "ZodLazy", t2.ZodLiteral = "ZodLiteral", t2.ZodEnum = "ZodEnum", t2.ZodEffects = "ZodEffects", t2.ZodNativeEnum = "ZodNativeEnum", t2.ZodOptional = "ZodOptional", t2.ZodNullable = "ZodNullable", t2.ZodDefault = "ZodDefault", t2.ZodPromise = "ZodPromise";
}(Ye || (Ye = {}));
const Qe = fe.create, Xe = ve.create, tn = pe.create, en = He.create;
var nn = /* @__PURE__ */ Object.freeze({__proto__: null, getParsedType: Kt, ZodParsedType: Ht, makeIssue: Wt, EMPTY_PATH: [], addIssueToContext: Yt, ParseStatus: Qt, INVALID: Xt, DIRTY: (t2) => ({status: "dirty", value: t2}), OK: te, isAborted: ee, isDirty: ne, isValid: re, isAsync: ie, ZodType: ce, ZodString: fe, ZodNumber: ve, ZodBigInt: ye, ZodBoolean: pe, ZodDate: ge, ZodUndefined: we, ZodNull: be, ZodAny: ke, ZodUnknown: Ne, ZodNever: Me, ZodVoid: xe, ZodArray: Ee, get objectUtil() {
  return Se;
}, ZodObject: Ie, ZodUnion: Ze, ZodDiscriminatedUnion: Ae, ZodIntersection: Oe, ZodTuple: Pe, ZodRecord: Ce, ZodMap: Le, ZodSet: Ue, ZodFunction: je, ZodLazy: Re, ZodLiteral: Fe, ZodEnum: $e, ZodNativeEnum: Be, ZodPromise: Ge, ZodEffects: He, ZodTransformer: He, ZodOptional: Ke, ZodNullable: ze, ZodDefault: qe, ZodNaN: Ve, custom: Je, Schema: ce, ZodSchema: ce, late: We, get ZodFirstPartyTypeKind() {
  return Ye;
}, any: ke.create, array: Ee.create, bigint: ye.create, boolean: tn, date: ge.create, discriminatedUnion: Ae.create, effect: en, enum: $e.create, function: je.create, instanceof: (t2, e2 = {message: `Input not instance of ${t2.name}`}) => Je((e3) => e3 instanceof t2, e2, true), intersection: Oe.create, lazy: Re.create, literal: Fe.create, map: Le.create, nan: Ve.create, nativeEnum: Be.create, never: Me.create, null: be.create, nullable: ze.create, number: Xe, object: Ie.create, oboolean: () => tn().optional(), onumber: () => Xe().optional(), optional: Ke.create, ostring: () => Qe().optional(), preprocess: He.createWithPreprocess, promise: Ge.create, record: Ce.create, set: Ue.create, strictObject: Ie.strictCreate, string: Qe, transformer: en, tuple: Pe.create, undefined: we.create, union: Ze.create, unknown: Ne.create, void: xe.create, ZodIssueCode: zt, quotelessJson: (t2) => JSON.stringify(t2, null, 2).replace(/"([^"]+)":/g, "$1:"), ZodError: qt, defaultErrorMap: Vt, get overrideErrorMap() {
  return Jt;
}, setErrorMap: (t2) => {
  Jt = t2;
}});
function rn(t2, e2) {
  for (var n2 = 0; n2 < e2.length; n2++) {
    var r2 = e2[n2];
    r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t2, r2.key, r2);
  }
}
function sn(t2, e2, n2) {
  return e2 && rn(t2.prototype, e2), n2 && rn(t2, n2), t2;
}
function an() {
  return (an = Object.assign || function(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var n2 = arguments[e2];
      for (var r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (t2[r2] = n2[r2]);
    }
    return t2;
  }).apply(this, arguments);
}
function un(t2, e2) {
  t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, cn(t2, e2);
}
function on(t2) {
  return (on = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  })(t2);
}
function cn(t2, e2) {
  return (cn = Object.setPrototypeOf || function(t3, e3) {
    return t3.__proto__ = e3, t3;
  })(t2, e2);
}
function hn() {
  if (typeof Reflect == "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy == "function")
    return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch (t2) {
    return false;
  }
}
function dn(t2, e2, n2) {
  return (dn = hn() ? Reflect.construct : function(t3, e3, n3) {
    var r2 = [null];
    r2.push.apply(r2, e3);
    var i2 = new (Function.bind.apply(t3, r2))();
    return n3 && cn(i2, n3.prototype), i2;
  }).apply(null, arguments);
}
function ln(t2) {
  var e2 = typeof Map == "function" ? new Map() : void 0;
  return (ln = function(t3) {
    if (t3 === null || Function.toString.call(t3).indexOf("[native code]") === -1)
      return t3;
    if (typeof t3 != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (e2 !== void 0) {
      if (e2.has(t3))
        return e2.get(t3);
      e2.set(t3, n2);
    }
    function n2() {
      return dn(t3, arguments, on(this).constructor);
    }
    return n2.prototype = Object.create(t3.prototype, {constructor: {value: n2, enumerable: false, writable: true, configurable: true}}), cn(n2, t3);
  })(t2);
}
function fn(t2, e2) {
  if (t2 == null)
    return {};
  var n2, r2, i2 = {}, s2 = Object.keys(t2);
  for (r2 = 0; r2 < s2.length; r2++)
    e2.indexOf(n2 = s2[r2]) >= 0 || (i2[n2] = t2[n2]);
  return i2;
}
function mn(t2, e2) {
  (e2 == null || e2 > t2.length) && (e2 = t2.length);
  for (var n2 = 0, r2 = new Array(e2); n2 < e2; n2++)
    r2[n2] = t2[n2];
  return r2;
}
function vn(t2, e2) {
  var n2 = typeof Symbol != "undefined" && t2[Symbol.iterator] || t2["@@iterator"];
  if (n2)
    return (n2 = n2.call(t2)).next.bind(n2);
  if (Array.isArray(t2) || (n2 = function(t3, e3) {
    if (t3) {
      if (typeof t3 == "string")
        return mn(t3, e3);
      var n3 = Object.prototype.toString.call(t3).slice(8, -1);
      return n3 === "Object" && t3.constructor && (n3 = t3.constructor.name), n3 === "Map" || n3 === "Set" ? Array.from(t3) : n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? mn(t3, e3) : void 0;
    }
  }(t2)) || e2 && t2 && typeof t2.length == "number") {
    n2 && (t2 = n2);
    var r2 = 0;
    return function() {
      return r2 >= t2.length ? {done: true} : {done: false, value: t2[r2++]};
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var yn = /* @__PURE__ */ function(t2) {
  function e2() {
    return t2.apply(this, arguments) || this;
  }
  return un(e2, t2), e2;
}(/* @__PURE__ */ ln(Error)), pn = /* @__PURE__ */ function(t2) {
  function e2(e3) {
    return t2.call(this, "Invalid DateTime: " + e3.toMessage()) || this;
  }
  return un(e2, t2), e2;
}(yn), gn = /* @__PURE__ */ function(t2) {
  function e2(e3) {
    return t2.call(this, "Invalid Interval: " + e3.toMessage()) || this;
  }
  return un(e2, t2), e2;
}(yn), wn = /* @__PURE__ */ function(t2) {
  function e2(e3) {
    return t2.call(this, "Invalid Duration: " + e3.toMessage()) || this;
  }
  return un(e2, t2), e2;
}(yn), bn = /* @__PURE__ */ function(t2) {
  function e2() {
    return t2.apply(this, arguments) || this;
  }
  return un(e2, t2), e2;
}(yn), kn = /* @__PURE__ */ function(t2) {
  function e2(e3) {
    return t2.call(this, "Invalid unit " + e3) || this;
  }
  return un(e2, t2), e2;
}(yn), Nn = /* @__PURE__ */ function(t2) {
  function e2() {
    return t2.apply(this, arguments) || this;
  }
  return un(e2, t2), e2;
}(yn), Mn = /* @__PURE__ */ function(t2) {
  function e2() {
    return t2.call(this, "Zone is an abstract class") || this;
  }
  return un(e2, t2), e2;
}(yn), xn = "numeric", En = "short", Sn = "long", Tn = {year: xn, month: xn, day: xn}, _n = {year: xn, month: En, day: xn}, In = {year: xn, month: En, day: xn, weekday: En}, Zn = {year: xn, month: Sn, day: xn}, An = {year: xn, month: Sn, day: xn, weekday: Sn}, Dn = {hour: xn, minute: xn}, On = {hour: xn, minute: xn, second: xn}, Pn = {hour: xn, minute: xn, second: xn, timeZoneName: En}, Cn = {hour: xn, minute: xn, second: xn, timeZoneName: Sn}, Ln = {hour: xn, minute: xn, hourCycle: "h23"}, Un = {hour: xn, minute: xn, second: xn, hourCycle: "h23"}, jn = {hour: xn, minute: xn, second: xn, hourCycle: "h23", timeZoneName: En}, Rn = {hour: xn, minute: xn, second: xn, hourCycle: "h23", timeZoneName: Sn}, Fn = {year: xn, month: xn, day: xn, hour: xn, minute: xn}, $n = {year: xn, month: xn, day: xn, hour: xn, minute: xn, second: xn}, Bn = {year: xn, month: En, day: xn, hour: xn, minute: xn}, Gn = {year: xn, month: En, day: xn, hour: xn, minute: xn, second: xn}, Hn = {year: xn, month: En, day: xn, weekday: En, hour: xn, minute: xn}, Kn = {year: xn, month: Sn, day: xn, hour: xn, minute: xn, timeZoneName: En}, zn = {year: xn, month: Sn, day: xn, hour: xn, minute: xn, second: xn, timeZoneName: En}, qn = {year: xn, month: Sn, day: xn, weekday: Sn, hour: xn, minute: xn, timeZoneName: Sn}, Vn = {year: xn, month: Sn, day: xn, weekday: Sn, hour: xn, minute: xn, second: xn, timeZoneName: Sn};
function Jn(t2) {
  return t2 === void 0;
}
function Wn(t2) {
  return typeof t2 == "number";
}
function Yn(t2) {
  return typeof t2 == "number" && t2 % 1 == 0;
}
function Qn() {
  try {
    return typeof Intl != "undefined" && !!Intl.RelativeTimeFormat;
  } catch (t2) {
    return false;
  }
}
function Xn(t2, e2, n2) {
  if (t2.length !== 0)
    return t2.reduce(function(t3, r2) {
      var i2 = [e2(r2), r2];
      return t3 && n2(t3[0], i2[0]) === t3[0] ? t3 : i2;
    }, null)[1];
}
function tr(t2, e2) {
  return Object.prototype.hasOwnProperty.call(t2, e2);
}
function er(t2, e2, n2) {
  return Yn(t2) && t2 >= e2 && t2 <= n2;
}
function nr(t2, e2) {
  return e2 === void 0 && (e2 = 2), t2 < 0 ? "-" + ("" + -t2).padStart(e2, "0") : ("" + t2).padStart(e2, "0");
}
function rr(t2) {
  return Jn(t2) || t2 === null || t2 === "" ? void 0 : parseInt(t2, 10);
}
function ir(t2) {
  return Jn(t2) || t2 === null || t2 === "" ? void 0 : parseFloat(t2);
}
function sr(t2) {
  if (!Jn(t2) && t2 !== null && t2 !== "") {
    var e2 = 1e3 * parseFloat("0." + t2);
    return Math.floor(e2);
  }
}
function ar(t2, e2, n2) {
  n2 === void 0 && (n2 = false);
  var r2 = Math.pow(10, e2);
  return (n2 ? Math.trunc : Math.round)(t2 * r2) / r2;
}
function ur(t2) {
  return t2 % 4 == 0 && (t2 % 100 != 0 || t2 % 400 == 0);
}
function or(t2) {
  return ur(t2) ? 366 : 365;
}
function cr(t2, e2) {
  var n2, r2 = (n2 = e2 - 1) - 12 * Math.floor(n2 / 12) + 1;
  return r2 === 2 ? ur(t2 + (e2 - r2) / 12) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][r2 - 1];
}
function hr(t2) {
  var e2 = Date.UTC(t2.year, t2.month - 1, t2.day, t2.hour, t2.minute, t2.second, t2.millisecond);
  return t2.year < 100 && t2.year >= 0 && (e2 = new Date(e2)).setUTCFullYear(e2.getUTCFullYear() - 1900), +e2;
}
function dr(t2) {
  var e2 = (t2 + Math.floor(t2 / 4) - Math.floor(t2 / 100) + Math.floor(t2 / 400)) % 7, n2 = t2 - 1, r2 = (n2 + Math.floor(n2 / 4) - Math.floor(n2 / 100) + Math.floor(n2 / 400)) % 7;
  return e2 === 4 || r2 === 3 ? 53 : 52;
}
function lr(t2) {
  return t2 > 99 ? t2 : t2 > 60 ? 1900 + t2 : 2e3 + t2;
}
function fr(t2, e2, n2, r2) {
  r2 === void 0 && (r2 = null);
  var i2 = new Date(t2), s2 = {hourCycle: "h23", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit"};
  r2 && (s2.timeZone = r2);
  var a2 = an({timeZoneName: e2}, s2), u2 = new Intl.DateTimeFormat(n2, a2).formatToParts(i2).find(function(t3) {
    return t3.type.toLowerCase() === "timezonename";
  });
  return u2 ? u2.value : null;
}
function mr(t2, e2) {
  var n2 = parseInt(t2, 10);
  Number.isNaN(n2) && (n2 = 0);
  var r2 = parseInt(e2, 10) || 0;
  return 60 * n2 + (n2 < 0 || Object.is(n2, -0) ? -r2 : r2);
}
function vr(t2) {
  var e2 = Number(t2);
  if (typeof t2 == "boolean" || t2 === "" || Number.isNaN(e2))
    throw new Nn("Invalid unit value " + t2);
  return e2;
}
function yr(t2, e2) {
  var n2 = {};
  for (var r2 in t2)
    if (tr(t2, r2)) {
      var i2 = t2[r2];
      if (i2 == null)
        continue;
      n2[e2(r2)] = vr(i2);
    }
  return n2;
}
function pr(t2, e2) {
  var n2 = Math.trunc(Math.abs(t2 / 60)), r2 = Math.trunc(Math.abs(t2 % 60)), i2 = t2 >= 0 ? "+" : "-";
  switch (e2) {
    case "short":
      return "" + i2 + nr(n2, 2) + ":" + nr(r2, 2);
    case "narrow":
      return "" + i2 + n2 + (r2 > 0 ? ":" + r2 : "");
    case "techie":
      return "" + i2 + nr(n2, 2) + nr(r2, 2);
    default:
      throw new RangeError("Value format " + e2 + " is out of range for property format");
  }
}
function gr(t2) {
  return function(t3, e2) {
    return ["hour", "minute", "second", "millisecond"].reduce(function(e3, n2) {
      return e3[n2] = t3[n2], e3;
    }, {});
  }(t2);
}
var wr = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/, br = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], kr = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], Nr = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function Mr(t2) {
  switch (t2) {
    case "narrow":
      return [].concat(Nr);
    case "short":
      return [].concat(kr);
    case "long":
      return [].concat(br);
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var xr = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], Er = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], Sr = ["M", "T", "W", "T", "F", "S", "S"];
function Tr(t2) {
  switch (t2) {
    case "narrow":
      return [].concat(Sr);
    case "short":
      return [].concat(Er);
    case "long":
      return [].concat(xr);
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var _r = ["AM", "PM"], Ir = ["Before Christ", "Anno Domini"], Zr = ["BC", "AD"], Ar = ["B", "A"];
function Dr(t2) {
  switch (t2) {
    case "narrow":
      return [].concat(Ar);
    case "short":
      return [].concat(Zr);
    case "long":
      return [].concat(Ir);
    default:
      return null;
  }
}
function Or(t2, e2) {
  for (var n2, r2 = "", i2 = vn(t2); !(n2 = i2()).done; ) {
    var s2 = n2.value;
    r2 += s2.literal ? s2.val : e2(s2.val);
  }
  return r2;
}
var Pr = {D: Tn, DD: _n, DDD: Zn, DDDD: An, t: Dn, tt: On, ttt: Pn, tttt: Cn, T: Ln, TT: Un, TTT: jn, TTTT: Rn, f: Fn, ff: Bn, fff: Kn, ffff: qn, F: $n, FF: Gn, FFF: zn, FFFF: Vn}, Cr = /* @__PURE__ */ function() {
  function t2(t3, e3) {
    this.opts = e3, this.loc = t3, this.systemLoc = null;
  }
  t2.create = function(e3, n2) {
    return n2 === void 0 && (n2 = {}), new t2(e3, n2);
  }, t2.parseFormat = function(t3) {
    for (var e3 = null, n2 = "", r2 = false, i2 = [], s2 = 0; s2 < t3.length; s2++) {
      var a2 = t3.charAt(s2);
      a2 === "'" ? (n2.length > 0 && i2.push({literal: r2, val: n2}), e3 = null, n2 = "", r2 = !r2) : r2 || a2 === e3 ? n2 += a2 : (n2.length > 0 && i2.push({literal: false, val: n2}), n2 = a2, e3 = a2);
    }
    return n2.length > 0 && i2.push({literal: r2, val: n2}), i2;
  }, t2.macroTokenToFormatOpts = function(t3) {
    return Pr[t3];
  };
  var e2 = t2.prototype;
  return e2.formatWithSystemDefault = function(t3, e3) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(t3, an({}, this.opts, e3)).format();
  }, e2.formatDateTime = function(t3, e3) {
    return e3 === void 0 && (e3 = {}), this.loc.dtFormatter(t3, an({}, this.opts, e3)).format();
  }, e2.formatDateTimeParts = function(t3, e3) {
    return e3 === void 0 && (e3 = {}), this.loc.dtFormatter(t3, an({}, this.opts, e3)).formatToParts();
  }, e2.resolvedOptions = function(t3, e3) {
    return e3 === void 0 && (e3 = {}), this.loc.dtFormatter(t3, an({}, this.opts, e3)).resolvedOptions();
  }, e2.num = function(t3, e3) {
    if (e3 === void 0 && (e3 = 0), this.opts.forceSimple)
      return nr(t3, e3);
    var n2 = an({}, this.opts);
    return e3 > 0 && (n2.padTo = e3), this.loc.numberFormatter(n2).format(t3);
  }, e2.formatDateTimeFromString = function(e3, n2) {
    var r2 = this, i2 = this.loc.listingMode() === "en", s2 = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", a2 = function(t3, n3) {
      return r2.loc.extract(e3, t3, n3);
    }, u2 = function(t3) {
      return e3.isOffsetFixed && e3.offset === 0 && t3.allowZ ? "Z" : e3.isValid ? e3.zone.formatOffset(e3.ts, t3.format) : "";
    }, o2 = function(t3, n3) {
      return i2 ? function(t4, e4) {
        return Mr(e4)[t4.month - 1];
      }(e3, t3) : a2(n3 ? {month: t3} : {month: t3, day: "numeric"}, "month");
    }, c2 = function(t3, n3) {
      return i2 ? function(t4, e4) {
        return Tr(e4)[t4.weekday - 1];
      }(e3, t3) : a2(n3 ? {weekday: t3} : {weekday: t3, month: "long", day: "numeric"}, "weekday");
    }, h2 = function(t3) {
      return i2 ? function(t4, e4) {
        return Dr(e4)[t4.year < 0 ? 0 : 1];
      }(e3, t3) : a2({era: t3}, "era");
    };
    return Or(t2.parseFormat(n2), function(n3) {
      switch (n3) {
        case "S":
          return r2.num(e3.millisecond);
        case "u":
        case "SSS":
          return r2.num(e3.millisecond, 3);
        case "s":
          return r2.num(e3.second);
        case "ss":
          return r2.num(e3.second, 2);
        case "uu":
          return r2.num(Math.floor(e3.millisecond / 10), 2);
        case "uuu":
          return r2.num(Math.floor(e3.millisecond / 100));
        case "m":
          return r2.num(e3.minute);
        case "mm":
          return r2.num(e3.minute, 2);
        case "h":
          return r2.num(e3.hour % 12 == 0 ? 12 : e3.hour % 12);
        case "hh":
          return r2.num(e3.hour % 12 == 0 ? 12 : e3.hour % 12, 2);
        case "H":
          return r2.num(e3.hour);
        case "HH":
          return r2.num(e3.hour, 2);
        case "Z":
          return u2({format: "narrow", allowZ: r2.opts.allowZ});
        case "ZZ":
          return u2({format: "short", allowZ: r2.opts.allowZ});
        case "ZZZ":
          return u2({format: "techie", allowZ: r2.opts.allowZ});
        case "ZZZZ":
          return e3.zone.offsetName(e3.ts, {format: "short", locale: r2.loc.locale});
        case "ZZZZZ":
          return e3.zone.offsetName(e3.ts, {format: "long", locale: r2.loc.locale});
        case "z":
          return e3.zoneName;
        case "a":
          return i2 ? function(t3) {
            return _r[t3.hour < 12 ? 0 : 1];
          }(e3) : a2({hour: "numeric", hourCycle: "h12"}, "dayperiod");
        case "d":
          return s2 ? a2({day: "numeric"}, "day") : r2.num(e3.day);
        case "dd":
          return s2 ? a2({day: "2-digit"}, "day") : r2.num(e3.day, 2);
        case "c":
          return r2.num(e3.weekday);
        case "ccc":
          return c2("short", true);
        case "cccc":
          return c2("long", true);
        case "ccccc":
          return c2("narrow", true);
        case "E":
          return r2.num(e3.weekday);
        case "EEE":
          return c2("short", false);
        case "EEEE":
          return c2("long", false);
        case "EEEEE":
          return c2("narrow", false);
        case "L":
          return s2 ? a2({month: "numeric", day: "numeric"}, "month") : r2.num(e3.month);
        case "LL":
          return s2 ? a2({month: "2-digit", day: "numeric"}, "month") : r2.num(e3.month, 2);
        case "LLL":
          return o2("short", true);
        case "LLLL":
          return o2("long", true);
        case "LLLLL":
          return o2("narrow", true);
        case "M":
          return s2 ? a2({month: "numeric"}, "month") : r2.num(e3.month);
        case "MM":
          return s2 ? a2({month: "2-digit"}, "month") : r2.num(e3.month, 2);
        case "MMM":
          return o2("short", false);
        case "MMMM":
          return o2("long", false);
        case "MMMMM":
          return o2("narrow", false);
        case "y":
          return s2 ? a2({year: "numeric"}, "year") : r2.num(e3.year);
        case "yy":
          return s2 ? a2({year: "2-digit"}, "year") : r2.num(e3.year.toString().slice(-2), 2);
        case "yyyy":
          return s2 ? a2({year: "numeric"}, "year") : r2.num(e3.year, 4);
        case "yyyyyy":
          return s2 ? a2({year: "numeric"}, "year") : r2.num(e3.year, 6);
        case "G":
          return h2("short");
        case "GG":
          return h2("long");
        case "GGGGG":
          return h2("narrow");
        case "kk":
          return r2.num(e3.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return r2.num(e3.weekYear, 4);
        case "W":
          return r2.num(e3.weekNumber);
        case "WW":
          return r2.num(e3.weekNumber, 2);
        case "o":
          return r2.num(e3.ordinal);
        case "ooo":
          return r2.num(e3.ordinal, 3);
        case "q":
          return r2.num(e3.quarter);
        case "qq":
          return r2.num(e3.quarter, 2);
        case "X":
          return r2.num(Math.floor(e3.ts / 1e3));
        case "x":
          return r2.num(e3.ts);
        default:
          return function(n4) {
            var i3 = t2.macroTokenToFormatOpts(n4);
            return i3 ? r2.formatWithSystemDefault(e3, i3) : n4;
          }(n3);
      }
    });
  }, e2.formatDurationFromString = function(e3, n2) {
    var r2, i2 = this, s2 = function(t3) {
      switch (t3[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, a2 = t2.parseFormat(n2), u2 = a2.reduce(function(t3, e4) {
      return e4.literal ? t3 : t3.concat(e4.val);
    }, []), o2 = e3.shiftTo.apply(e3, u2.map(s2).filter(function(t3) {
      return t3;
    }));
    return Or(a2, (r2 = o2, function(t3) {
      var e4 = s2(t3);
      return e4 ? i2.num(r2.get(e4), t3.length) : t3;
    }));
  }, t2;
}(), Lr = /* @__PURE__ */ function() {
  function t2(t3, e2) {
    this.reason = t3, this.explanation = e2;
  }
  return t2.prototype.toMessage = function() {
    return this.explanation ? this.reason + ": " + this.explanation : this.reason;
  }, t2;
}(), Ur = /* @__PURE__ */ function() {
  function t2() {
  }
  var e2 = t2.prototype;
  return e2.offsetName = function(t3, e3) {
    throw new Mn();
  }, e2.formatOffset = function(t3, e3) {
    throw new Mn();
  }, e2.offset = function(t3) {
    throw new Mn();
  }, e2.equals = function(t3) {
    throw new Mn();
  }, sn(t2, [{key: "type", get: function() {
    throw new Mn();
  }}, {key: "name", get: function() {
    throw new Mn();
  }}, {key: "ianaName", get: function() {
    return this.name;
  }}, {key: "isUniversal", get: function() {
    throw new Mn();
  }}, {key: "isValid", get: function() {
    throw new Mn();
  }}]), t2;
}(), jr = null, Rr = /* @__PURE__ */ function(t2) {
  function e2() {
    return t2.apply(this, arguments) || this;
  }
  un(e2, t2);
  var n2 = e2.prototype;
  return n2.offsetName = function(t3, e3) {
    return fr(t3, e3.format, e3.locale);
  }, n2.formatOffset = function(t3, e3) {
    return pr(this.offset(t3), e3);
  }, n2.offset = function(t3) {
    return -new Date(t3).getTimezoneOffset();
  }, n2.equals = function(t3) {
    return t3.type === "system";
  }, sn(e2, [{key: "type", get: function() {
    return "system";
  }}, {key: "name", get: function() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }}, {key: "isUniversal", get: function() {
    return false;
  }}, {key: "isValid", get: function() {
    return true;
  }}], [{key: "instance", get: function() {
    return jr === null && (jr = new e2()), jr;
  }}]), e2;
}(Ur), Fr = {}, $r = {year: 0, month: 1, day: 2, era: 3, hour: 4, minute: 5, second: 6}, Br = {}, Gr = /* @__PURE__ */ function(t2) {
  function e2(n3) {
    var r2;
    return (r2 = t2.call(this) || this).zoneName = n3, r2.valid = e2.isValidZone(n3), r2;
  }
  un(e2, t2), e2.create = function(t3) {
    return Br[t3] || (Br[t3] = new e2(t3)), Br[t3];
  }, e2.resetCache = function() {
    Br = {}, Fr = {};
  }, e2.isValidSpecifier = function(t3) {
    return this.isValidZone(t3);
  }, e2.isValidZone = function(t3) {
    if (!t3)
      return false;
    try {
      return new Intl.DateTimeFormat("en-US", {timeZone: t3}).format(), true;
    } catch (t4) {
      return false;
    }
  };
  var n2 = e2.prototype;
  return n2.offsetName = function(t3, e3) {
    return fr(t3, e3.format, e3.locale, this.name);
  }, n2.formatOffset = function(t3, e3) {
    return pr(this.offset(t3), e3);
  }, n2.offset = function(t3) {
    var e3 = new Date(t3);
    if (isNaN(e3))
      return NaN;
    var n3, r2 = (Fr[n3 = this.name] || (Fr[n3] = new Intl.DateTimeFormat("en-US", {hour12: false, timeZone: n3, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", era: "short"})), Fr[n3]), i2 = r2.formatToParts ? function(t4, e4) {
      for (var n4 = t4.formatToParts(e4), r3 = [], i3 = 0; i3 < n4.length; i3++) {
        var s3 = n4[i3], a3 = s3.type, u3 = s3.value, o3 = $r[a3];
        a3 === "era" ? r3[o3] = u3 : Jn(o3) || (r3[o3] = parseInt(u3, 10));
      }
      return r3;
    }(r2, e3) : function(t4, e4) {
      var n4 = t4.format(e4).replace(/\u200E/g, ""), r3 = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n4);
      return [r3[3], r3[1], r3[2], r3[4], r3[5], r3[6], r3[7]];
    }(r2, e3), s2 = i2[0], a2 = i2[1], u2 = i2[2], o2 = i2[4], c2 = i2[5], h2 = i2[6];
    i2[3] === "BC" && (s2 = 1 - Math.abs(s2));
    var d2 = +e3, l2 = d2 % 1e3;
    return (hr({year: s2, month: a2, day: u2, hour: o2 === 24 ? 0 : o2, minute: c2, second: h2, millisecond: 0}) - (d2 -= l2 >= 0 ? l2 : 1e3 + l2)) / 6e4;
  }, n2.equals = function(t3) {
    return t3.type === "iana" && t3.name === this.name;
  }, sn(e2, [{key: "type", get: function() {
    return "iana";
  }}, {key: "name", get: function() {
    return this.zoneName;
  }}, {key: "isUniversal", get: function() {
    return false;
  }}, {key: "isValid", get: function() {
    return this.valid;
  }}]), e2;
}(Ur), Hr = null, Kr = /* @__PURE__ */ function(t2) {
  function e2(e3) {
    var n3;
    return (n3 = t2.call(this) || this).fixed = e3, n3;
  }
  un(e2, t2), e2.instance = function(t3) {
    return t3 === 0 ? e2.utcInstance : new e2(t3);
  }, e2.parseSpecifier = function(t3) {
    if (t3) {
      var n3 = t3.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (n3)
        return new e2(mr(n3[1], n3[2]));
    }
    return null;
  };
  var n2 = e2.prototype;
  return n2.offsetName = function() {
    return this.name;
  }, n2.formatOffset = function(t3, e3) {
    return pr(this.fixed, e3);
  }, n2.offset = function() {
    return this.fixed;
  }, n2.equals = function(t3) {
    return t3.type === "fixed" && t3.fixed === this.fixed;
  }, sn(e2, [{key: "type", get: function() {
    return "fixed";
  }}, {key: "name", get: function() {
    return this.fixed === 0 ? "UTC" : "UTC" + pr(this.fixed, "narrow");
  }}, {key: "ianaName", get: function() {
    return this.fixed === 0 ? "Etc/UTC" : "Etc/GMT" + pr(-this.fixed, "narrow");
  }}, {key: "isUniversal", get: function() {
    return true;
  }}, {key: "isValid", get: function() {
    return true;
  }}], [{key: "utcInstance", get: function() {
    return Hr === null && (Hr = new e2(0)), Hr;
  }}]), e2;
}(Ur), zr = /* @__PURE__ */ function(t2) {
  function e2(e3) {
    var n3;
    return (n3 = t2.call(this) || this).zoneName = e3, n3;
  }
  un(e2, t2);
  var n2 = e2.prototype;
  return n2.offsetName = function() {
    return null;
  }, n2.formatOffset = function() {
    return "";
  }, n2.offset = function() {
    return NaN;
  }, n2.equals = function() {
    return false;
  }, sn(e2, [{key: "type", get: function() {
    return "invalid";
  }}, {key: "name", get: function() {
    return this.zoneName;
  }}, {key: "isUniversal", get: function() {
    return false;
  }}, {key: "isValid", get: function() {
    return false;
  }}]), e2;
}(Ur);
function qr(t2, e2) {
  if (Jn(t2) || t2 === null)
    return e2;
  if (t2 instanceof Ur)
    return t2;
  if (typeof t2 == "string") {
    var n2 = t2.toLowerCase();
    return n2 === "local" || n2 === "system" ? e2 : n2 === "utc" || n2 === "gmt" ? Kr.utcInstance : Kr.parseSpecifier(n2) || Gr.create(t2);
  }
  return Wn(t2) ? Kr.instance(t2) : typeof t2 == "object" && t2.offset && typeof t2.offset == "number" ? t2 : new zr(t2);
}
var Vr, Jr = function() {
  return Date.now();
}, Wr = "system", Yr = null, Qr = null, Xr = null, ti = /* @__PURE__ */ function() {
  function t2() {
  }
  return t2.resetCaches = function() {
    fi.resetCache(), Gr.resetCache();
  }, sn(t2, null, [{key: "now", get: function() {
    return Jr;
  }, set: function(t3) {
    Jr = t3;
  }}, {key: "defaultZone", get: function() {
    return qr(Wr, Rr.instance);
  }, set: function(t3) {
    Wr = t3;
  }}, {key: "defaultLocale", get: function() {
    return Yr;
  }, set: function(t3) {
    Yr = t3;
  }}, {key: "defaultNumberingSystem", get: function() {
    return Qr;
  }, set: function(t3) {
    Qr = t3;
  }}, {key: "defaultOutputCalendar", get: function() {
    return Xr;
  }, set: function(t3) {
    Xr = t3;
  }}, {key: "throwOnInvalid", get: function() {
    return Vr;
  }, set: function(t3) {
    Vr = t3;
  }}]), t2;
}(), ei = ["base"], ni = ["padTo", "floor"], ri = {}, ii = {};
function si(t2, e2) {
  e2 === void 0 && (e2 = {});
  var n2 = JSON.stringify([t2, e2]), r2 = ii[n2];
  return r2 || (r2 = new Intl.DateTimeFormat(t2, e2), ii[n2] = r2), r2;
}
var ai = {}, ui = {}, oi = null;
function ci(t2, e2, n2, r2, i2) {
  var s2 = t2.listingMode(n2);
  return s2 === "error" ? null : s2 === "en" ? r2(e2) : i2(e2);
}
var hi = /* @__PURE__ */ function() {
  function t2(t3, e2, n2) {
    this.padTo = n2.padTo || 0, this.floor = n2.floor || false;
    var r2 = fn(n2, ni);
    if (!e2 || Object.keys(r2).length > 0) {
      var i2 = an({useGrouping: false}, n2);
      n2.padTo > 0 && (i2.minimumIntegerDigits = n2.padTo), this.inf = function(t4, e3) {
        e3 === void 0 && (e3 = {});
        var n3 = JSON.stringify([t4, e3]), r3 = ai[n3];
        return r3 || (r3 = new Intl.NumberFormat(t4, e3), ai[n3] = r3), r3;
      }(t3, i2);
    }
  }
  return t2.prototype.format = function(t3) {
    if (this.inf) {
      var e2 = this.floor ? Math.floor(t3) : t3;
      return this.inf.format(e2);
    }
    return nr(this.floor ? Math.floor(t3) : ar(t3, 3), this.padTo);
  }, t2;
}(), di = /* @__PURE__ */ function() {
  function t2(t3, e3, n2) {
    var r2;
    if (this.opts = n2, t3.zone.isUniversal) {
      var i2 = t3.offset / 60 * -1, s2 = i2 >= 0 ? "Etc/GMT+" + i2 : "Etc/GMT" + i2;
      t3.offset !== 0 && Gr.create(s2).valid ? (r2 = s2, this.dt = t3) : (r2 = "UTC", this.dt = n2.timeZoneName || t3.offset === 0 ? t3 : oa.fromMillis(t3.ts + 60 * t3.offset * 1e3));
    } else
      t3.zone.type === "system" ? this.dt = t3 : (this.dt = t3, r2 = t3.zone.name);
    var a2 = an({}, this.opts);
    r2 && (a2.timeZone = r2), this.dtf = si(e3, a2);
  }
  var e2 = t2.prototype;
  return e2.format = function() {
    return this.dtf.format(this.dt.toJSDate());
  }, e2.formatToParts = function() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }, e2.resolvedOptions = function() {
    return this.dtf.resolvedOptions();
  }, t2;
}(), li = /* @__PURE__ */ function() {
  function t2(t3, e3, n2) {
    this.opts = an({style: "long"}, n2), !e3 && Qn() && (this.rtf = function(t4, e4) {
      e4 === void 0 && (e4 = {});
      var n3 = fn(e4, ei), r2 = JSON.stringify([t4, n3]), i2 = ui[r2];
      return i2 || (i2 = new Intl.RelativeTimeFormat(t4, e4), ui[r2] = i2), i2;
    }(t3, n2));
  }
  var e2 = t2.prototype;
  return e2.format = function(t3, e3) {
    return this.rtf ? this.rtf.format(t3, e3) : function(t4, e4, n2, r2) {
      n2 === void 0 && (n2 = "always"), r2 === void 0 && (r2 = false);
      var i2 = {years: ["year", "yr."], quarters: ["quarter", "qtr."], months: ["month", "mo."], weeks: ["week", "wk."], days: ["day", "day", "days"], hours: ["hour", "hr."], minutes: ["minute", "min."], seconds: ["second", "sec."]}, s2 = ["hours", "minutes", "seconds"].indexOf(t4) === -1;
      if (n2 === "auto" && s2) {
        var a2 = t4 === "days";
        switch (e4) {
          case 1:
            return a2 ? "tomorrow" : "next " + i2[t4][0];
          case -1:
            return a2 ? "yesterday" : "last " + i2[t4][0];
          case 0:
            return a2 ? "today" : "this " + i2[t4][0];
        }
      }
      var u2 = Object.is(e4, -0) || e4 < 0, o2 = Math.abs(e4), c2 = o2 === 1, h2 = i2[t4], d2 = r2 ? c2 ? h2[1] : h2[2] || h2[1] : c2 ? i2[t4][0] : t4;
      return u2 ? o2 + " " + d2 + " ago" : "in " + o2 + " " + d2;
    }(e3, t3, this.opts.numeric, this.opts.style !== "long");
  }, e2.formatToParts = function(t3, e3) {
    return this.rtf ? this.rtf.formatToParts(t3, e3) : [];
  }, t2;
}(), fi = /* @__PURE__ */ function() {
  function t2(t3, e3, n2, r2) {
    var i2 = function(t4) {
      var e4 = t4.indexOf("-u-");
      if (e4 === -1)
        return [t4];
      var n3, r3 = t4.substring(0, e4);
      try {
        n3 = si(t4).resolvedOptions();
      } catch (t5) {
        n3 = si(r3).resolvedOptions();
      }
      return [r3, n3.numberingSystem, n3.calendar];
    }(t3), s2 = i2[1], a2 = i2[2];
    this.locale = i2[0], this.numberingSystem = e3 || s2 || null, this.outputCalendar = n2 || a2 || null, this.intl = function(t4, e4, n3) {
      return n3 || e4 ? (t4 += "-u", n3 && (t4 += "-ca-" + n3), e4 && (t4 += "-nu-" + e4), t4) : t4;
    }(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = {format: {}, standalone: {}}, this.monthsCache = {format: {}, standalone: {}}, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = r2, this.fastNumbersCached = null;
  }
  t2.fromOpts = function(e3) {
    return t2.create(e3.locale, e3.numberingSystem, e3.outputCalendar, e3.defaultToEN);
  }, t2.create = function(e3, n2, r2, i2) {
    i2 === void 0 && (i2 = false);
    var s2 = e3 || ti.defaultLocale;
    return new t2(s2 || (i2 ? "en-US" : oi || (oi = new Intl.DateTimeFormat().resolvedOptions().locale)), n2 || ti.defaultNumberingSystem, r2 || ti.defaultOutputCalendar, s2);
  }, t2.resetCache = function() {
    oi = null, ii = {}, ai = {}, ui = {};
  }, t2.fromObject = function(e3) {
    var n2 = e3 === void 0 ? {} : e3;
    return t2.create(n2.locale, n2.numberingSystem, n2.outputCalendar);
  };
  var e2 = t2.prototype;
  return e2.listingMode = function() {
    return this.isEnglish() && !(this.numberingSystem !== null && this.numberingSystem !== "latn" || this.outputCalendar !== null && this.outputCalendar !== "gregory") ? "en" : "intl";
  }, e2.clone = function(e3) {
    return e3 && Object.getOwnPropertyNames(e3).length !== 0 ? t2.create(e3.locale || this.specifiedLocale, e3.numberingSystem || this.numberingSystem, e3.outputCalendar || this.outputCalendar, e3.defaultToEN || false) : this;
  }, e2.redefaultToEN = function(t3) {
    return t3 === void 0 && (t3 = {}), this.clone(an({}, t3, {defaultToEN: true}));
  }, e2.redefaultToSystem = function(t3) {
    return t3 === void 0 && (t3 = {}), this.clone(an({}, t3, {defaultToEN: false}));
  }, e2.months = function(t3, e3, n2) {
    var r2 = this;
    return e3 === void 0 && (e3 = false), n2 === void 0 && (n2 = true), ci(this, t3, n2, Mr, function() {
      var n3 = e3 ? {month: t3, day: "numeric"} : {month: t3}, i2 = e3 ? "format" : "standalone";
      return r2.monthsCache[i2][t3] || (r2.monthsCache[i2][t3] = function(t4) {
        for (var e4 = [], n4 = 1; n4 <= 12; n4++) {
          var r3 = oa.utc(2016, n4, 1);
          e4.push(t4(r3));
        }
        return e4;
      }(function(t4) {
        return r2.extract(t4, n3, "month");
      })), r2.monthsCache[i2][t3];
    });
  }, e2.weekdays = function(t3, e3, n2) {
    var r2 = this;
    return e3 === void 0 && (e3 = false), n2 === void 0 && (n2 = true), ci(this, t3, n2, Tr, function() {
      var n3 = e3 ? {weekday: t3, year: "numeric", month: "long", day: "numeric"} : {weekday: t3}, i2 = e3 ? "format" : "standalone";
      return r2.weekdaysCache[i2][t3] || (r2.weekdaysCache[i2][t3] = function(t4) {
        for (var e4 = [], n4 = 1; n4 <= 7; n4++) {
          var r3 = oa.utc(2016, 11, 13 + n4);
          e4.push(t4(r3));
        }
        return e4;
      }(function(t4) {
        return r2.extract(t4, n3, "weekday");
      })), r2.weekdaysCache[i2][t3];
    });
  }, e2.meridiems = function(t3) {
    var e3 = this;
    return t3 === void 0 && (t3 = true), ci(this, void 0, t3, function() {
      return _r;
    }, function() {
      if (!e3.meridiemCache) {
        var t4 = {hour: "numeric", hourCycle: "h12"};
        e3.meridiemCache = [oa.utc(2016, 11, 13, 9), oa.utc(2016, 11, 13, 19)].map(function(n2) {
          return e3.extract(n2, t4, "dayperiod");
        });
      }
      return e3.meridiemCache;
    });
  }, e2.eras = function(t3, e3) {
    var n2 = this;
    return e3 === void 0 && (e3 = true), ci(this, t3, e3, Dr, function() {
      var e4 = {era: t3};
      return n2.eraCache[t3] || (n2.eraCache[t3] = [oa.utc(-40, 1, 1), oa.utc(2017, 1, 1)].map(function(t4) {
        return n2.extract(t4, e4, "era");
      })), n2.eraCache[t3];
    });
  }, e2.extract = function(t3, e3, n2) {
    var r2 = this.dtFormatter(t3, e3).formatToParts().find(function(t4) {
      return t4.type.toLowerCase() === n2;
    });
    return r2 ? r2.value : null;
  }, e2.numberFormatter = function(t3) {
    return t3 === void 0 && (t3 = {}), new hi(this.intl, t3.forceSimple || this.fastNumbers, t3);
  }, e2.dtFormatter = function(t3, e3) {
    return e3 === void 0 && (e3 = {}), new di(t3, this.intl, e3);
  }, e2.relFormatter = function(t3) {
    return t3 === void 0 && (t3 = {}), new li(this.intl, this.isEnglish(), t3);
  }, e2.listFormatter = function(t3) {
    return t3 === void 0 && (t3 = {}), function(t4, e3) {
      e3 === void 0 && (e3 = {});
      var n2 = JSON.stringify([t4, e3]), r2 = ri[n2];
      return r2 || (r2 = new Intl.ListFormat(t4, e3), ri[n2] = r2), r2;
    }(this.intl, t3);
  }, e2.isEnglish = function() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }, e2.equals = function(t3) {
    return this.locale === t3.locale && this.numberingSystem === t3.numberingSystem && this.outputCalendar === t3.outputCalendar;
  }, sn(t2, [{key: "fastNumbers", get: function() {
    var t3;
    return this.fastNumbersCached == null && (this.fastNumbersCached = (!(t3 = this).numberingSystem || t3.numberingSystem === "latn") && (t3.numberingSystem === "latn" || !t3.locale || t3.locale.startsWith("en") || new Intl.DateTimeFormat(t3.intl).resolvedOptions().numberingSystem === "latn")), this.fastNumbersCached;
  }}]), t2;
}();
function mi() {
  for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
    e2[n2] = arguments[n2];
  var r2 = e2.reduce(function(t3, e3) {
    return t3 + e3.source;
  }, "");
  return RegExp("^" + r2 + "$");
}
function vi() {
  for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
    e2[n2] = arguments[n2];
  return function(t3) {
    return e2.reduce(function(e3, n3) {
      var r2 = e3[0], i2 = e3[1], s2 = n3(t3, e3[2]), a2 = s2[1], u2 = s2[2];
      return [an({}, r2, s2[0]), a2 || i2, u2];
    }, [{}, null, 1]).slice(0, 2);
  };
}
function yi(t2) {
  if (t2 == null)
    return [null, null];
  for (var e2 = arguments.length, n2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++)
    n2[r2 - 1] = arguments[r2];
  for (var i2 = 0, s2 = n2; i2 < s2.length; i2++) {
    var a2 = s2[i2], u2 = a2[0], o2 = a2[1], c2 = u2.exec(t2);
    if (c2)
      return o2(c2);
  }
  return [null, null];
}
function pi() {
  for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
    e2[n2] = arguments[n2];
  return function(t3, n3) {
    var r2, i2 = {};
    for (r2 = 0; r2 < e2.length; r2++)
      i2[e2[r2]] = rr(t3[n3 + r2]);
    return [i2, null, n3 + r2];
  };
}
var gi = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, wi = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, bi = RegExp(wi.source + "(?:" + gi.source + "?(?:\\[(" + wr.source + ")\\])?)?"), ki = RegExp("(?:T" + bi.source + ")?"), Ni = pi("weekYear", "weekNumber", "weekDay"), Mi = pi("year", "ordinal"), xi = RegExp(wi.source + " ?(?:" + gi.source + "|(" + wr.source + "))?"), Ei = RegExp("(?: " + xi.source + ")?");
function Si(t2, e2, n2) {
  var r2 = t2[e2];
  return Jn(r2) ? n2 : rr(r2);
}
function Ti(t2, e2) {
  return [{hours: Si(t2, e2, 0), minutes: Si(t2, e2 + 1, 0), seconds: Si(t2, e2 + 2, 0), milliseconds: sr(t2[e2 + 3])}, null, e2 + 4];
}
function _i(t2, e2) {
  var n2 = !t2[e2] && !t2[e2 + 1], r2 = mr(t2[e2 + 1], t2[e2 + 2]);
  return [{}, n2 ? null : Kr.instance(r2), e2 + 3];
}
function Ii(t2, e2) {
  return [{}, t2[e2] ? Gr.create(t2[e2]) : null, e2 + 1];
}
var Zi = RegExp("^T?" + wi.source + "$"), Ai = /^-?P(?:(?:(-?\d{1,9}(?:\.\d{1,9})?)Y)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,9}(?:\.\d{1,9})?)W)?(?:(-?\d{1,9}(?:\.\d{1,9})?)D)?(?:T(?:(-?\d{1,9}(?:\.\d{1,9})?)H)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;
function Di(t2) {
  var e2 = t2[2], n2 = t2[3], r2 = t2[4], i2 = t2[5], s2 = t2[6], a2 = t2[7], u2 = t2[8], o2 = t2[0][0] === "-", c2 = a2 && a2[0] === "-", h2 = function(t3, e3) {
    return e3 === void 0 && (e3 = false), t3 !== void 0 && (e3 || t3 && o2) ? -t3 : t3;
  };
  return [{years: h2(ir(t2[1])), months: h2(ir(e2)), weeks: h2(ir(n2)), days: h2(ir(r2)), hours: h2(ir(i2)), minutes: h2(ir(s2)), seconds: h2(ir(a2), a2 === "-0"), milliseconds: h2(sr(u2), c2)}];
}
var Oi = {GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480};
function Pi(t2, e2, n2, r2, i2, s2, a2) {
  var u2 = {year: e2.length === 2 ? lr(rr(e2)) : rr(e2), month: kr.indexOf(n2) + 1, day: rr(r2), hour: rr(i2), minute: rr(s2)};
  return a2 && (u2.second = rr(a2)), t2 && (u2.weekday = t2.length > 3 ? xr.indexOf(t2) + 1 : Er.indexOf(t2) + 1), u2;
}
var Ci = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function Li(t2) {
  var e2, n2 = t2[8], r2 = t2[9], i2 = t2[10], s2 = t2[11], a2 = Pi(t2[1], t2[4], t2[3], t2[2], t2[5], t2[6], t2[7]);
  return e2 = n2 ? Oi[n2] : r2 ? 0 : mr(i2, s2), [a2, new Kr(e2)];
}
var Ui = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, ji = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Ri = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function Fi(t2) {
  return [Pi(t2[1], t2[4], t2[3], t2[2], t2[5], t2[6], t2[7]), Kr.utcInstance];
}
function $i(t2) {
  return [Pi(t2[1], t2[7], t2[2], t2[3], t2[4], t2[5], t2[6]), Kr.utcInstance];
}
var Bi = mi(/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, ki), Gi = mi(/(\d{4})-?W(\d\d)(?:-?(\d))?/, ki), Hi = mi(/(\d{4})-?(\d{3})/, ki), Ki = mi(bi), zi = vi(function(t2, e2) {
  return [{year: Si(t2, e2), month: Si(t2, e2 + 1, 1), day: Si(t2, e2 + 2, 1)}, null, e2 + 3];
}, Ti, _i, Ii), qi = vi(Ni, Ti, _i, Ii), Vi = vi(Mi, Ti, _i, Ii), Ji = vi(Ti, _i, Ii), Wi = vi(Ti), Yi = mi(/(\d{4})-(\d\d)-(\d\d)/, Ei), Qi = mi(xi), Xi = vi(Ti, _i, Ii), ts = {weeks: {days: 7, hours: 168, minutes: 10080, seconds: 604800, milliseconds: 6048e5}, days: {hours: 24, minutes: 1440, seconds: 86400, milliseconds: 864e5}, hours: {minutes: 60, seconds: 3600, milliseconds: 36e5}, minutes: {seconds: 60, milliseconds: 6e4}, seconds: {milliseconds: 1e3}}, es = an({years: {quarters: 4, months: 12, weeks: 52, days: 365, hours: 8760, minutes: 525600, seconds: 31536e3, milliseconds: 31536e6}, quarters: {months: 3, weeks: 13, days: 91, hours: 2184, minutes: 131040, seconds: 7862400, milliseconds: 78624e5}, months: {weeks: 4, days: 30, hours: 720, minutes: 43200, seconds: 2592e3, milliseconds: 2592e6}}, ts), ns = an({years: {quarters: 4, months: 12, weeks: 52.1775, days: 365.2425, hours: 8765.82, minutes: 525949.2, seconds: 525949.2 * 60, milliseconds: 525949.2 * 60 * 1e3}, quarters: {months: 3, weeks: 13.044375, days: 91.310625, hours: 2191.455, minutes: 131487.3, seconds: 525949.2 * 60 / 4, milliseconds: 7889237999999999e-6}, months: {weeks: 30.436875 / 7, days: 30.436875, hours: 730.485, minutes: 43829.1, seconds: 2629746, milliseconds: 2629746e3}}, ts), rs = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"], is = rs.slice(0).reverse();
function ss(t2, e2, n2) {
  n2 === void 0 && (n2 = false);
  var r2 = {values: n2 ? e2.values : an({}, t2.values, e2.values || {}), loc: t2.loc.clone(e2.loc), conversionAccuracy: e2.conversionAccuracy || t2.conversionAccuracy};
  return new us(r2);
}
function as(t2, e2, n2, r2, i2) {
  var s2 = t2[i2][n2], a2 = e2[n2] / s2, u2 = Math.sign(a2) !== Math.sign(r2[i2]) && r2[i2] !== 0 && Math.abs(a2) <= 1 ? function(t3) {
    return t3 < 0 ? Math.floor(t3) : Math.ceil(t3);
  }(a2) : Math.trunc(a2);
  r2[i2] += u2, e2[n2] -= u2 * s2;
}
var us = /* @__PURE__ */ function() {
  function t2(t3) {
    var e3 = t3.conversionAccuracy === "longterm" || false;
    this.values = t3.values, this.loc = t3.loc || fi.create(), this.conversionAccuracy = e3 ? "longterm" : "casual", this.invalid = t3.invalid || null, this.matrix = e3 ? ns : es, this.isLuxonDuration = true;
  }
  t2.fromMillis = function(e3, n2) {
    return t2.fromObject({milliseconds: e3}, n2);
  }, t2.fromObject = function(e3, n2) {
    if (n2 === void 0 && (n2 = {}), e3 == null || typeof e3 != "object")
      throw new Nn("Duration.fromObject: argument expected to be an object, got " + (e3 === null ? "null" : typeof e3));
    return new t2({values: yr(e3, t2.normalizeUnit), loc: fi.fromObject(n2), conversionAccuracy: n2.conversionAccuracy});
  }, t2.fromDurationLike = function(e3) {
    if (Wn(e3))
      return t2.fromMillis(e3);
    if (t2.isDuration(e3))
      return e3;
    if (typeof e3 == "object")
      return t2.fromObject(e3);
    throw new Nn("Unknown duration argument " + e3 + " of type " + typeof e3);
  }, t2.fromISO = function(e3, n2) {
    var r2 = function(t3) {
      return yi(t3, [Ai, Di]);
    }(e3)[0];
    return r2 ? t2.fromObject(r2, n2) : t2.invalid("unparsable", 'the input "' + e3 + `" can't be parsed as ISO 8601`);
  }, t2.fromISOTime = function(e3, n2) {
    var r2 = function(t3) {
      return yi(t3, [Zi, Wi]);
    }(e3)[0];
    return r2 ? t2.fromObject(r2, n2) : t2.invalid("unparsable", 'the input "' + e3 + `" can't be parsed as ISO 8601`);
  }, t2.invalid = function(e3, n2) {
    if (n2 === void 0 && (n2 = null), !e3)
      throw new Nn("need to specify a reason the Duration is invalid");
    var r2 = e3 instanceof Lr ? e3 : new Lr(e3, n2);
    if (ti.throwOnInvalid)
      throw new wn(r2);
    return new t2({invalid: r2});
  }, t2.normalizeUnit = function(t3) {
    var e3 = {year: "years", years: "years", quarter: "quarters", quarters: "quarters", month: "months", months: "months", week: "weeks", weeks: "weeks", day: "days", days: "days", hour: "hours", hours: "hours", minute: "minutes", minutes: "minutes", second: "seconds", seconds: "seconds", millisecond: "milliseconds", milliseconds: "milliseconds"}[t3 ? t3.toLowerCase() : t3];
    if (!e3)
      throw new kn(t3);
    return e3;
  }, t2.isDuration = function(t3) {
    return t3 && t3.isLuxonDuration || false;
  };
  var e2 = t2.prototype;
  return e2.toFormat = function(t3, e3) {
    e3 === void 0 && (e3 = {});
    var n2 = an({}, e3, {floor: e3.round !== false && e3.floor !== false});
    return this.isValid ? Cr.create(this.loc, n2).formatDurationFromString(this, t3) : "Invalid Duration";
  }, e2.toHuman = function(t3) {
    var e3 = this;
    t3 === void 0 && (t3 = {});
    var n2 = rs.map(function(n3) {
      var r2 = e3.values[n3];
      return Jn(r2) ? null : e3.loc.numberFormatter(an({style: "unit", unitDisplay: "long"}, t3, {unit: n3.slice(0, -1)})).format(r2);
    }).filter(function(t4) {
      return t4;
    });
    return this.loc.listFormatter(an({type: "conjunction", style: t3.listStyle || "narrow"}, t3)).format(n2);
  }, e2.toObject = function() {
    return this.isValid ? an({}, this.values) : {};
  }, e2.toISO = function() {
    if (!this.isValid)
      return null;
    var t3 = "P";
    return this.years !== 0 && (t3 += this.years + "Y"), this.months === 0 && this.quarters === 0 || (t3 += this.months + 3 * this.quarters + "M"), this.weeks !== 0 && (t3 += this.weeks + "W"), this.days !== 0 && (t3 += this.days + "D"), this.hours === 0 && this.minutes === 0 && this.seconds === 0 && this.milliseconds === 0 || (t3 += "T"), this.hours !== 0 && (t3 += this.hours + "H"), this.minutes !== 0 && (t3 += this.minutes + "M"), this.seconds === 0 && this.milliseconds === 0 || (t3 += ar(this.seconds + this.milliseconds / 1e3, 3) + "S"), t3 === "P" && (t3 += "T0S"), t3;
  }, e2.toISOTime = function(t3) {
    if (t3 === void 0 && (t3 = {}), !this.isValid)
      return null;
    var e3 = this.toMillis();
    if (e3 < 0 || e3 >= 864e5)
      return null;
    t3 = an({suppressMilliseconds: false, suppressSeconds: false, includePrefix: false, format: "extended"}, t3);
    var n2 = this.shiftTo("hours", "minutes", "seconds", "milliseconds"), r2 = t3.format === "basic" ? "hhmm" : "hh:mm";
    t3.suppressSeconds && n2.seconds === 0 && n2.milliseconds === 0 || (r2 += t3.format === "basic" ? "ss" : ":ss", t3.suppressMilliseconds && n2.milliseconds === 0 || (r2 += ".SSS"));
    var i2 = n2.toFormat(r2);
    return t3.includePrefix && (i2 = "T" + i2), i2;
  }, e2.toJSON = function() {
    return this.toISO();
  }, e2.toString = function() {
    return this.toISO();
  }, e2.toMillis = function() {
    return this.as("milliseconds");
  }, e2.valueOf = function() {
    return this.toMillis();
  }, e2.plus = function(e3) {
    if (!this.isValid)
      return this;
    for (var n2, r2 = t2.fromDurationLike(e3), i2 = {}, s2 = vn(rs); !(n2 = s2()).done; ) {
      var a2 = n2.value;
      (tr(r2.values, a2) || tr(this.values, a2)) && (i2[a2] = r2.get(a2) + this.get(a2));
    }
    return ss(this, {values: i2}, true);
  }, e2.minus = function(e3) {
    if (!this.isValid)
      return this;
    var n2 = t2.fromDurationLike(e3);
    return this.plus(n2.negate());
  }, e2.mapUnits = function(t3) {
    if (!this.isValid)
      return this;
    for (var e3 = {}, n2 = 0, r2 = Object.keys(this.values); n2 < r2.length; n2++) {
      var i2 = r2[n2];
      e3[i2] = vr(t3(this.values[i2], i2));
    }
    return ss(this, {values: e3}, true);
  }, e2.get = function(e3) {
    return this[t2.normalizeUnit(e3)];
  }, e2.set = function(e3) {
    return this.isValid ? ss(this, {values: an({}, this.values, yr(e3, t2.normalizeUnit))}) : this;
  }, e2.reconfigure = function(t3) {
    var e3 = t3 === void 0 ? {} : t3, n2 = e3.conversionAccuracy, r2 = {loc: this.loc.clone({locale: e3.locale, numberingSystem: e3.numberingSystem})};
    return n2 && (r2.conversionAccuracy = n2), ss(this, r2);
  }, e2.as = function(t3) {
    return this.isValid ? this.shiftTo(t3).get(t3) : NaN;
  }, e2.normalize = function() {
    if (!this.isValid)
      return this;
    var t3 = this.toObject();
    return function(t4, e3) {
      is.reduce(function(n2, r2) {
        return Jn(e3[r2]) ? n2 : (n2 && as(t4, e3, n2, e3, r2), r2);
      }, null);
    }(this.matrix, t3), ss(this, {values: t3}, true);
  }, e2.shiftTo = function() {
    for (var e3 = arguments.length, n2 = new Array(e3), r2 = 0; r2 < e3; r2++)
      n2[r2] = arguments[r2];
    if (!this.isValid)
      return this;
    if (n2.length === 0)
      return this;
    n2 = n2.map(function(e4) {
      return t2.normalizeUnit(e4);
    });
    for (var i2, s2, a2 = {}, u2 = {}, o2 = this.toObject(), c2 = vn(rs); !(s2 = c2()).done; ) {
      var h2 = s2.value;
      if (n2.indexOf(h2) >= 0) {
        i2 = h2;
        var d2 = 0;
        for (var l2 in u2)
          d2 += this.matrix[l2][h2] * u2[l2], u2[l2] = 0;
        Wn(o2[h2]) && (d2 += o2[h2]);
        var f2 = Math.trunc(d2);
        for (var m2 in a2[h2] = f2, u2[h2] = (1e3 * d2 - 1e3 * f2) / 1e3, o2)
          rs.indexOf(m2) > rs.indexOf(h2) && as(this.matrix, o2, m2, a2, h2);
      } else
        Wn(o2[h2]) && (u2[h2] = o2[h2]);
    }
    for (var v2 in u2)
      u2[v2] !== 0 && (a2[i2] += v2 === i2 ? u2[v2] : u2[v2] / this.matrix[i2][v2]);
    return ss(this, {values: a2}, true).normalize();
  }, e2.negate = function() {
    if (!this.isValid)
      return this;
    for (var t3 = {}, e3 = 0, n2 = Object.keys(this.values); e3 < n2.length; e3++) {
      var r2 = n2[e3];
      t3[r2] = this.values[r2] === 0 ? 0 : -this.values[r2];
    }
    return ss(this, {values: t3}, true);
  }, e2.equals = function(t3) {
    if (!this.isValid || !t3.isValid)
      return false;
    if (!this.loc.equals(t3.loc))
      return false;
    for (var e3, n2 = vn(rs); !(e3 = n2()).done; ) {
      var r2 = e3.value;
      if (s2 = t3.values[r2], !((i2 = this.values[r2]) === void 0 || i2 === 0 ? s2 === void 0 || s2 === 0 : i2 === s2))
        return false;
    }
    var i2, s2;
    return true;
  }, sn(t2, [{key: "locale", get: function() {
    return this.isValid ? this.loc.locale : null;
  }}, {key: "numberingSystem", get: function() {
    return this.isValid ? this.loc.numberingSystem : null;
  }}, {key: "years", get: function() {
    return this.isValid ? this.values.years || 0 : NaN;
  }}, {key: "quarters", get: function() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }}, {key: "months", get: function() {
    return this.isValid ? this.values.months || 0 : NaN;
  }}, {key: "weeks", get: function() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }}, {key: "days", get: function() {
    return this.isValid ? this.values.days || 0 : NaN;
  }}, {key: "hours", get: function() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }}, {key: "minutes", get: function() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }}, {key: "seconds", get: function() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }}, {key: "milliseconds", get: function() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }}, {key: "isValid", get: function() {
    return this.invalid === null;
  }}, {key: "invalidReason", get: function() {
    return this.invalid ? this.invalid.reason : null;
  }}, {key: "invalidExplanation", get: function() {
    return this.invalid ? this.invalid.explanation : null;
  }}]), t2;
}(), os = "Invalid Interval";
function cs(t2, e2) {
  return t2 && t2.isValid ? e2 && e2.isValid ? e2 < t2 ? hs.invalid("end before start", "The end of an interval must be after its start, but you had start=" + t2.toISO() + " and end=" + e2.toISO()) : null : hs.invalid("missing or invalid end") : hs.invalid("missing or invalid start");
}
var hs = /* @__PURE__ */ function() {
  function t2(t3) {
    this.s = t3.start, this.e = t3.end, this.invalid = t3.invalid || null, this.isLuxonInterval = true;
  }
  t2.invalid = function(e3, n2) {
    if (n2 === void 0 && (n2 = null), !e3)
      throw new Nn("need to specify a reason the Interval is invalid");
    var r2 = e3 instanceof Lr ? e3 : new Lr(e3, n2);
    if (ti.throwOnInvalid)
      throw new gn(r2);
    return new t2({invalid: r2});
  }, t2.fromDateTimes = function(e3, n2) {
    var r2 = ca(e3), i2 = ca(n2), s2 = cs(r2, i2);
    return s2 == null ? new t2({start: r2, end: i2}) : s2;
  }, t2.after = function(e3, n2) {
    var r2 = us.fromDurationLike(n2), i2 = ca(e3);
    return t2.fromDateTimes(i2, i2.plus(r2));
  }, t2.before = function(e3, n2) {
    var r2 = us.fromDurationLike(n2), i2 = ca(e3);
    return t2.fromDateTimes(i2.minus(r2), i2);
  }, t2.fromISO = function(e3, n2) {
    var r2 = (e3 || "").split("/", 2), i2 = r2[0], s2 = r2[1];
    if (i2 && s2) {
      var a2, u2, o2, c2;
      try {
        u2 = (a2 = oa.fromISO(i2, n2)).isValid;
      } catch (s3) {
        u2 = false;
      }
      try {
        c2 = (o2 = oa.fromISO(s2, n2)).isValid;
      } catch (s3) {
        c2 = false;
      }
      if (u2 && c2)
        return t2.fromDateTimes(a2, o2);
      if (u2) {
        var h2 = us.fromISO(s2, n2);
        if (h2.isValid)
          return t2.after(a2, h2);
      } else if (c2) {
        var d2 = us.fromISO(i2, n2);
        if (d2.isValid)
          return t2.before(o2, d2);
      }
    }
    return t2.invalid("unparsable", 'the input "' + e3 + `" can't be parsed as ISO 8601`);
  }, t2.isInterval = function(t3) {
    return t3 && t3.isLuxonInterval || false;
  };
  var e2 = t2.prototype;
  return e2.length = function(t3) {
    return t3 === void 0 && (t3 = "milliseconds"), this.isValid ? this.toDuration.apply(this, [t3]).get(t3) : NaN;
  }, e2.count = function(t3) {
    if (t3 === void 0 && (t3 = "milliseconds"), !this.isValid)
      return NaN;
    var e3 = this.start.startOf(t3), n2 = this.end.startOf(t3);
    return Math.floor(n2.diff(e3, t3).get(t3)) + 1;
  }, e2.hasSame = function(t3) {
    return !!this.isValid && (this.isEmpty() || this.e.minus(1).hasSame(this.s, t3));
  }, e2.isEmpty = function() {
    return this.s.valueOf() === this.e.valueOf();
  }, e2.isAfter = function(t3) {
    return !!this.isValid && this.s > t3;
  }, e2.isBefore = function(t3) {
    return !!this.isValid && this.e <= t3;
  }, e2.contains = function(t3) {
    return !!this.isValid && this.s <= t3 && this.e > t3;
  }, e2.set = function(e3) {
    var n2 = e3 === void 0 ? {} : e3;
    return this.isValid ? t2.fromDateTimes(n2.start || this.s, n2.end || this.e) : this;
  }, e2.splitAt = function() {
    var e3 = this;
    if (!this.isValid)
      return [];
    for (var n2 = arguments.length, r2 = new Array(n2), i2 = 0; i2 < n2; i2++)
      r2[i2] = arguments[i2];
    for (var s2 = r2.map(ca).filter(function(t3) {
      return e3.contains(t3);
    }).sort(), a2 = [], u2 = this.s, o2 = 0; u2 < this.e; ) {
      var c2 = s2[o2] || this.e, h2 = +c2 > +this.e ? this.e : c2;
      a2.push(t2.fromDateTimes(u2, h2)), u2 = h2, o2 += 1;
    }
    return a2;
  }, e2.splitBy = function(e3) {
    var n2 = us.fromDurationLike(e3);
    if (!this.isValid || !n2.isValid || n2.as("milliseconds") === 0)
      return [];
    for (var r2, i2 = this.s, s2 = 1, a2 = []; i2 < this.e; ) {
      var u2 = this.start.plus(n2.mapUnits(function(t3) {
        return t3 * s2;
      }));
      a2.push(t2.fromDateTimes(i2, r2 = +u2 > +this.e ? this.e : u2)), i2 = r2, s2 += 1;
    }
    return a2;
  }, e2.divideEqually = function(t3) {
    return this.isValid ? this.splitBy(this.length() / t3).slice(0, t3) : [];
  }, e2.overlaps = function(t3) {
    return this.e > t3.s && this.s < t3.e;
  }, e2.abutsStart = function(t3) {
    return !!this.isValid && +this.e == +t3.s;
  }, e2.abutsEnd = function(t3) {
    return !!this.isValid && +t3.e == +this.s;
  }, e2.engulfs = function(t3) {
    return !!this.isValid && this.s <= t3.s && this.e >= t3.e;
  }, e2.equals = function(t3) {
    return !(!this.isValid || !t3.isValid) && this.s.equals(t3.s) && this.e.equals(t3.e);
  }, e2.intersection = function(e3) {
    if (!this.isValid)
      return this;
    var n2 = this.s > e3.s ? this.s : e3.s, r2 = this.e < e3.e ? this.e : e3.e;
    return n2 >= r2 ? null : t2.fromDateTimes(n2, r2);
  }, e2.union = function(e3) {
    return this.isValid ? t2.fromDateTimes(this.s < e3.s ? this.s : e3.s, this.e > e3.e ? this.e : e3.e) : this;
  }, t2.merge = function(t3) {
    var e3 = t3.sort(function(t4, e4) {
      return t4.s - e4.s;
    }).reduce(function(t4, e4) {
      var n3 = t4[0], r3 = t4[1];
      return r3 ? r3.overlaps(e4) || r3.abutsStart(e4) ? [n3, r3.union(e4)] : [n3.concat([r3]), e4] : [n3, e4];
    }, [[], null]), n2 = e3[0], r2 = e3[1];
    return r2 && n2.push(r2), n2;
  }, t2.xor = function(e3) {
    for (var n2, r2, i2 = null, s2 = 0, a2 = [], u2 = e3.map(function(t3) {
      return [{time: t3.s, type: "s"}, {time: t3.e, type: "e"}];
    }), o2 = vn((n2 = Array.prototype).concat.apply(n2, u2).sort(function(t3, e4) {
      return t3.time - e4.time;
    })); !(r2 = o2()).done; ) {
      var c2 = r2.value;
      (s2 += c2.type === "s" ? 1 : -1) === 1 ? i2 = c2.time : (i2 && +i2 != +c2.time && a2.push(t2.fromDateTimes(i2, c2.time)), i2 = null);
    }
    return t2.merge(a2);
  }, e2.difference = function() {
    for (var e3 = this, n2 = arguments.length, r2 = new Array(n2), i2 = 0; i2 < n2; i2++)
      r2[i2] = arguments[i2];
    return t2.xor([this].concat(r2)).map(function(t3) {
      return e3.intersection(t3);
    }).filter(function(t3) {
      return t3 && !t3.isEmpty();
    });
  }, e2.toString = function() {
    return this.isValid ? "[" + this.s.toISO() + " \u2013 " + this.e.toISO() + ")" : os;
  }, e2.toISO = function(t3) {
    return this.isValid ? this.s.toISO(t3) + "/" + this.e.toISO(t3) : os;
  }, e2.toISODate = function() {
    return this.isValid ? this.s.toISODate() + "/" + this.e.toISODate() : os;
  }, e2.toISOTime = function(t3) {
    return this.isValid ? this.s.toISOTime(t3) + "/" + this.e.toISOTime(t3) : os;
  }, e2.toFormat = function(t3, e3) {
    var n2 = (e3 === void 0 ? {} : e3).separator, r2 = n2 === void 0 ? " \u2013 " : n2;
    return this.isValid ? "" + this.s.toFormat(t3) + r2 + this.e.toFormat(t3) : os;
  }, e2.toDuration = function(t3, e3) {
    return this.isValid ? this.e.diff(this.s, t3, e3) : us.invalid(this.invalidReason);
  }, e2.mapEndpoints = function(e3) {
    return t2.fromDateTimes(e3(this.s), e3(this.e));
  }, sn(t2, [{key: "start", get: function() {
    return this.isValid ? this.s : null;
  }}, {key: "end", get: function() {
    return this.isValid ? this.e : null;
  }}, {key: "isValid", get: function() {
    return this.invalidReason === null;
  }}, {key: "invalidReason", get: function() {
    return this.invalid ? this.invalid.reason : null;
  }}, {key: "invalidExplanation", get: function() {
    return this.invalid ? this.invalid.explanation : null;
  }}]), t2;
}(), ds = /* @__PURE__ */ function() {
  function t2() {
  }
  return t2.hasDST = function(t3) {
    t3 === void 0 && (t3 = ti.defaultZone);
    var e2 = oa.now().setZone(t3).set({month: 12});
    return !t3.isUniversal && e2.offset !== e2.set({month: 6}).offset;
  }, t2.isValidIANAZone = function(t3) {
    return Gr.isValidZone(t3);
  }, t2.normalizeZone = function(t3) {
    return qr(t3, ti.defaultZone);
  }, t2.months = function(t3, e2) {
    t3 === void 0 && (t3 = "long");
    var n2 = e2 === void 0 ? {} : e2, r2 = n2.locale, i2 = n2.numberingSystem, s2 = n2.locObj, a2 = n2.outputCalendar;
    return ((s2 === void 0 ? null : s2) || fi.create(r2 === void 0 ? null : r2, i2 === void 0 ? null : i2, a2 === void 0 ? "gregory" : a2)).months(t3);
  }, t2.monthsFormat = function(t3, e2) {
    t3 === void 0 && (t3 = "long");
    var n2 = e2 === void 0 ? {} : e2, r2 = n2.locale, i2 = n2.numberingSystem, s2 = n2.locObj, a2 = n2.outputCalendar;
    return ((s2 === void 0 ? null : s2) || fi.create(r2 === void 0 ? null : r2, i2 === void 0 ? null : i2, a2 === void 0 ? "gregory" : a2)).months(t3, true);
  }, t2.weekdays = function(t3, e2) {
    t3 === void 0 && (t3 = "long");
    var n2 = e2 === void 0 ? {} : e2, r2 = n2.locale, i2 = n2.numberingSystem, s2 = n2.locObj;
    return ((s2 === void 0 ? null : s2) || fi.create(r2 === void 0 ? null : r2, i2 === void 0 ? null : i2, null)).weekdays(t3);
  }, t2.weekdaysFormat = function(t3, e2) {
    t3 === void 0 && (t3 = "long");
    var n2 = e2 === void 0 ? {} : e2, r2 = n2.locale, i2 = n2.numberingSystem, s2 = n2.locObj;
    return ((s2 === void 0 ? null : s2) || fi.create(r2 === void 0 ? null : r2, i2 === void 0 ? null : i2, null)).weekdays(t3, true);
  }, t2.meridiems = function(t3) {
    var e2 = (t3 === void 0 ? {} : t3).locale;
    return fi.create(e2 === void 0 ? null : e2).meridiems();
  }, t2.eras = function(t3, e2) {
    t3 === void 0 && (t3 = "short");
    var n2 = (e2 === void 0 ? {} : e2).locale;
    return fi.create(n2 === void 0 ? null : n2, null, "gregory").eras(t3);
  }, t2.features = function() {
    return {relative: Qn()};
  }, t2;
}();
function ls(t2, e2) {
  var n2 = function(t3) {
    return t3.toUTC(0, {keepLocalTime: true}).startOf("day").valueOf();
  }, r2 = n2(e2) - n2(t2);
  return Math.floor(us.fromMillis(r2).as("days"));
}
var fs = {arab: "[\u0660-\u0669]", arabext: "[\u06F0-\u06F9]", bali: "[\u1B50-\u1B59]", beng: "[\u09E6-\u09EF]", deva: "[\u0966-\u096F]", fullwide: "[\uFF10-\uFF19]", gujr: "[\u0AE6-\u0AEF]", hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]", khmr: "[\u17E0-\u17E9]", knda: "[\u0CE6-\u0CEF]", laoo: "[\u0ED0-\u0ED9]", limb: "[\u1946-\u194F]", mlym: "[\u0D66-\u0D6F]", mong: "[\u1810-\u1819]", mymr: "[\u1040-\u1049]", orya: "[\u0B66-\u0B6F]", tamldec: "[\u0BE6-\u0BEF]", telu: "[\u0C66-\u0C6F]", thai: "[\u0E50-\u0E59]", tibt: "[\u0F20-\u0F29]", latn: "\\d"}, ms = {arab: [1632, 1641], arabext: [1776, 1785], bali: [6992, 7001], beng: [2534, 2543], deva: [2406, 2415], fullwide: [65296, 65303], gujr: [2790, 2799], khmr: [6112, 6121], knda: [3302, 3311], laoo: [3792, 3801], limb: [6470, 6479], mlym: [3430, 3439], mong: [6160, 6169], mymr: [4160, 4169], orya: [2918, 2927], tamldec: [3046, 3055], telu: [3174, 3183], thai: [3664, 3673], tibt: [3872, 3881]}, vs = fs.hanidec.replace(/[\[|\]]/g, "").split("");
function ys(t2, e2) {
  return e2 === void 0 && (e2 = ""), new RegExp("" + fs[t2.numberingSystem || "latn"] + e2);
}
function ps(t2, e2) {
  return e2 === void 0 && (e2 = function(t3) {
    return t3;
  }), {regex: t2, deser: function(t3) {
    return e2(function(t4) {
      var e3 = parseInt(t4, 10);
      if (isNaN(e3)) {
        e3 = "";
        for (var n2 = 0; n2 < t4.length; n2++) {
          var r2 = t4.charCodeAt(n2);
          if (t4[n2].search(fs.hanidec) !== -1)
            e3 += vs.indexOf(t4[n2]);
          else
            for (var i2 in ms) {
              var s2 = ms[i2], a2 = s2[0];
              r2 >= a2 && r2 <= s2[1] && (e3 += r2 - a2);
            }
        }
        return parseInt(e3, 10);
      }
      return e3;
    }(t3[0]));
  }};
}
var gs = "[ " + String.fromCharCode(160) + "]", ws = new RegExp(gs, "g");
function bs(t2) {
  return t2.replace(/\./g, "\\.?").replace(ws, gs);
}
function ks(t2) {
  return t2.replace(/\./g, "").replace(ws, " ").toLowerCase();
}
function Ns(t2, e2) {
  return t2 === null ? null : {regex: RegExp(t2.map(bs).join("|")), deser: function(n2) {
    var r2 = n2[0];
    return t2.findIndex(function(t3) {
      return ks(r2) === ks(t3);
    }) + e2;
  }};
}
function Ms(t2, e2) {
  return {regex: t2, deser: function(t3) {
    return mr(t3[1], t3[2]);
  }, groups: e2};
}
function xs(t2) {
  return {regex: t2, deser: function(t3) {
    return t3[0];
  }};
}
var Es = {year: {"2-digit": "yy", numeric: "yyyyy"}, month: {numeric: "M", "2-digit": "MM", short: "MMM", long: "MMMM"}, day: {numeric: "d", "2-digit": "dd"}, weekday: {short: "EEE", long: "EEEE"}, dayperiod: "a", dayPeriod: "a", hour: {numeric: "h", "2-digit": "hh"}, minute: {numeric: "m", "2-digit": "mm"}, second: {numeric: "s", "2-digit": "ss"}}, Ss = null;
function Ts(t2, e2, n2) {
  var r2 = function(t3, e3) {
    var n3;
    return (n3 = Array.prototype).concat.apply(n3, t3.map(function(t4) {
      return function(t5, e4) {
        if (t5.literal)
          return t5;
        var n4 = Cr.macroTokenToFormatOpts(t5.val);
        if (!n4)
          return t5;
        var r3 = Cr.create(e4, n4).formatDateTimeParts((Ss || (Ss = oa.fromMillis(1555555555555)), Ss)).map(function(t6) {
          return function(t7, e5, n5) {
            var r4 = t7.type;
            if (r4 === "literal")
              return {literal: true, val: t7.value};
            var i3 = Es[r4];
            return typeof i3 == "object" && (i3 = i3[n5[r4]]), i3 ? {literal: false, val: i3} : void 0;
          }(t6, 0, n4);
        });
        return r3.includes(void 0) ? t5 : r3;
      }(t4, e3);
    }));
  }(Cr.parseFormat(n2), t2), i2 = r2.map(function(e3) {
    return n3 = e3, i3 = ys(r3 = t2), s3 = ys(r3, "{2}"), a3 = ys(r3, "{3}"), u3 = ys(r3, "{4}"), o3 = ys(r3, "{6}"), c3 = ys(r3, "{1,2}"), h3 = ys(r3, "{1,3}"), d3 = ys(r3, "{1,6}"), l3 = ys(r3, "{1,9}"), f3 = ys(r3, "{2,4}"), m3 = ys(r3, "{4,6}"), v3 = function(t3) {
      return {regex: RegExp((e4 = t3.val, e4.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"))), deser: function(t4) {
        return t4[0];
      }, literal: true};
      var e4;
    }, (y2 = function(t3) {
      if (n3.literal)
        return v3(t3);
      switch (t3.val) {
        case "G":
          return Ns(r3.eras("short", false), 0);
        case "GG":
          return Ns(r3.eras("long", false), 0);
        case "y":
          return ps(d3);
        case "yy":
          return ps(f3, lr);
        case "yyyy":
          return ps(u3);
        case "yyyyy":
          return ps(m3);
        case "yyyyyy":
          return ps(o3);
        case "M":
          return ps(c3);
        case "MM":
          return ps(s3);
        case "MMM":
          return Ns(r3.months("short", true, false), 1);
        case "MMMM":
          return Ns(r3.months("long", true, false), 1);
        case "L":
          return ps(c3);
        case "LL":
          return ps(s3);
        case "LLL":
          return Ns(r3.months("short", false, false), 1);
        case "LLLL":
          return Ns(r3.months("long", false, false), 1);
        case "d":
          return ps(c3);
        case "dd":
          return ps(s3);
        case "o":
          return ps(h3);
        case "ooo":
          return ps(a3);
        case "HH":
          return ps(s3);
        case "H":
          return ps(c3);
        case "hh":
          return ps(s3);
        case "h":
          return ps(c3);
        case "mm":
          return ps(s3);
        case "m":
        case "q":
          return ps(c3);
        case "qq":
          return ps(s3);
        case "s":
          return ps(c3);
        case "ss":
          return ps(s3);
        case "S":
          return ps(h3);
        case "SSS":
          return ps(a3);
        case "u":
          return xs(l3);
        case "uu":
          return xs(c3);
        case "uuu":
          return ps(i3);
        case "a":
          return Ns(r3.meridiems(), 0);
        case "kkkk":
          return ps(u3);
        case "kk":
          return ps(f3, lr);
        case "W":
          return ps(c3);
        case "WW":
          return ps(s3);
        case "E":
        case "c":
          return ps(i3);
        case "EEE":
          return Ns(r3.weekdays("short", false, false), 1);
        case "EEEE":
          return Ns(r3.weekdays("long", false, false), 1);
        case "ccc":
          return Ns(r3.weekdays("short", true, false), 1);
        case "cccc":
          return Ns(r3.weekdays("long", true, false), 1);
        case "Z":
        case "ZZ":
          return Ms(new RegExp("([+-]" + c3.source + ")(?::(" + s3.source + "))?"), 2);
        case "ZZZ":
          return Ms(new RegExp("([+-]" + c3.source + ")(" + s3.source + ")?"), 2);
        case "z":
          return xs(/[a-z_+-/]{1,256}?/i);
        default:
          return v3(t3);
      }
    }(n3) || {invalidReason: "missing Intl.DateTimeFormat.formatToParts support"}).token = n3, y2;
    var n3, r3, i3, s3, a3, u3, o3, c3, h3, d3, l3, f3, m3, v3, y2;
  }), s2 = i2.find(function(t3) {
    return t3.invalidReason;
  });
  if (s2)
    return {input: e2, tokens: r2, invalidReason: s2.invalidReason};
  var a2 = function(t3) {
    return ["^" + t3.map(function(t4) {
      return t4.regex;
    }).reduce(function(t4, e3) {
      return t4 + "(" + e3.source + ")";
    }, "") + "$", t3];
  }(i2), u2 = a2[1], o2 = RegExp(a2[0], "i"), c2 = function(t3, e3, n3) {
    var r3 = t3.match(e3);
    if (r3) {
      var i3 = {}, s3 = 1;
      for (var a3 in n3)
        if (tr(n3, a3)) {
          var u3 = n3[a3], o3 = u3.groups ? u3.groups + 1 : 1;
          !u3.literal && u3.token && (i3[u3.token.val[0]] = u3.deser(r3.slice(s3, s3 + o3))), s3 += o3;
        }
      return [r3, i3];
    }
    return [r3, {}];
  }(e2, o2, u2), h2 = c2[0], d2 = c2[1], l2 = d2 ? function(t3) {
    var e3, n3 = null;
    return Jn(t3.z) || (n3 = Gr.create(t3.z)), Jn(t3.Z) || (n3 || (n3 = new Kr(t3.Z)), e3 = t3.Z), Jn(t3.q) || (t3.M = 3 * (t3.q - 1) + 1), Jn(t3.h) || (t3.h < 12 && t3.a === 1 ? t3.h += 12 : t3.h === 12 && t3.a === 0 && (t3.h = 0)), t3.G === 0 && t3.y && (t3.y = -t3.y), Jn(t3.u) || (t3.S = sr(t3.u)), [Object.keys(t3).reduce(function(e4, n4) {
      var r3 = function(t4) {
        switch (t4) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      }(n4);
      return r3 && (e4[r3] = t3[n4]), e4;
    }, {}), n3, e3];
  }(d2) : [null, null, void 0], f2 = l2[0], m2 = l2[1], v2 = l2[2];
  if (tr(d2, "a") && tr(d2, "H"))
    throw new bn("Can't include meridiem when specifying 24-hour format");
  return {input: e2, tokens: r2, regex: o2, rawMatches: h2, matches: d2, result: f2, zone: m2, specificOffset: v2};
}
var _s = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Is = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function Zs(t2, e2) {
  return new Lr("unit out of range", "you specified " + e2 + " (of type " + typeof e2 + ") as a " + t2 + ", which is invalid");
}
function As(t2, e2, n2) {
  var r2 = new Date(Date.UTC(t2, e2 - 1, n2));
  t2 < 100 && t2 >= 0 && r2.setUTCFullYear(r2.getUTCFullYear() - 1900);
  var i2 = r2.getUTCDay();
  return i2 === 0 ? 7 : i2;
}
function Ds(t2, e2, n2) {
  return n2 + (ur(t2) ? Is : _s)[e2 - 1];
}
function Os(t2, e2) {
  var n2 = ur(t2) ? Is : _s, r2 = n2.findIndex(function(t3) {
    return t3 < e2;
  });
  return {month: r2 + 1, day: e2 - n2[r2]};
}
function Ps(t2) {
  var e2, n2 = t2.year, r2 = t2.month, i2 = t2.day, s2 = Ds(n2, r2, i2), a2 = As(n2, r2, i2), u2 = Math.floor((s2 - a2 + 10) / 7);
  return u2 < 1 ? u2 = dr(e2 = n2 - 1) : u2 > dr(n2) ? (e2 = n2 + 1, u2 = 1) : e2 = n2, an({weekYear: e2, weekNumber: u2, weekday: a2}, gr(t2));
}
function Cs(t2) {
  var e2, n2 = t2.weekYear, r2 = t2.weekNumber, i2 = t2.weekday, s2 = As(n2, 1, 4), a2 = or(n2), u2 = 7 * r2 + i2 - s2 - 3;
  u2 < 1 ? u2 += or(e2 = n2 - 1) : u2 > a2 ? (e2 = n2 + 1, u2 -= or(n2)) : e2 = n2;
  var o2 = Os(e2, u2);
  return an({year: e2, month: o2.month, day: o2.day}, gr(t2));
}
function Ls(t2) {
  var e2 = t2.year;
  return an({year: e2, ordinal: Ds(e2, t2.month, t2.day)}, gr(t2));
}
function Us(t2) {
  var e2 = t2.year, n2 = Os(e2, t2.ordinal);
  return an({year: e2, month: n2.month, day: n2.day}, gr(t2));
}
function js(t2) {
  var e2 = Yn(t2.year), n2 = er(t2.month, 1, 12), r2 = er(t2.day, 1, cr(t2.year, t2.month));
  return e2 ? n2 ? !r2 && Zs("day", t2.day) : Zs("month", t2.month) : Zs("year", t2.year);
}
function Rs(t2) {
  var e2 = t2.hour, n2 = t2.minute, r2 = t2.second, i2 = t2.millisecond, s2 = er(e2, 0, 23) || e2 === 24 && n2 === 0 && r2 === 0 && i2 === 0, a2 = er(n2, 0, 59), u2 = er(r2, 0, 59), o2 = er(i2, 0, 999);
  return s2 ? a2 ? u2 ? !o2 && Zs("millisecond", i2) : Zs("second", r2) : Zs("minute", n2) : Zs("hour", e2);
}
var Fs = "Invalid DateTime";
function $s(t2) {
  return new Lr("unsupported zone", 'the zone "' + t2.name + '" is not supported');
}
function Bs(t2) {
  return t2.weekData === null && (t2.weekData = Ps(t2.c)), t2.weekData;
}
function Gs(t2, e2) {
  var n2 = {ts: t2.ts, zone: t2.zone, c: t2.c, o: t2.o, loc: t2.loc, invalid: t2.invalid};
  return new oa(an({}, n2, e2, {old: n2}));
}
function Hs(t2, e2, n2) {
  var r2 = t2 - 60 * e2 * 1e3, i2 = n2.offset(r2);
  if (e2 === i2)
    return [r2, e2];
  var s2 = n2.offset(r2 -= 60 * (i2 - e2) * 1e3);
  return i2 === s2 ? [r2, i2] : [t2 - 60 * Math.min(i2, s2) * 1e3, Math.max(i2, s2)];
}
function Ks(t2, e2) {
  var n2 = new Date(t2 += 60 * e2 * 1e3);
  return {year: n2.getUTCFullYear(), month: n2.getUTCMonth() + 1, day: n2.getUTCDate(), hour: n2.getUTCHours(), minute: n2.getUTCMinutes(), second: n2.getUTCSeconds(), millisecond: n2.getUTCMilliseconds()};
}
function zs(t2, e2, n2) {
  return Hs(hr(t2), e2, n2);
}
function qs(t2, e2) {
  var n2 = t2.o, r2 = t2.c.year + Math.trunc(e2.years), i2 = t2.c.month + Math.trunc(e2.months) + 3 * Math.trunc(e2.quarters), s2 = an({}, t2.c, {year: r2, month: i2, day: Math.min(t2.c.day, cr(r2, i2)) + Math.trunc(e2.days) + 7 * Math.trunc(e2.weeks)}), a2 = us.fromObject({years: e2.years - Math.trunc(e2.years), quarters: e2.quarters - Math.trunc(e2.quarters), months: e2.months - Math.trunc(e2.months), weeks: e2.weeks - Math.trunc(e2.weeks), days: e2.days - Math.trunc(e2.days), hours: e2.hours, minutes: e2.minutes, seconds: e2.seconds, milliseconds: e2.milliseconds}).as("milliseconds"), u2 = Hs(hr(s2), n2, t2.zone), o2 = u2[0], c2 = u2[1];
  return a2 !== 0 && (c2 = t2.zone.offset(o2 += a2)), {ts: o2, o: c2};
}
function Vs(t2, e2, n2, r2, i2, s2) {
  var a2 = n2.setZone, u2 = n2.zone;
  if (t2 && Object.keys(t2).length !== 0) {
    var o2 = oa.fromObject(t2, an({}, n2, {zone: e2 || u2, specificOffset: s2}));
    return a2 ? o2 : o2.setZone(u2);
  }
  return oa.invalid(new Lr("unparsable", 'the input "' + i2 + `" can't be parsed as ` + r2));
}
function Js(t2, e2, n2) {
  return n2 === void 0 && (n2 = true), t2.isValid ? Cr.create(fi.create("en-US"), {allowZ: n2, forceSimple: true}).formatDateTimeFromString(t2, e2) : null;
}
function Ws(t2, e2) {
  var n2 = t2.c.year > 9999 || t2.c.year < 0, r2 = "";
  return n2 && t2.c.year >= 0 && (r2 += "+"), r2 += nr(t2.c.year, n2 ? 6 : 4), e2 ? (r2 += "-", r2 += nr(t2.c.month), r2 += "-", r2 += nr(t2.c.day)) : (r2 += nr(t2.c.month), r2 += nr(t2.c.day)), r2;
}
function Ys(t2, e2, n2, r2, i2, s2) {
  var a2 = nr(t2.c.hour);
  return e2 ? (a2 += ":", a2 += nr(t2.c.minute), t2.c.second === 0 && n2 || (a2 += ":")) : a2 += nr(t2.c.minute), t2.c.second === 0 && n2 || (a2 += nr(t2.c.second), t2.c.millisecond === 0 && r2 || (a2 += ".", a2 += nr(t2.c.millisecond, 3))), i2 && (t2.isOffsetFixed && t2.offset === 0 && !s2 ? a2 += "Z" : t2.o < 0 ? (a2 += "-", a2 += nr(Math.trunc(-t2.o / 60)), a2 += ":", a2 += nr(Math.trunc(-t2.o % 60))) : (a2 += "+", a2 += nr(Math.trunc(t2.o / 60)), a2 += ":", a2 += nr(Math.trunc(t2.o % 60)))), s2 && (a2 += "[" + t2.zone.ianaName + "]"), a2;
}
var Qs = {month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0}, Xs = {weekNumber: 1, weekday: 1, hour: 0, minute: 0, second: 0, millisecond: 0}, ta = {ordinal: 1, hour: 0, minute: 0, second: 0, millisecond: 0}, ea = ["year", "month", "day", "hour", "minute", "second", "millisecond"], na = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"], ra = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function ia(t2) {
  var e2 = {year: "year", years: "year", month: "month", months: "month", day: "day", days: "day", hour: "hour", hours: "hour", minute: "minute", minutes: "minute", quarter: "quarter", quarters: "quarter", second: "second", seconds: "second", millisecond: "millisecond", milliseconds: "millisecond", weekday: "weekday", weekdays: "weekday", weeknumber: "weekNumber", weeksnumber: "weekNumber", weeknumbers: "weekNumber", weekyear: "weekYear", weekyears: "weekYear", ordinal: "ordinal"}[t2.toLowerCase()];
  if (!e2)
    throw new kn(t2);
  return e2;
}
function sa(t2, e2) {
  var n2, r2, i2 = qr(e2.zone, ti.defaultZone), s2 = fi.fromObject(e2), a2 = ti.now();
  if (Jn(t2.year))
    n2 = a2;
  else {
    for (var u2, o2 = vn(ea); !(u2 = o2()).done; ) {
      var c2 = u2.value;
      Jn(t2[c2]) && (t2[c2] = Qs[c2]);
    }
    var h2 = js(t2) || Rs(t2);
    if (h2)
      return oa.invalid(h2);
    var d2 = zs(t2, i2.offset(a2), i2);
    n2 = d2[0], r2 = d2[1];
  }
  return new oa({ts: n2, zone: i2, loc: s2, o: r2});
}
function aa(t2, e2, n2) {
  var r2 = !!Jn(n2.round) || n2.round, i2 = function(t3, i3) {
    return t3 = ar(t3, r2 || n2.calendary ? 0 : 2, true), e2.loc.clone(n2).relFormatter(n2).format(t3, i3);
  }, s2 = function(r3) {
    return n2.calendary ? e2.hasSame(t2, r3) ? 0 : e2.startOf(r3).diff(t2.startOf(r3), r3).get(r3) : e2.diff(t2, r3).get(r3);
  };
  if (n2.unit)
    return i2(s2(n2.unit), n2.unit);
  for (var a2, u2 = vn(n2.units); !(a2 = u2()).done; ) {
    var o2 = a2.value, c2 = s2(o2);
    if (Math.abs(c2) >= 1)
      return i2(c2, o2);
  }
  return i2(t2 > e2 ? -0 : 0, n2.units[n2.units.length - 1]);
}
function ua(t2) {
  var e2, n2 = {};
  return t2.length > 0 && typeof t2[t2.length - 1] == "object" ? (n2 = t2[t2.length - 1], e2 = Array.from(t2).slice(0, t2.length - 1)) : e2 = Array.from(t2), [n2, e2];
}
var oa = /* @__PURE__ */ function() {
  function t2(t3) {
    var e3 = t3.zone || ti.defaultZone, n2 = t3.invalid || (Number.isNaN(t3.ts) ? new Lr("invalid input") : null) || (e3.isValid ? null : $s(e3));
    this.ts = Jn(t3.ts) ? ti.now() : t3.ts;
    var r2 = null, i2 = null;
    if (!n2)
      if (t3.old && t3.old.ts === this.ts && t3.old.zone.equals(e3)) {
        var s2 = [t3.old.c, t3.old.o];
        r2 = s2[0], i2 = s2[1];
      } else {
        var a2 = e3.offset(this.ts);
        r2 = Ks(this.ts, a2), r2 = (n2 = Number.isNaN(r2.year) ? new Lr("invalid input") : null) ? null : r2, i2 = n2 ? null : a2;
      }
    this.W = e3, this.loc = t3.loc || fi.create(), this.invalid = n2, this.weekData = null, this.c = r2, this.o = i2, this.isLuxonDateTime = true;
  }
  t2.now = function() {
    return new t2({});
  }, t2.local = function() {
    var t3 = ua(arguments), e3 = t3[0], n2 = t3[1], r2 = n2[0], i2 = n2[1], s2 = n2[2], a2 = n2[3], u2 = n2[4], o2 = n2[5], c2 = n2[6];
    return sa({year: r2, month: i2, day: s2, hour: a2, minute: u2, second: o2, millisecond: c2}, e3);
  }, t2.utc = function() {
    var t3 = ua(arguments), e3 = t3[0], n2 = t3[1], r2 = n2[0], i2 = n2[1], s2 = n2[2], a2 = n2[3], u2 = n2[4], o2 = n2[5], c2 = n2[6];
    return e3.zone = Kr.utcInstance, sa({year: r2, month: i2, day: s2, hour: a2, minute: u2, second: o2, millisecond: c2}, e3);
  }, t2.fromJSDate = function(e3, n2) {
    n2 === void 0 && (n2 = {});
    var r2 = Object.prototype.toString.call(e3) === "[object Date]" ? e3.valueOf() : NaN;
    if (Number.isNaN(r2))
      return t2.invalid("invalid input");
    var i2 = qr(n2.zone, ti.defaultZone);
    return i2.isValid ? new t2({ts: r2, zone: i2, loc: fi.fromObject(n2)}) : t2.invalid($s(i2));
  }, t2.fromMillis = function(e3, n2) {
    if (n2 === void 0 && (n2 = {}), Wn(e3))
      return e3 < -864e13 || e3 > 864e13 ? t2.invalid("Timestamp out of range") : new t2({ts: e3, zone: qr(n2.zone, ti.defaultZone), loc: fi.fromObject(n2)});
    throw new Nn("fromMillis requires a numerical input, but received a " + typeof e3 + " with value " + e3);
  }, t2.fromSeconds = function(e3, n2) {
    if (n2 === void 0 && (n2 = {}), Wn(e3))
      return new t2({ts: 1e3 * e3, zone: qr(n2.zone, ti.defaultZone), loc: fi.fromObject(n2)});
    throw new Nn("fromSeconds requires a numerical input");
  }, t2.fromObject = function(e3, n2) {
    n2 === void 0 && (n2 = {}), e3 = e3 || {};
    var r2 = qr(n2.zone, ti.defaultZone);
    if (!r2.isValid)
      return t2.invalid($s(r2));
    var i2 = ti.now(), s2 = Jn(n2.specificOffset) ? r2.offset(i2) : n2.specificOffset, a2 = yr(e3, ia), u2 = !Jn(a2.ordinal), o2 = !Jn(a2.year), c2 = !Jn(a2.month) || !Jn(a2.day), h2 = o2 || c2, d2 = a2.weekYear || a2.weekNumber, l2 = fi.fromObject(n2);
    if ((h2 || u2) && d2)
      throw new bn("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    if (c2 && u2)
      throw new bn("Can't mix ordinal dates with month/day");
    var f2, m2, v2 = d2 || a2.weekday && !h2, y2 = Ks(i2, s2);
    v2 ? (f2 = na, m2 = Xs, y2 = Ps(y2)) : u2 ? (f2 = ra, m2 = ta, y2 = Ls(y2)) : (f2 = ea, m2 = Qs);
    for (var p2, g2 = false, w2 = vn(f2); !(p2 = w2()).done; ) {
      var b2 = p2.value;
      Jn(a2[b2]) ? a2[b2] = g2 ? m2[b2] : y2[b2] : g2 = true;
    }
    var k2 = (v2 ? function(t3) {
      var e4 = Yn(t3.weekYear), n3 = er(t3.weekNumber, 1, dr(t3.weekYear)), r3 = er(t3.weekday, 1, 7);
      return e4 ? n3 ? !r3 && Zs("weekday", t3.weekday) : Zs("week", t3.week) : Zs("weekYear", t3.weekYear);
    }(a2) : u2 ? function(t3) {
      var e4 = Yn(t3.year), n3 = er(t3.ordinal, 1, or(t3.year));
      return e4 ? !n3 && Zs("ordinal", t3.ordinal) : Zs("year", t3.year);
    }(a2) : js(a2)) || Rs(a2);
    if (k2)
      return t2.invalid(k2);
    var N2 = zs(v2 ? Cs(a2) : u2 ? Us(a2) : a2, s2, r2), M2 = new t2({ts: N2[0], zone: r2, o: N2[1], loc: l2});
    return a2.weekday && h2 && e3.weekday !== M2.weekday ? t2.invalid("mismatched weekday", "you can't specify both a weekday of " + a2.weekday + " and a date of " + M2.toISO()) : M2;
  }, t2.fromISO = function(t3, e3) {
    e3 === void 0 && (e3 = {});
    var n2 = function(t4) {
      return yi(t4, [Bi, zi], [Gi, qi], [Hi, Vi], [Ki, Ji]);
    }(t3);
    return Vs(n2[0], n2[1], e3, "ISO 8601", t3);
  }, t2.fromRFC2822 = function(t3, e3) {
    e3 === void 0 && (e3 = {});
    var n2 = function(t4) {
      return yi(function(t5) {
        return t5.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
      }(t4), [Ci, Li]);
    }(t3);
    return Vs(n2[0], n2[1], e3, "RFC 2822", t3);
  }, t2.fromHTTP = function(t3, e3) {
    e3 === void 0 && (e3 = {});
    var n2 = function(t4) {
      return yi(t4, [Ui, Fi], [ji, Fi], [Ri, $i]);
    }(t3);
    return Vs(n2[0], n2[1], e3, "HTTP", e3);
  }, t2.fromFormat = function(e3, n2, r2) {
    if (r2 === void 0 && (r2 = {}), Jn(e3) || Jn(n2))
      throw new Nn("fromFormat requires an input string and a format");
    var i2, s2 = r2.locale, a2 = r2.numberingSystem, u2 = [(i2 = Ts(fi.fromOpts({locale: s2 === void 0 ? null : s2, numberingSystem: a2 === void 0 ? null : a2, defaultToEN: true}), e3, n2)).result, i2.zone, i2.specificOffset, i2.invalidReason], o2 = u2[0], c2 = u2[1], h2 = u2[2], d2 = u2[3];
    return d2 ? t2.invalid(d2) : Vs(o2, c2, r2, "format " + n2, e3, h2);
  }, t2.fromString = function(e3, n2, r2) {
    return r2 === void 0 && (r2 = {}), t2.fromFormat(e3, n2, r2);
  }, t2.fromSQL = function(t3, e3) {
    e3 === void 0 && (e3 = {});
    var n2 = function(t4) {
      return yi(t4, [Yi, zi], [Qi, Xi]);
    }(t3);
    return Vs(n2[0], n2[1], e3, "SQL", t3);
  }, t2.invalid = function(e3, n2) {
    if (n2 === void 0 && (n2 = null), !e3)
      throw new Nn("need to specify a reason the DateTime is invalid");
    var r2 = e3 instanceof Lr ? e3 : new Lr(e3, n2);
    if (ti.throwOnInvalid)
      throw new pn(r2);
    return new t2({invalid: r2});
  }, t2.isDateTime = function(t3) {
    return t3 && t3.isLuxonDateTime || false;
  };
  var e2 = t2.prototype;
  return e2.get = function(t3) {
    return this[t3];
  }, e2.resolvedLocaleOptions = function(t3) {
    t3 === void 0 && (t3 = {});
    var e3 = Cr.create(this.loc.clone(t3), t3).resolvedOptions(this);
    return {locale: e3.locale, numberingSystem: e3.numberingSystem, outputCalendar: e3.calendar};
  }, e2.toUTC = function(t3, e3) {
    return t3 === void 0 && (t3 = 0), e3 === void 0 && (e3 = {}), this.setZone(Kr.instance(t3), e3);
  }, e2.toLocal = function() {
    return this.setZone(ti.defaultZone);
  }, e2.setZone = function(e3, n2) {
    var r2 = n2 === void 0 ? {} : n2, i2 = r2.keepLocalTime, s2 = i2 !== void 0 && i2, a2 = r2.keepCalendarTime, u2 = a2 !== void 0 && a2;
    if ((e3 = qr(e3, ti.defaultZone)).equals(this.zone))
      return this;
    if (e3.isValid) {
      var o2 = this.ts;
      if (s2 || u2) {
        var c2 = e3.offset(this.ts);
        o2 = zs(this.toObject(), c2, e3)[0];
      }
      return Gs(this, {ts: o2, zone: e3});
    }
    return t2.invalid($s(e3));
  }, e2.reconfigure = function(t3) {
    var e3 = t3 === void 0 ? {} : t3;
    return Gs(this, {loc: this.loc.clone({locale: e3.locale, numberingSystem: e3.numberingSystem, outputCalendar: e3.outputCalendar})});
  }, e2.setLocale = function(t3) {
    return this.reconfigure({locale: t3});
  }, e2.set = function(t3) {
    if (!this.isValid)
      return this;
    var e3, n2 = yr(t3, ia), r2 = !Jn(n2.weekYear) || !Jn(n2.weekNumber) || !Jn(n2.weekday), i2 = !Jn(n2.ordinal), s2 = !Jn(n2.year), a2 = !Jn(n2.month) || !Jn(n2.day);
    if ((s2 || a2 || i2) && (n2.weekYear || n2.weekNumber))
      throw new bn("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    if (a2 && i2)
      throw new bn("Can't mix ordinal dates with month/day");
    r2 ? e3 = Cs(an({}, Ps(this.c), n2)) : Jn(n2.ordinal) ? (e3 = an({}, this.toObject(), n2), Jn(n2.day) && (e3.day = Math.min(cr(e3.year, e3.month), e3.day))) : e3 = Us(an({}, Ls(this.c), n2));
    var u2 = zs(e3, this.o, this.zone);
    return Gs(this, {ts: u2[0], o: u2[1]});
  }, e2.plus = function(t3) {
    return this.isValid ? Gs(this, qs(this, us.fromDurationLike(t3))) : this;
  }, e2.minus = function(t3) {
    return this.isValid ? Gs(this, qs(this, us.fromDurationLike(t3).negate())) : this;
  }, e2.startOf = function(t3) {
    if (!this.isValid)
      return this;
    var e3 = {}, n2 = us.normalizeUnit(t3);
    switch (n2) {
      case "years":
        e3.month = 1;
      case "quarters":
      case "months":
        e3.day = 1;
      case "weeks":
      case "days":
        e3.hour = 0;
      case "hours":
        e3.minute = 0;
      case "minutes":
        e3.second = 0;
      case "seconds":
        e3.millisecond = 0;
    }
    if (n2 === "weeks" && (e3.weekday = 1), n2 === "quarters") {
      var r2 = Math.ceil(this.month / 3);
      e3.month = 3 * (r2 - 1) + 1;
    }
    return this.set(e3);
  }, e2.endOf = function(t3) {
    var e3;
    return this.isValid ? this.plus((e3 = {}, e3[t3] = 1, e3)).startOf(t3).minus(1) : this;
  }, e2.toFormat = function(t3, e3) {
    return e3 === void 0 && (e3 = {}), this.isValid ? Cr.create(this.loc.redefaultToEN(e3)).formatDateTimeFromString(this, t3) : Fs;
  }, e2.toLocaleString = function(t3, e3) {
    return t3 === void 0 && (t3 = Tn), e3 === void 0 && (e3 = {}), this.isValid ? Cr.create(this.loc.clone(e3), t3).formatDateTime(this) : Fs;
  }, e2.toLocaleParts = function(t3) {
    return t3 === void 0 && (t3 = {}), this.isValid ? Cr.create(this.loc.clone(t3), t3).formatDateTimeParts(this) : [];
  }, e2.toISO = function(t3) {
    var e3 = t3 === void 0 ? {} : t3, n2 = e3.format, r2 = e3.suppressSeconds, i2 = r2 !== void 0 && r2, s2 = e3.suppressMilliseconds, a2 = s2 !== void 0 && s2, u2 = e3.includeOffset, o2 = u2 === void 0 || u2, c2 = e3.extendedZone, h2 = c2 !== void 0 && c2;
    if (!this.isValid)
      return null;
    var d2 = (n2 === void 0 ? "extended" : n2) === "extended", l2 = Ws(this, d2);
    return (l2 += "T") + Ys(this, d2, i2, a2, o2, h2);
  }, e2.toISODate = function(t3) {
    var e3 = (t3 === void 0 ? {} : t3).format;
    return this.isValid ? Ws(this, (e3 === void 0 ? "extended" : e3) === "extended") : null;
  }, e2.toISOWeekDate = function() {
    return Js(this, "kkkk-'W'WW-c");
  }, e2.toISOTime = function(t3) {
    var e3 = t3 === void 0 ? {} : t3, n2 = e3.suppressMilliseconds, r2 = e3.suppressSeconds, i2 = e3.includeOffset, s2 = e3.includePrefix, a2 = e3.extendedZone, u2 = e3.format;
    return this.isValid ? (s2 !== void 0 && s2 ? "T" : "") + Ys(this, (u2 === void 0 ? "extended" : u2) === "extended", r2 !== void 0 && r2, n2 !== void 0 && n2, i2 === void 0 || i2, a2 !== void 0 && a2) : null;
  }, e2.toRFC2822 = function() {
    return Js(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }, e2.toHTTP = function() {
    return Js(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }, e2.toSQLDate = function() {
    return this.isValid ? Ws(this, true) : null;
  }, e2.toSQLTime = function(t3) {
    var e3 = t3 === void 0 ? {} : t3, n2 = e3.includeOffset, r2 = n2 === void 0 || n2, i2 = e3.includeZone, s2 = i2 !== void 0 && i2, a2 = e3.includeOffsetSpace, u2 = "HH:mm:ss.SSS";
    return (s2 || r2) && ((a2 === void 0 || a2) && (u2 += " "), s2 ? u2 += "z" : r2 && (u2 += "ZZ")), Js(this, u2, true);
  }, e2.toSQL = function(t3) {
    return t3 === void 0 && (t3 = {}), this.isValid ? this.toSQLDate() + " " + this.toSQLTime(t3) : null;
  }, e2.toString = function() {
    return this.isValid ? this.toISO() : Fs;
  }, e2.valueOf = function() {
    return this.toMillis();
  }, e2.toMillis = function() {
    return this.isValid ? this.ts : NaN;
  }, e2.toSeconds = function() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }, e2.toUnixInteger = function() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }, e2.toJSON = function() {
    return this.toISO();
  }, e2.toBSON = function() {
    return this.toJSDate();
  }, e2.toObject = function(t3) {
    if (t3 === void 0 && (t3 = {}), !this.isValid)
      return {};
    var e3 = an({}, this.c);
    return t3.includeConfig && (e3.outputCalendar = this.outputCalendar, e3.numberingSystem = this.loc.numberingSystem, e3.locale = this.loc.locale), e3;
  }, e2.toJSDate = function() {
    return new Date(this.isValid ? this.ts : NaN);
  }, e2.diff = function(t3, e3, n2) {
    if (e3 === void 0 && (e3 = "milliseconds"), n2 === void 0 && (n2 = {}), !this.isValid || !t3.isValid)
      return us.invalid("created by diffing an invalid DateTime");
    var r2, i2 = an({locale: this.locale, numberingSystem: this.numberingSystem}, n2), s2 = (r2 = e3, Array.isArray(r2) ? r2 : [r2]).map(us.normalizeUnit), a2 = t3.valueOf() > this.valueOf(), u2 = function(t4, e4, n3, r3) {
      var i3, s3 = function(t5, e5, n4) {
        for (var r4, i4, s4 = {}, a4 = 0, u4 = [["years", function(t6, e6) {
          return e6.year - t6.year;
        }], ["quarters", function(t6, e6) {
          return e6.quarter - t6.quarter;
        }], ["months", function(t6, e6) {
          return e6.month - t6.month + 12 * (e6.year - t6.year);
        }], ["weeks", function(t6, e6) {
          var n5 = ls(t6, e6);
          return (n5 - n5 % 7) / 7;
        }], ["days", ls]]; a4 < u4.length; a4++) {
          var o3 = u4[a4], c3 = o3[0], h3 = o3[1];
          if (n4.indexOf(c3) >= 0) {
            var d3;
            r4 = c3;
            var l3, f3 = h3(t5, e5);
            (i4 = t5.plus(((d3 = {})[c3] = f3, d3))) > e5 ? (t5 = t5.plus(((l3 = {})[c3] = f3 - 1, l3)), f3 -= 1) : t5 = i4, s4[c3] = f3;
          }
        }
        return [t5, s4, i4, r4];
      }(t4, e4, n3), a3 = s3[0], u3 = s3[1], o2 = s3[2], c2 = s3[3], h2 = e4 - a3, d2 = n3.filter(function(t5) {
        return ["hours", "minutes", "seconds", "milliseconds"].indexOf(t5) >= 0;
      });
      d2.length === 0 && (o2 < e4 && (o2 = a3.plus(((i3 = {})[c2] = 1, i3))), o2 !== a3 && (u3[c2] = (u3[c2] || 0) + h2 / (o2 - a3)));
      var l2, f2 = us.fromObject(u3, r3);
      return d2.length > 0 ? (l2 = us.fromMillis(h2, r3)).shiftTo.apply(l2, d2).plus(f2) : f2;
    }(a2 ? this : t3, a2 ? t3 : this, s2, i2);
    return a2 ? u2.negate() : u2;
  }, e2.diffNow = function(e3, n2) {
    return e3 === void 0 && (e3 = "milliseconds"), n2 === void 0 && (n2 = {}), this.diff(t2.now(), e3, n2);
  }, e2.until = function(t3) {
    return this.isValid ? hs.fromDateTimes(this, t3) : this;
  }, e2.hasSame = function(t3, e3) {
    if (!this.isValid)
      return false;
    var n2 = t3.valueOf(), r2 = this.setZone(t3.zone, {keepLocalTime: true});
    return r2.startOf(e3) <= n2 && n2 <= r2.endOf(e3);
  }, e2.equals = function(t3) {
    return this.isValid && t3.isValid && this.valueOf() === t3.valueOf() && this.zone.equals(t3.zone) && this.loc.equals(t3.loc);
  }, e2.toRelative = function(e3) {
    if (e3 === void 0 && (e3 = {}), !this.isValid)
      return null;
    var n2 = e3.base || t2.fromObject({}, {zone: this.zone}), r2 = e3.padding ? this < n2 ? -e3.padding : e3.padding : 0, i2 = ["years", "months", "days", "hours", "minutes", "seconds"], s2 = e3.unit;
    return Array.isArray(e3.unit) && (i2 = e3.unit, s2 = void 0), aa(n2, this.plus(r2), an({}, e3, {numeric: "always", units: i2, unit: s2}));
  }, e2.toRelativeCalendar = function(e3) {
    return e3 === void 0 && (e3 = {}), this.isValid ? aa(e3.base || t2.fromObject({}, {zone: this.zone}), this, an({}, e3, {numeric: "auto", units: ["years", "months", "days"], calendary: true})) : null;
  }, t2.min = function() {
    for (var e3 = arguments.length, n2 = new Array(e3), r2 = 0; r2 < e3; r2++)
      n2[r2] = arguments[r2];
    if (!n2.every(t2.isDateTime))
      throw new Nn("min requires all arguments be DateTimes");
    return Xn(n2, function(t3) {
      return t3.valueOf();
    }, Math.min);
  }, t2.max = function() {
    for (var e3 = arguments.length, n2 = new Array(e3), r2 = 0; r2 < e3; r2++)
      n2[r2] = arguments[r2];
    if (!n2.every(t2.isDateTime))
      throw new Nn("max requires all arguments be DateTimes");
    return Xn(n2, function(t3) {
      return t3.valueOf();
    }, Math.max);
  }, t2.fromFormatExplain = function(t3, e3, n2) {
    n2 === void 0 && (n2 = {});
    var r2 = n2.locale, i2 = n2.numberingSystem;
    return Ts(fi.fromOpts({locale: r2 === void 0 ? null : r2, numberingSystem: i2 === void 0 ? null : i2, defaultToEN: true}), t3, e3);
  }, t2.fromStringExplain = function(e3, n2, r2) {
    return r2 === void 0 && (r2 = {}), t2.fromFormatExplain(e3, n2, r2);
  }, sn(t2, [{key: "isValid", get: function() {
    return this.invalid === null;
  }}, {key: "invalidReason", get: function() {
    return this.invalid ? this.invalid.reason : null;
  }}, {key: "invalidExplanation", get: function() {
    return this.invalid ? this.invalid.explanation : null;
  }}, {key: "locale", get: function() {
    return this.isValid ? this.loc.locale : null;
  }}, {key: "numberingSystem", get: function() {
    return this.isValid ? this.loc.numberingSystem : null;
  }}, {key: "outputCalendar", get: function() {
    return this.isValid ? this.loc.outputCalendar : null;
  }}, {key: "zone", get: function() {
    return this.W;
  }}, {key: "zoneName", get: function() {
    return this.isValid ? this.zone.name : null;
  }}, {key: "year", get: function() {
    return this.isValid ? this.c.year : NaN;
  }}, {key: "quarter", get: function() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }}, {key: "month", get: function() {
    return this.isValid ? this.c.month : NaN;
  }}, {key: "day", get: function() {
    return this.isValid ? this.c.day : NaN;
  }}, {key: "hour", get: function() {
    return this.isValid ? this.c.hour : NaN;
  }}, {key: "minute", get: function() {
    return this.isValid ? this.c.minute : NaN;
  }}, {key: "second", get: function() {
    return this.isValid ? this.c.second : NaN;
  }}, {key: "millisecond", get: function() {
    return this.isValid ? this.c.millisecond : NaN;
  }}, {key: "weekYear", get: function() {
    return this.isValid ? Bs(this).weekYear : NaN;
  }}, {key: "weekNumber", get: function() {
    return this.isValid ? Bs(this).weekNumber : NaN;
  }}, {key: "weekday", get: function() {
    return this.isValid ? Bs(this).weekday : NaN;
  }}, {key: "ordinal", get: function() {
    return this.isValid ? Ls(this.c).ordinal : NaN;
  }}, {key: "monthShort", get: function() {
    return this.isValid ? ds.months("short", {locObj: this.loc})[this.month - 1] : null;
  }}, {key: "monthLong", get: function() {
    return this.isValid ? ds.months("long", {locObj: this.loc})[this.month - 1] : null;
  }}, {key: "weekdayShort", get: function() {
    return this.isValid ? ds.weekdays("short", {locObj: this.loc})[this.weekday - 1] : null;
  }}, {key: "weekdayLong", get: function() {
    return this.isValid ? ds.weekdays("long", {locObj: this.loc})[this.weekday - 1] : null;
  }}, {key: "offset", get: function() {
    return this.isValid ? +this.o : NaN;
  }}, {key: "offsetNameShort", get: function() {
    return this.isValid ? this.zone.offsetName(this.ts, {format: "short", locale: this.locale}) : null;
  }}, {key: "offsetNameLong", get: function() {
    return this.isValid ? this.zone.offsetName(this.ts, {format: "long", locale: this.locale}) : null;
  }}, {key: "isOffsetFixed", get: function() {
    return this.isValid ? this.zone.isUniversal : null;
  }}, {key: "isInDST", get: function() {
    return !this.isOffsetFixed && (this.offset > this.set({month: 1, day: 1}).offset || this.offset > this.set({month: 5}).offset);
  }}, {key: "isInLeapYear", get: function() {
    return ur(this.year);
  }}, {key: "daysInMonth", get: function() {
    return cr(this.year, this.month);
  }}, {key: "daysInYear", get: function() {
    return this.isValid ? or(this.year) : NaN;
  }}, {key: "weeksInWeekYear", get: function() {
    return this.isValid ? dr(this.weekYear) : NaN;
  }}], [{key: "DATE_SHORT", get: function() {
    return Tn;
  }}, {key: "DATE_MED", get: function() {
    return _n;
  }}, {key: "DATE_MED_WITH_WEEKDAY", get: function() {
    return In;
  }}, {key: "DATE_FULL", get: function() {
    return Zn;
  }}, {key: "DATE_HUGE", get: function() {
    return An;
  }}, {key: "TIME_SIMPLE", get: function() {
    return Dn;
  }}, {key: "TIME_WITH_SECONDS", get: function() {
    return On;
  }}, {key: "TIME_WITH_SHORT_OFFSET", get: function() {
    return Pn;
  }}, {key: "TIME_WITH_LONG_OFFSET", get: function() {
    return Cn;
  }}, {key: "TIME_24_SIMPLE", get: function() {
    return Ln;
  }}, {key: "TIME_24_WITH_SECONDS", get: function() {
    return Un;
  }}, {key: "TIME_24_WITH_SHORT_OFFSET", get: function() {
    return jn;
  }}, {key: "TIME_24_WITH_LONG_OFFSET", get: function() {
    return Rn;
  }}, {key: "DATETIME_SHORT", get: function() {
    return Fn;
  }}, {key: "DATETIME_SHORT_WITH_SECONDS", get: function() {
    return $n;
  }}, {key: "DATETIME_MED", get: function() {
    return Bn;
  }}, {key: "DATETIME_MED_WITH_SECONDS", get: function() {
    return Gn;
  }}, {key: "DATETIME_MED_WITH_WEEKDAY", get: function() {
    return Hn;
  }}, {key: "DATETIME_FULL", get: function() {
    return Kn;
  }}, {key: "DATETIME_FULL_WITH_SECONDS", get: function() {
    return zn;
  }}, {key: "DATETIME_HUGE", get: function() {
    return qn;
  }}, {key: "DATETIME_HUGE_WITH_SECONDS", get: function() {
    return Vn;
  }}]), t2;
}();
function ca(t2) {
  if (oa.isDateTime(t2))
    return t2;
  if (t2 && t2.valueOf && Wn(t2.valueOf()))
    return oa.fromJSDate(t2);
  if (t2 && typeof t2 == "object")
    return oa.fromObject(t2);
  throw new Nn("Unknown datetime argument: " + t2 + ", of type " + typeof t2);
}
var ha, da = oa, la = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global$1 != "undefined" ? global$1 : typeof self != "undefined" ? self : {}, fa = la && la.Y || (ha = function(t2, e2) {
  return (ha = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(t3, e3) {
    t3.__proto__ = e3;
  } || function(t3, e3) {
    for (var n2 in e3)
      e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
  })(t2, e2);
}, function(t2, e2) {
  function n2() {
    this.constructor = t2;
  }
  ha(t2, e2), t2.prototype = e2 === null ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
}), ma = function() {
  function t2(t3) {
    t3 === void 0 && (t3 = "="), this.X = t3;
  }
  return t2.prototype.encodedLength = function(t3) {
    return this.X ? (t3 + 2) / 3 * 4 | 0 : (8 * t3 + 5) / 6 | 0;
  }, t2.prototype.encode = function(t3) {
    for (var e2 = "", n2 = 0; n2 < t3.length - 2; n2 += 3)
      e2 += this.et((r2 = t3[n2] << 16 | t3[n2 + 1] << 8 | t3[n2 + 2]) >>> 18 & 63), e2 += this.et(r2 >>> 12 & 63), e2 += this.et(r2 >>> 6 & 63), e2 += this.et(r2 >>> 0 & 63);
    var r2, i2 = t3.length - n2;
    return i2 > 0 && (e2 += this.et((r2 = t3[n2] << 16 | (i2 === 2 ? t3[n2 + 1] << 8 : 0)) >>> 18 & 63), e2 += this.et(r2 >>> 12 & 63), e2 += i2 === 2 ? this.et(r2 >>> 6 & 63) : this.X || "", e2 += this.X || ""), e2;
  }, t2.prototype.maxDecodedLength = function(t3) {
    return this.X ? t3 / 4 * 3 | 0 : (6 * t3 + 7) / 8 | 0;
  }, t2.prototype.decodedLength = function(t3) {
    return this.maxDecodedLength(t3.length - this.nt(t3));
  }, t2.prototype.decode = function(t3) {
    if (t3.length === 0)
      return new Uint8Array(0);
    for (var e2 = this.nt(t3), n2 = t3.length - e2, r2 = new Uint8Array(this.maxDecodedLength(n2)), i2 = 0, s2 = 0, a2 = 0, u2 = 0, o2 = 0, c2 = 0, h2 = 0; s2 < n2 - 4; s2 += 4)
      u2 = this.rt(t3.charCodeAt(s2 + 0)), o2 = this.rt(t3.charCodeAt(s2 + 1)), c2 = this.rt(t3.charCodeAt(s2 + 2)), h2 = this.rt(t3.charCodeAt(s2 + 3)), r2[i2++] = u2 << 2 | o2 >>> 4, r2[i2++] = o2 << 4 | c2 >>> 2, r2[i2++] = c2 << 6 | h2, a2 |= 256 & u2, a2 |= 256 & o2, a2 |= 256 & c2, a2 |= 256 & h2;
    if (s2 < n2 - 1 && (u2 = this.rt(t3.charCodeAt(s2)), o2 = this.rt(t3.charCodeAt(s2 + 1)), r2[i2++] = u2 << 2 | o2 >>> 4, a2 |= 256 & u2, a2 |= 256 & o2), s2 < n2 - 2 && (c2 = this.rt(t3.charCodeAt(s2 + 2)), r2[i2++] = o2 << 4 | c2 >>> 2, a2 |= 256 & c2), s2 < n2 - 3 && (h2 = this.rt(t3.charCodeAt(s2 + 3)), r2[i2++] = c2 << 6 | h2, a2 |= 256 & h2), a2 !== 0)
      throw new Error("Base64Coder: incorrect characters for decoding");
    return r2;
  }, t2.prototype.et = function(t3) {
    var e2 = t3;
    return e2 += 65, e2 += 25 - t3 >>> 8 & 6, e2 += 51 - t3 >>> 8 & -75, e2 += 61 - t3 >>> 8 & -15, e2 += 62 - t3 >>> 8 & 3, String.fromCharCode(e2);
  }, t2.prototype.rt = function(t3) {
    var e2 = 256;
    return e2 += (42 - t3 & t3 - 44) >>> 8 & -256 + t3 - 43 + 62, e2 += (46 - t3 & t3 - 48) >>> 8 & -256 + t3 - 47 + 63, e2 += (47 - t3 & t3 - 58) >>> 8 & -256 + t3 - 48 + 52, (e2 += (64 - t3 & t3 - 91) >>> 8 & -256 + t3 - 65 + 0) + ((96 - t3 & t3 - 123) >>> 8 & -256 + t3 - 97 + 26);
  }, t2.prototype.nt = function(t3) {
    var e2 = 0;
    if (this.X) {
      for (var n2 = t3.length - 1; n2 >= 0 && t3[n2] === this.X; n2--)
        e2++;
      if (t3.length < 4 || e2 > 2)
        throw new Error("Base64Coder: incorrect padding");
    }
    return e2;
  }, t2;
}(), va = new ma();
new (function(t2) {
  function e2() {
    return t2 !== null && t2.apply(this, arguments) || this;
  }
  return fa(e2, t2), e2.prototype.et = function(t3) {
    var e3 = t3;
    return e3 += 65, e3 += 25 - t3 >>> 8 & 6, e3 += 51 - t3 >>> 8 & -75, e3 += 61 - t3 >>> 8 & -13, e3 += 62 - t3 >>> 8 & 49, String.fromCharCode(e3);
  }, e2.prototype.rt = function(t3) {
    var e3 = 256;
    return e3 += (44 - t3 & t3 - 46) >>> 8 & -256 + t3 - 45 + 62, e3 += (94 - t3 & t3 - 96) >>> 8 & -256 + t3 - 95 + 63, e3 += (47 - t3 & t3 - 58) >>> 8 & -256 + t3 - 48 + 52, (e3 += (64 - t3 & t3 - 91) >>> 8 & -256 + t3 - 65 + 0) + ((96 - t3 & t3 - 123) >>> 8 & -256 + t3 - 97 + 26);
  }, e2;
}(ma))();
var ya, pa = (function(t2, e2) {
  function n2(t3) {
    return e2.ISO_3166_ALPHA_2.indexOf(t3) != -1;
  }
  Object.defineProperty(e2, "it", {value: true}), e2.getIso3166CountryName = e2.isIso3166Alpha2Code = e2.ISO_3166_ALPHA_2 = e2.ISO_3166_ALPHA_2_MAPPINGS = void 0, e2.ISO_3166_ALPHA_2_MAPPINGS = {AD: "Andorra", AE: "United Arab Emirates", AF: "Afghanistan", AG: "Antigua and Barbuda", AI: "Anguilla", AL: "Albania", AM: "Armenia", AO: "Angola", AQ: "Antarctica", AR: "Argentina", AS: "American Samoa", AT: "Austria", AU: "Australia", AW: "Aruba", AX: "\xC5land Islands", AZ: "Azerbaijan", BA: "Bosnia and Herzegovina", BB: "Barbados", BD: "Bangladesh", BE: "Belgium", BF: "Burkina Faso", BG: "Bulgaria", BH: "Bahrain", BI: "Burundi", BJ: "Benin", BL: "Saint Barth\xC3\xA9lemy", BM: "Bermuda", BN: "Brunei Darussalam", BO: "Bolivia (Plurinational State of)", BQ: "Bonaire, Sint Eustatius and Saba", BR: "Brazil", BS: "Bahamas", BT: "Bhutan", BV: "Bouvet Island", BW: "Botswana", BY: "Belarus", BZ: "Belize", CA: "Canada", CC: "Cocos (Keeling) Islands", CD: "Congo, Democratic Republic of the", CF: "Central African Republic", CG: "Congo", CH: "Switzerland", CI: "C\xF3te d'Ivoire", CK: "Cook Islands", CL: "Chile", CM: "Cameroon", CN: "China", CO: "Colombia", CR: "Costa Rica", CU: "Cuba", CV: "Cabo Verde", CW: "Cura\xC3\xA7ao", CX: "Christmas Island", CY: "Cyprus", CZ: "Czechia", DE: "Germany", DJ: "Djibouti", DK: "Denmark", DM: "Dominica", DO: "Dominican Republic", DZ: "Algeria", EC: "Ecuador", EE: "Estonia", EG: "Egypt", EH: "Western Sahara", ER: "Eritrea", ES: "Spain", ET: "Ethiopia", FI: "Finland", FJ: "Fiji", FK: "Falkland Islands (Malvinas)", FM: "Micronesia (Federated States of)", FO: "Faroe Islands", FR: "France", GA: "Gabon", GB: "United Kingdom of Great Britain and Northern Ireland", GD: "Grenada", GE: "Georgia", GF: "French Guiana", GG: "Guernsey", GH: "Ghana", GI: "Gibraltar", GL: "Greenland", GM: "Gambia", GN: "Guinea", GP: "Guadeloupe", GQ: "Equatorial Guinea", GR: "Greece", GS: "South Georgia and the South Sandwich Islands", GT: "Guatemala", GU: "Guam", GW: "Guinea-Bissau", GY: "Guyana", HK: "Hong Kong", HM: "Heard Island and McDonald Islands", HN: "Honduras", HR: "Croatia", HT: "Haiti", HU: "Hungary", ID: "Indonesia", IE: "Ireland", IL: "Israel", IM: "Isle of Man", IN: "India", IO: "British Indian Ocean Territory", IQ: "Iraq", IR: "Iran (Islamic Republic of)", IS: "Iceland", IT: "Italy", JE: "Jersey", JM: "Jamaica", JO: "Jordan", JP: "Japan", KE: "Kenya", KG: "Kyrgyzstan", KH: "Cambodia", KI: "Kiribati", KM: "Comoros", KN: "Saint Kitts and Nevis", KP: "Korea (Democratic People's Republic of) ", KR: "Korea, Republic of", KW: "Kuwait", KY: "Cayman Islands", KZ: "Kazakhstan", LA: "Lao People's Democratic Republic", LB: "Lebanon", LC: "Saint Lucia", LI: "Liechtenstein", LK: "Sri Lanka", LR: "Liberia", LS: "Lesotho", LT: "Lithuania", LU: "Luxembourg", LV: "Latvia", LY: "Libya", MA: "Morocco", MC: "Monaco", MD: "Moldova, Republic of", ME: "Montenegro", MF: "Saint Martin (French part)", MG: "Madagascar", MH: "Marshall Islands", MK: "North Macedonia", ML: "Mali", MM: "Myanmar", MN: "Mongolia", MO: "Macao", MP: "Northern Mariana Islands", MQ: "Martinique", MR: "Mauritania", MS: "Montserrat", MT: "Malta", MU: "Mauritius", MV: "Maldives", MW: "Malawi", MX: "Mexico", MY: "Malaysia", MZ: "Mozambique", NA: "Namibia", NC: "New Caledonia", NE: "Niger", NF: "Norfolk Island", NG: "Nigeria", NI: "Nicaragua", NL: "Netherlands", NO: "Norway", NP: "Nepal", NR: "Nauru", NU: "Niue", NZ: "New Zealand", OM: "Oman", PA: "Panama", PE: "Peru", PF: "French Polynesia", PG: "Papua New Guinea", PH: "Philippines", PK: "Pakistan", PL: "Poland", PM: "Saint Pierre and Miquelon", PN: "Pitcairn", PR: "Puerto Rico", PS: "Palestine, State of", PT: "Portugal", PW: "Palau", PY: "Paraguay", QA: "Qatar", RE: "R\xE9union", RO: "Romania", RS: "Serbia", RU: "Russian Federation", RW: "Rwanda", SA: "Saudi Arabia", SB: "Solomon Islands", SC: "Seychelles", SD: "Sudan", SE: "Sweden", SG: "Singapore", SH: "Saint Helena, Ascension and Tristan da Cunha", SI: "Slovenia", SJ: "Svalbard and Jan Mayen", SK: "Slovakia", SL: "Sierra Leone", SM: "San Marino", SN: "Senegal", SO: "Somalia", SR: "Suriname", SS: "South Sudan", ST: "Sao Tome and Principe", SV: "El Salvador", SX: "Sint Maarten (Dutch part)", SY: "Syrian Arab Republic", SZ: "Eswatini", TC: "Turks and Caicos Islands", TD: "Chad", TF: "French Southern Territories", TG: "Togo", TH: "Thailand", TJ: "Tajikistan", TK: "Tokelau", TL: "Timor-Leste", TM: "Turkmenistan", TN: "Tunisia", TO: "Tonga", TR: "Turkey", TT: "Trinidad and Tobago", TV: "Tuvalu", TW: "Taiwan, Province of China", TZ: "Tanzania, United Republic of", UA: "Ukraine", UG: "Uganda", UM: "United States Minor Outlying Islands", US: "United States of America", UY: "Uruguay", UZ: "Uzbekistan", VA: "Holy See", VC: "Saint Vincent and the Grenadines", VE: "Venezuela (Bolivarian Republic of)", VG: "Virgin Islands (British)", VI: "Virgin Islands (U.S.)", VN: "Viet Nam", VU: "Vanuatu", WF: "Wallis and Futuna", WS: "Samoa", XK: "Kosovo", YE: "Yemen", YT: "Mayotte", ZA: "South Africa", ZM: "Zambia", ZW: "Zimbabwe"}, e2.ISO_3166_ALPHA_2 = Object.keys(e2.ISO_3166_ALPHA_2_MAPPINGS), e2.isIso3166Alpha2Code = n2, e2.getIso3166CountryName = function(t3) {
    if (n2(t3))
      return e2.ISO_3166_ALPHA_2_MAPPINGS[t3];
  };
}(ya = {exports: {}}, ya.exports), ya.exports), ga = nn.string().regex(/^(([a-f0-9]{2}){32})$/i), wa = nn.string().regex(/^(([a-f0-9]{2}){20,64})$/i), ba = nn.string().regex(/^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$/), ka = nn.union([nn.literal("sha1"), nn.literal("sha-256"), nn.literal("sha-384"), nn.literal("sha-512")]), Na = nn.union([nn.literal("sha224"), nn.literal("sha256"), nn.literal("sha384"), nn.literal("sha512"), nn.literal("sha512_256"), nn.literal("sha3_224"), nn.literal("sha3_256"), nn.literal("sha3_384"), nn.literal("sha3_512")]), Ma = nn.union([nn.literal("bitcoin"), nn.literal("ethereum"), nn.literal("stellar"), nn.literal("twitter")]), xa = nn.union([nn.literal("development"), nn.literal("staging"), nn.literal("production")]), Ea = nn.object({minBytes: nn.number().min(20).max(64), maxBytes: nn.number().min(20).max(64)});
nn.record(nn.string(), Ea);
var Sa = nn.string().refine(function(t2) {
  try {
    return (({id: t3}) => {
      try {
        return $t({id: t3}), true;
      } catch (t4) {
        return false;
      }
    })({id: t2});
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid Truestamp Id string"}), Ta = nn.string().refine(function(t2) {
  try {
    return function(t3) {
      va.decode(t3);
    }(t2), true;
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid Base64 encoded string"}), _a = nn.string().refine(function(t2) {
  try {
    return da.fromISO(t2).isValid;
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid ISO8601 timestamp"}), Ia = nn.string().refine(function(t2) {
  try {
    if (!t2.endsWith("Z") && !t2.endsWith("+00:00"))
      return false;
    var e2 = da.fromISO(t2, {zone: "utc"});
    return e2.isValid && e2.offsetNameShort === "UTC";
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid ISO8601 UTC timestamp"}), Za = nn.string().length(2).refine(function(t2) {
  try {
    return pa.isIso3166Alpha2Code(t2);
  } catch (t3) {
    return false;
  }
}, {message: "is not an ISO3166 Alpha 2 country code"}), Aa = nn.object({streetNo: nn.optional(nn.string().min(1).max(8)), streetName: nn.optional(nn.string().min(1).max(64)), streetType: nn.optional(nn.string().min(1).max(16)), floor: nn.optional(nn.string().min(1).max(8)), town: nn.optional(nn.string().min(1).max(64)), region: nn.optional(nn.string().min(1).max(64)), postcode: nn.optional(nn.string().min(1).max(16)), countryCode: nn.optional(Za)}), Da = nn.string().refine(function(t2) {
  try {
    if (!/^[-+]?[0-9]*\.?[0-9]+$/.test(t2))
      return false;
    var e2 = parseFloat(t2);
    return e2 >= -90 && e2 <= 90;
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid Latitude"}), Oa = nn.string().refine(function(t2) {
  try {
    if (!/^[-+]?[0-9]*\.?[0-9]+$/.test(t2))
      return false;
    var e2 = parseFloat(t2);
    return e2 >= -180 && e2 <= 180;
  } catch (t3) {
    return false;
  }
}, {message: "is not a valid Longitude"}), Pa = nn.object({latitude: Da, longitude: Oa}), Ca = nn.object({coordinate: Pa, altitude: nn.optional(nn.number().int().min(-1e5).max(1e5)), ellipsoidalAltitude: nn.optional(nn.number().int().min(-1e5).max(1e5)), floor: nn.optional(nn.number().int().min(0).max(200)), horizontalAccuracy: nn.optional(nn.number().int().min(-1e5).max(1e5)), verticalAccuracy: nn.optional(nn.number().int().min(-1e5).max(1e5)), timestamp: nn.optional(_a), speed: nn.optional(nn.number().int().min(-1e5).max(1e5)), speedAccuracy: nn.optional(nn.number().int().min(-1e4).max(1e4)), course: nn.optional(nn.number().int().min(-360).max(360)), courseAccuracy: nn.optional(nn.number().int().min(-360).max(360)), magneticHeading: nn.optional(nn.number().int().min(0).max(359)), headingAccuracy: nn.optional(nn.number().int().min(-180).max(180)), trueHeading: nn.optional(nn.number().int().min(0).max(359))}), La = nn.object({givenName: nn.optional(nn.string().min(1).max(32)), surname: nn.optional(nn.string().min(1).max(32)), organizationName: nn.optional(nn.string().min(1).max(64)), roles: nn.optional(nn.array(nn.string()).min(1).max(32)), email: nn.optional(nn.string().email()), uri: nn.optional(nn.string().url()), address: nn.optional(Aa)}), Ua = nn.object({publicKey: Ta, signature: Ta, signatureType: nn.literal("ed25519"), signer: nn.optional(La)}), ja = nn.object({asn: nn.optional(nn.nullable(nn.union([nn.number().int(), nn.string()]))), colo: nn.optional(nn.nullable(nn.string().min(1))), country: nn.optional(nn.nullable(nn.string().min(1))), city: nn.optional(nn.nullable(nn.string().min(1))), continent: nn.optional(nn.nullable(nn.string().min(1))), latitude: nn.optional(nn.nullable(nn.string().min(1))), longitude: nn.optional(nn.nullable(nn.string().min(1))), postalCode: nn.optional(nn.nullable(nn.string().min(1))), metroCode: nn.optional(nn.nullable(nn.string().min(1))), region: nn.optional(nn.nullable(nn.string().min(1))), regionCode: nn.optional(nn.nullable(nn.string().min(1))), timezone: nn.optional(nn.nullable(nn.string().min(1)))}), Ra = nn.union([nn.string(), nn.number(), nn.boolean(), nn.null()]), Fa = nn.lazy(function() {
  return nn.union([Ra, nn.array(Fa), nn.record(Fa)]);
}), $a = nn.object({hash: wa, hashType: ka, people: nn.optional(nn.array(La).min(1)), description: nn.optional(nn.string().min(1).max(256)), address: nn.optional(Aa), location: nn.optional(Ca), timestamp: nn.optional(_a), extra: nn.optional(Fa)}), Ba = nn.object({cf: nn.optional(ja), observableEntropy: nn.optional(ga), submittedAt: Ia}), Ga = nn.object({itemData: nn.array($a).min(1), itemSignals: nn.optional(Ba), itemDataSignatures: nn.optional(nn.array(Ua).min(1))}), Ha = Ga.pick({itemData: true, itemDataSignatures: true});
nn.object({id: Sa}), nn.object({owner: nn.string().min(1).max(255), ulid: ba, item: Ga}), nn.object({owner: nn.optional(nn.string().min(1)), inputHash: ga});
var Ka = nn.tuple([nn.number().int().min(0).max(1), wa]), za = nn.object({v: nn.number().int().min(1).max(1), h: Na, p: nn.array(Ka)}), qa = nn.object({inputHash: ga, inclusionProof: za, merkleRoot: ga}), Va = nn.object({inputHash: ga}), Ja = Va.extend({intent: nn.literal("bitcoin"), hash: nn.string().regex(/(0x)?[0-9a-f]+/i)}).strict(), Wa = Va.extend({intent: nn.literal("ethereum"), hash: nn.string().regex(/(0x)?[0-9a-f]+/i)}).strict(), Ya = Va.extend({intent: nn.literal("stellar"), hash: ga, ledger: nn.number().int().min(11111)}).strict(), Qa = Va.extend({intent: nn.literal("twitter"), id: nn.string().regex(/[0-9]+/i)}).strict(), Xa = nn.discriminatedUnion("intent", [Ja, Wa, Ya, Qa]), tu = nn.object({id: Sa, itemData: nn.array($a).min(1), itemDataSignatures: nn.optional(nn.array(Ua).min(1)), itemSignals: nn.optional(Ba), proofs: nn.array(qa), transactions: nn.record(nn.string(), nn.array(Xa).min(1))});
nn.object({commitmentData: tu, commitmentDataSignatures: nn.array(Ua).min(1)});
var eu = nn.object({t: nn.number(), ts: Ia, ulid: ba});
nn.array(eu);
var nu = nn.object({success: nn.boolean(), inputHash: ga, merkleRoot: ga, error: nn.optional(nn.string())}).strict(), ru = nn.object({intent: Ma, success: nn.boolean(), offline: nn.boolean(), transaction: Xa, timestamp: nn.optional(Ia), urls: nn.optional(nn.array(nn.string().url())), error: nn.optional(nn.string())}).strict();
nn.object({id: Sa, success: nn.boolean(), offline: nn.boolean(), testnet: nn.optional(nn.boolean()), itemData: nn.optional(nn.object({hash: ga, signaturesCount: nn.number().int(), signaturesVerified: nn.boolean()})), item: nn.optional(nn.object({hash: ga})), commitmentData: nn.optional(nn.object({hash: ga, signaturesCount: nn.number().int(), signaturesVerified: nn.boolean(), signaturesPublicKeyVerified: nn.boolean()})), proofs: nn.optional(nn.array(nu).min(1)), transactions: nn.optional(nn.array(ru).min(1)), commitsTo: nn.optional(nn.object({hashes: nn.array(wa).min(1), observableEntropy: nn.optional(ga), timestamps: nn.object({submittedAfter: nn.optional(Ia), submittedAt: Ia, submittedBefore: nn.optional(Ia), submitWindowMilliseconds: nn.optional(nn.number().int().min(0).max(31536e6))})})), error: nn.optional(nn.string())}).strict();
var iu = nn.object({environment: xa, expired: nn.boolean(), handle: nn.string().min(1), publicKey: Ta, type: nn.literal("ed25519"), selfSignature: Ta});
nn.array(iu), iu.omit({selfSignature: true}), nn.object({hash: nn.instanceof(Uint8Array), hashHex: ga, hashType: ka, canonicalData: nn.optional(nn.string())});
var su = nn.object({name: nn.string(), hash: ga, hashType: nn.literal("sha256")});
nn.object({hash: ga, hashType: nn.literal("sha256"), hashIterations: nn.number().int().min(1), createdAt: Ia, signature: Ta, prevHash: nn.optional(ga), files: nn.optional(nn.array(su).min(1))});
var au, uu = /* @__PURE__ */ function(t2) {
  function n2() {
    return t2.apply(this, arguments) || this;
  }
  e(n2, t2);
  var r2 = n2.prototype;
  return r2.createItem = function(t3) {
    var e2 = Ha.parse(t3);
    return this.request("items", {method: "POST", body: JSON.stringify(e2)});
  }, r2.updateItem = function(t3, e2) {
    $t({id: t3});
    var n3 = "items/" + t3, r3 = Ha.parse(e2);
    return this.request(n3, {method: "PUT", body: JSON.stringify(r3)});
  }, n2;
}(l), ou = /* @__PURE__ */ function(t2) {
  function n2() {
    return t2.apply(this, arguments) || this;
  }
  return e(n2, t2), n2.prototype.createApiKey = function(t3) {
    return this.request("apikeys", {method: "POST", body: JSON.stringify(t3)});
  }, n2;
}(l), cu = /* @__PURE__ */ function(t2) {
  function n2() {
    return t2.apply(this, arguments) || this;
  }
  return e(n2, t2), n2;
}(l);
au = cu, [Bt, Gt, uu, ou].forEach(function(t2) {
  Object.getOwnPropertyNames(t2.prototype).forEach(function(e2) {
    Object.defineProperty(au.prototype, e2, Object.getOwnPropertyDescriptor(t2.prototype, e2));
  });
});
export default cu;
