const t = (t2) => new DataView(t2.buffer, t2.byteOffset, t2.byteLength), e = (t2, e2) => t2 << 32 - e2 | t2 >>> e2;
if (new Uint8Array(new Uint32Array([287454020]).buffer)[0] !== 68)
  throw new Error("Non little-endian hardware is not supported");
const n = Array.from({length: 256}, (t2, e2) => e2.toString(16).padStart(2, "0"));
function i(t2) {
  let e2 = "";
  for (let i2 = 0; i2 < t2.length; i2++)
    e2 += n[t2[i2]];
  return e2;
}
function s(t2) {
  if (typeof t2 == "string" && (t2 = function(t3) {
    if (typeof t3 != "string")
      throw new TypeError("utf8ToBytes expected string, got " + typeof t3);
    return new TextEncoder().encode(t3);
  }(t2)), !(t2 instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof t2})`);
  return t2;
}
function r(t2) {
  if (!Number.isSafeInteger(t2) || t2 < 0)
    throw new Error(`Wrong positive integer: ${t2}`);
}
(() => {
  const t2 = typeof module != "undefined" && typeof module.require == "function" && module.require.bind(module);
  try {
    t2 && t2("timers");
  } catch (t3) {
  }
})();
class o {
  clone() {
    return this._cloneInto();
  }
}
class c extends o {
  constructor(t2, e2) {
    super(), this.finished = false, this.destroyed = false, function(t3) {
      if (typeof t3 != "function" || typeof t3.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      r(t3.outputLen), r(t3.blockLen);
    }(t2);
    const n2 = s(e2);
    if (this.iHash = t2.create(), !(this.iHash instanceof o))
      throw new TypeError("Expected instance of class which extends utils.Hash");
    const i2 = this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const c3 = new Uint8Array(i2);
    c3.set(n2.length > this.iHash.blockLen ? t2.create().update(n2).digest() : n2);
    for (let t3 = 0; t3 < c3.length; t3++)
      c3[t3] ^= 54;
    this.iHash.update(c3), this.oHash = t2.create();
    for (let t3 = 0; t3 < c3.length; t3++)
      c3[t3] ^= 106;
    this.oHash.update(c3), c3.fill(0);
  }
  update(t2) {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    return this.iHash.update(t2), this;
  }
  digestInto(t2) {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    if (!(t2 instanceof Uint8Array) || t2.length !== this.outputLen)
      throw new Error("HMAC: Invalid output buffer");
    if (this.finished)
      throw new Error("digest() was already called");
    this.finished = true, this.iHash.digestInto(t2), this.oHash.update(t2), this.oHash.digestInto(t2), this.destroy();
  }
  digest() {
    const t2 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t2), t2;
  }
  _cloneInto(t2) {
    t2 || (t2 = Object.create(Object.getPrototypeOf(this), {}));
    const {oHash: e2, iHash: n2, finished: i2, destroyed: s2, blockLen: r2, outputLen: o2} = this;
    return (t2 = t2).finished = i2, t2.destroyed = s2, t2.blockLen = r2, t2.outputLen = o2, t2.oHash = e2._cloneInto(t2.oHash), t2.iHash = n2._cloneInto(t2.iHash), t2;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
}
const h = (t2, e2, n2) => new c(t2, e2).update(n2).digest();
h.create = (t2, e2) => new c(t2, e2);
class a extends o {
  constructor(e2, n2, i2, s2) {
    super(), this.blockLen = e2, this.outputLen = n2, this.padOffset = i2, this.isLE = s2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e2), this.view = t(this.buffer);
  }
  update(e2) {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    const {view: n2, buffer: i2, blockLen: r2, finished: o2} = this;
    if (o2)
      throw new Error("digest() was already called");
    const c2 = (e2 = s(e2)).length;
    for (let s2 = 0; s2 < c2; ) {
      const o3 = Math.min(r2 - this.pos, c2 - s2);
      if (o3 !== r2)
        i2.set(e2.subarray(s2, s2 + o3), this.pos), this.pos += o3, s2 += o3, this.pos === r2 && (this.process(n2, 0), this.pos = 0);
      else {
        const n3 = t(e2);
        for (; r2 <= c2 - s2; s2 += r2)
          this.process(n3, s2);
      }
    }
    return this.length += e2.length, this.roundClean(), this;
  }
  digestInto(e2) {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    if (!(e2 instanceof Uint8Array) || e2.length < this.outputLen)
      throw new Error("_Sha2: Invalid output buffer");
    if (this.finished)
      throw new Error("digest() was already called");
    this.finished = true;
    const {buffer: n2, view: i2, blockLen: s2, isLE: r2} = this;
    let {pos: o2} = this;
    n2[o2++] = 128, this.buffer.subarray(o2).fill(0), this.padOffset > s2 - o2 && (this.process(i2, 0), o2 = 0);
    for (let t2 = o2; t2 < s2; t2++)
      n2[t2] = 0;
    !function(t2, e3, n3, i3) {
      if (typeof t2.setBigUint64 == "function")
        return t2.setBigUint64(e3, n3, i3);
      const s3 = BigInt(32), r3 = BigInt(4294967295), o3 = Number(n3 >> s3 & r3), c3 = Number(n3 & r3), h2 = i3 ? 0 : 4;
      t2.setUint32(e3 + (i3 ? 4 : 0), o3, i3), t2.setUint32(e3 + h2, c3, i3);
    }(i2, s2 - 8, BigInt(8 * this.length), r2), this.process(i2, 0);
    const c2 = t(e2);
    this.get().forEach((t2, e3) => c2.setUint32(4 * e3, t2, r2));
  }
  digest() {
    const {buffer: t2, outputLen: e2} = this;
    this.digestInto(t2);
    const n2 = t2.slice(0, e2);
    return this.destroy(), n2;
  }
  _cloneInto(t2) {
    t2 || (t2 = new this.constructor()), t2.set(...this.get());
    const {blockLen: e2, buffer: n2, length: i2, finished: s2, destroyed: r2, pos: o2} = this;
    return t2.length = i2, t2.pos = o2, t2.finished = s2, t2.destroyed = r2, i2 % e2 && t2.buffer.set(n2), t2;
  }
}
const u = (t2, e2, n2) => t2 & e2 ^ t2 & n2 ^ e2 & n2, f = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), d = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), l = new Uint32Array(64);
class p extends a {
  constructor() {
    super(64, 32, 8, false), this.A = 0 | d[0], this.B = 0 | d[1], this.C = 0 | d[2], this.D = 0 | d[3], this.E = 0 | d[4], this.F = 0 | d[5], this.G = 0 | d[6], this.H = 0 | d[7];
  }
  get() {
    const {A: t2, B: e2, C: n2, D: i2, E: s2, F: r2, G: o2, H: c2} = this;
    return [t2, e2, n2, i2, s2, r2, o2, c2];
  }
  set(t2, e2, n2, i2, s2, r2, o2, c2) {
    this.A = 0 | t2, this.B = 0 | e2, this.C = 0 | n2, this.D = 0 | i2, this.E = 0 | s2, this.F = 0 | r2, this.G = 0 | o2, this.H = 0 | c2;
  }
  process(t2, n2) {
    for (let e2 = 0; e2 < 16; e2++, n2 += 4)
      l[e2] = t2.getUint32(n2, false);
    for (let t3 = 16; t3 < 64; t3++) {
      const n3 = l[t3 - 15], i3 = l[t3 - 2], s3 = e(n3, 7) ^ e(n3, 18) ^ n3 >>> 3, r3 = e(i3, 17) ^ e(i3, 19) ^ i3 >>> 10;
      l[t3] = r3 + l[t3 - 7] + s3 + l[t3 - 16] | 0;
    }
    let {A: i2, B: s2, C: r2, D: o2, E: c2, F: h2, G: a2, H: d2} = this;
    for (let t3 = 0; t3 < 64; t3++) {
      const n3 = d2 + (e(c2, 6) ^ e(c2, 11) ^ e(c2, 25)) + ((p3 = c2) & h2 ^ ~p3 & a2) + f[t3] + l[t3] | 0, y2 = (e(i2, 2) ^ e(i2, 13) ^ e(i2, 22)) + u(i2, s2, r2) | 0;
      d2 = a2, a2 = h2, h2 = c2, c2 = o2 + n3 | 0, o2 = r2, r2 = s2, s2 = i2, i2 = n3 + y2 | 0;
    }
    var p3;
    i2 = i2 + this.A | 0, s2 = s2 + this.B | 0, r2 = r2 + this.C | 0, o2 = o2 + this.D | 0, c2 = c2 + this.E | 0, h2 = h2 + this.F | 0, a2 = a2 + this.G | 0, d2 = d2 + this.H | 0, this.set(i2, s2, r2, o2, c2, h2, a2, d2);
  }
  roundClean() {
    l.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const y = function(t2) {
  const e2 = (e3) => t2().update(s(e3)).digest(), n2 = t2();
  return e2.outputLen = n2.outputLen, e2.blockLen = n2.blockLen, e2.create = () => t2(), e2;
}(() => new p());
class v extends TypeError {
  constructor(t2, e2) {
    let n2;
    const {message: i2, ...s2} = t2, {path: r2} = t2;
    super(r2.length === 0 ? i2 : "At path: " + r2.join(".") + " -- " + i2), this.value = void 0, this.key = void 0, this.type = void 0, this.refinement = void 0, this.path = void 0, this.branch = void 0, this.failures = void 0, Object.assign(this, s2), this.name = this.constructor.name, this.failures = () => {
      var i3;
      return (i3 = n2) != null ? i3 : n2 = [t2, ...e2()];
    };
  }
}
function w(t2) {
  return typeof t2 == "object" && t2 != null;
}
function m(t2) {
  if (Object.prototype.toString.call(t2) !== "[object Object]")
    return false;
  const e2 = Object.getPrototypeOf(t2);
  return e2 === null || e2 === Object.prototype;
}
function g(t2) {
  return typeof t2 == "string" ? JSON.stringify(t2) : "" + t2;
}
function b(t2, e2, n2, i2) {
  if (t2 === true)
    return;
  t2 === false ? t2 = {} : typeof t2 == "string" && (t2 = {message: t2});
  const {path: s2, branch: r2} = e2, {type: o2} = n2, {refinement: c2, message: h2 = "Expected a value of type `" + o2 + "`" + (c2 ? " with refinement `" + c2 + "`" : "") + ", but received: `" + g(i2) + "`"} = t2;
  return {value: i2, type: o2, refinement: c2, key: s2[s2.length - 1], path: s2, branch: r2, ...t2, message: h2};
}
function* E(t2, e2, n2, i2) {
  var s2;
  w(s2 = t2) && typeof s2[Symbol.iterator] == "function" || (t2 = [t2]);
  for (const s3 of t2) {
    const t3 = b(s3, e2, n2, i2);
    t3 && (yield t3);
  }
}
function* H(t2, e2, n2 = {}) {
  const {path: i2 = [], branch: s2 = [t2], coerce: r2 = false, mask: o2 = false} = n2, c2 = {path: i2, branch: s2};
  if (r2 && (t2 = e2.coercer(t2, c2), o2 && e2.type !== "type" && w(e2.schema) && w(t2) && !Array.isArray(t2)))
    for (const n3 in t2)
      e2.schema[n3] === void 0 && delete t2[n3];
  let h2 = true;
  for (const n3 of e2.validator(t2, c2))
    h2 = false, yield [n3, void 0];
  for (let [n3, a2, u2] of e2.entries(t2, c2)) {
    const e3 = H(a2, u2, {path: n3 === void 0 ? i2 : [...i2, n3], branch: n3 === void 0 ? s2 : [...s2, a2], coerce: r2, mask: o2});
    for (const i3 of e3)
      i3[0] ? (h2 = false, yield [i3[0], void 0]) : r2 && (a2 = i3[1], n3 === void 0 ? t2 = a2 : t2 instanceof Map ? t2.set(n3, a2) : t2 instanceof Set ? t2.add(a2) : w(t2) && (t2[n3] = a2));
  }
  if (h2)
    for (const n3 of e2.refiner(t2, c2))
      h2 = false, yield [n3, void 0];
  h2 && (yield [void 0, t2]);
}
class I {
  constructor(t2) {
    this.TYPE = void 0, this.type = void 0, this.schema = void 0, this.coercer = void 0, this.validator = void 0, this.refiner = void 0, this.entries = void 0;
    const {type: e2, schema: n2, validator: i2, refiner: s2, coercer: r2 = (t3) => t3, entries: o2 = function* () {
    }} = t2;
    this.type = e2, this.schema = n2, this.entries = o2, this.coercer = r2, this.validator = i2 ? (t3, e3) => E(i2(t3, e3), e3, this, t3) : () => [], this.refiner = s2 ? (t3, e3) => E(s2(t3, e3), e3, this, t3) : () => [];
  }
  assert(t2) {
    return $(t2, this);
  }
  create(t2) {
    return A(t2, this);
  }
  is(t2) {
    return L(t2, this);
  }
  mask(t2) {
    return function(t3, e2) {
      const n2 = x(t3, e2, {coerce: true, mask: true});
      if (n2[0])
        throw n2[0];
      return n2[1];
    }(t2, this);
  }
  validate(t2, e2 = {}) {
    return x(t2, this, e2);
  }
}
function $(t2, e2) {
  const n2 = x(t2, e2);
  if (n2[0])
    throw n2[0];
}
function A(t2, e2) {
  const n2 = x(t2, e2, {coerce: true});
  if (n2[0])
    throw n2[0];
  return n2[1];
}
function L(t2, e2) {
  return !x(t2, e2)[0];
}
function x(t2, e2, n2 = {}) {
  const i2 = H(t2, e2, n2), s2 = function(t3) {
    const {done: e3, value: n3} = t3.next();
    return e3 ? void 0 : n3;
  }(i2);
  return s2[0] ? [new v(s2[0], function* () {
    for (const t3 of i2)
      t3[0] && (yield t3[0]);
  }), void 0] : [void 0, s2[1]];
}
function k(t2, e2) {
  return new I({type: t2, schema: null, validator: e2});
}
function U(t2, e2) {
  const {schema: n2} = t2, i2 = {};
  for (const t3 of e2)
    i2[t3] = n2[t3];
  return j(i2);
}
function _() {
  return k("integer", (t2) => typeof t2 == "number" && !isNaN(t2) && Number.isInteger(t2) || "Expected an integer, but received: " + g(t2));
}
function j(t2) {
  const e2 = t2 ? Object.keys(t2) : [], n2 = k("never", () => false);
  return new I({type: "object", schema: t2 || null, *entries(i2) {
    if (t2 && w(i2)) {
      const s2 = new Set(Object.keys(i2));
      for (const n3 of e2)
        s2.delete(n3), yield [n3, i2[n3], t2[n3]];
      for (const t3 of s2)
        yield [t3, i2[t3], n2];
    }
  }, validator: (t3) => w(t3) || "Expected an object, but received: " + g(t3), coercer: (t3) => w(t3) ? {...t3} : t3});
}
function O() {
  return k("string", (t2) => typeof t2 == "string" || "Expected a string, but received: " + g(t2));
}
function C(t2, e2, n2 = {}) {
  return function(t3, i2, s2) {
    return new I({...t3, coercer: (s3, r2) => L(s3, i2) ? t3.coercer(((t4) => {
      const i3 = typeof e2 == "function" ? e2() : e2;
      if (t4 === void 0)
        return i3;
      if (!n2.strict && m(t4) && m(i3)) {
        const e3 = {...t4};
        let n3 = false;
        for (const t5 in i3)
          e3[t5] === void 0 && (e3[t5] = i3[t5], n3 = true);
        if (n3)
          return e3;
      }
      return t4;
    })(s3), r2) : t3.coercer(s3, r2)});
  }(t2, k("unknown", () => true));
}
function B(t2, e2) {
  return T(t2, "pattern", (n2) => e2.test(n2) || "Expected a " + t2.type + " matching `/" + e2.source + '/` but received "' + n2 + '"');
}
function T(t2, e2, n2) {
  return new I({...t2, *refiner(i2, s2) {
    yield* t2.refiner(i2, s2);
    const r2 = E(n2(i2, s2), s2, t2, i2);
    for (const t3 of r2)
      yield {...t3, refinement: e2};
  }});
}
const S = j({prefix: C(function(t2) {
  const e2 = {}, n2 = t2.map((t3) => g(t3)).join();
  for (const n3 of t2)
    e2[n3] = n3;
  return new I({type: "enums", schema: e2, validator: (e3) => t2.includes(e3) || "Expected one of `" + n2 + "`, but received: " + g(e3)});
}(["T"]), "T"), version: function(t2, e2, n2 = e2) {
  const i2 = "Expected a " + t2.type, s2 = e2 === n2 ? "of `" + e2 + "`" : "between `" + e2 + "` and `" + n2 + "`";
  return T(t2, "size", (t3) => {
    if (typeof t3 == "number" || t3 instanceof Date)
      return e2 <= t3 && t3 <= n2 || i2 + " " + s2 + " but received `" + t3 + "`";
    if (t3 instanceof Map || t3 instanceof Set) {
      const {size: r2} = t3;
      return e2 <= r2 && r2 <= n2 || i2 + " with a size " + s2 + " but received one with a size of `" + r2 + "`";
    }
    {
      const {length: r2} = t3;
      return e2 <= r2 && r2 <= n2 || i2 + " with a length " + s2 + " but received one with a length of `" + r2 + "`";
    }
  });
}(_(), 1, 1), test: C(k("boolean", (t2) => typeof t2 == "boolean"), false), ulid: B(O(), /^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$/), timestamp: function(t2, e2, n2 = {}) {
  const {exclusive: i2} = n2;
  return T(t2, "min", (n3) => i2 ? n3 > e2 : n3 >= e2 || "Expected a " + t2.type + " greater than " + (i2 ? "" : "or equal to ") + e2 + " but received `" + n3 + "`");
}(_(), 16409952e8), envelopeHash: B(O(), /^(([a-f0-9]{2}){20,64})$/i), hmacKey: B(O(), /^(([a-f0-9]{2}){32,64})$/i), hmac: B(O(), /^(([A-F0-9]{2}){16})$/i), id: B(O(), /^T(1)(0|1)_[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}_[0-9]{16}_[0-9A-F]{32}$/)}), N = U(S, ["id"]), D = U(S, ["prefix", "version", "test", "ulid", "timestamp", "hmac"]), F = U(S, ["version", "test", "ulid", "timestamp", "envelopeHash", "hmacKey"]), K = U(S, ["id", "envelopeHash", "hmacKey"]), G = U(S, ["version", "test", "ulid", "timestamp", "envelopeHash"]), M = U(S, ["version", "test", "ulid", "timestamp"]), P = (t2) => {
  try {
    const e2 = A(t2, N), [n2, i2, s2, r2] = e2.id.split("_"), [o2, c2, h2] = n2.split(""), a2 = {prefix: o2, version: parseInt(c2, 10), test: parseInt(h2, 10) == 1, ulid: i2, timestamp: parseInt(s2, 10), hmac: r2};
    return $(a2, D), a2;
  } catch (t3) {
    throw t3 instanceof v ? new Error(`Invalid Id structure: ${t3.message}`) : t3 instanceof Error ? new Error(`Invalid Id: ${t3.message}`) : t3;
  }
}, z = (t2) => {
  const e2 = A(t2, F), n2 = `T${e2.version}${e2.test ? 1 : 0}_${e2.ulid}_${e2.timestamp}`;
  return `${n2}_${i(h(y, e2.hmacKey, `${n2}_${e2.envelopeHash}`).slice(0, 16)).toUpperCase()}`;
}, q = (t2) => {
  try {
    const e2 = A(t2, K), {prefix: n2, version: s2, test: r2, ulid: o2, timestamp: c2, hmac: a2} = P({id: e2.id});
    if (i(h(y, e2.hmacKey, `${n2}${s2}${r2 ? 1 : 0}_${o2}_${c2}_${e2.envelopeHash}`)).slice(0, 32).toUpperCase() !== a2)
      throw new Error(`Invalid HMAC for Id: ${e2.id}`);
    return A({version: s2, test: r2, ulid: o2, timestamp: c2, envelopeHash: e2.envelopeHash}, G);
  } catch (t3) {
    throw t3 instanceof v ? new Error(`Invalid Id structure: ${t3.message}`) : t3 instanceof Error ? new Error(`Invalid Id: ${t3.message}`) : t3;
  }
}, J = ({id: t2}) => {
  const {version: e2, test: n2, ulid: i2, timestamp: s2} = P({id: t2});
  try {
    return A({version: e2, test: n2, ulid: i2, timestamp: s2}, M);
  } catch (t3) {
    throw t3 instanceof v ? new Error(`Invalid Id structure: ${t3.message}`) : t3 instanceof Error ? new Error(`Invalid Id: ${t3.message}`) : t3;
  }
}, V = (t2) => {
  try {
    const e2 = A(t2, K);
    return q({id: e2.id, envelopeHash: e2.envelopeHash, hmacKey: e2.hmacKey}), true;
  } catch (t3) {
    return false;
  }
}, W = ({id: t2}) => {
  try {
    return J({id: t2}), true;
  } catch (t3) {
    return false;
  }
};
export {q as decode, J as decodeUnsafely, z as encode, V as isValid, W as isValidUnsafely};
export default null;
